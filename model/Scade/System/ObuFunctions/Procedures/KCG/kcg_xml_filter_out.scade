/* $*************** KCG Version 6.1.3 (build i6) ****************
** Command: x2s613 C:/Users/Baseliyos/Documents/GitHub_05_2015/model/Scade/System/ObuFunctions/Procedures/ManageProcedure_Pkg.xscade
** Generation date: 2015-05-27T21:43:20
*************************************************************$ */

/* xscade source: C:/Users/Baseliyos/Documents/GitHub_05_2015/model/Scade/System/ObuFunctions/Procedures/ManageProcedure_Pkg.xscade */
package ManageProcedure_Pkg
  const
    cNID_BG_Radio_Header : Radio_Types_Pkg::Radio_TrackTrain_Header_T
      = {
          radioDevice:0,
          receivedSystemTime:0,
          nid_message:0,
          t_train:0.0,
          m_ack:M_ACK_No_acknowledgement_required,
          nid_lrbg:0,
          t_train_reference:0.0,
          nid_em:0,
          q_scale:Q_SCALE_10_cm_scale,
          d_sr:0,
          t_sh_rqst:0.0,
          d_ref:0,
          q_dir:Q_DIR_Reverse,
          d_emergencystop:0,
          m_version:M_VERSION_Previous_versions_according_to_e_g_EEIG_SRS_and_UIC_A200_SRS };
  
  const
    cpacket42_to_MoRC : Packet_Types_Pkg::P42_SessionManagement_T
      = {
          valid:false,
          q_dir:Q_DIR_Reverse,
          q_rbc:Q_RBC_Terminate_communication_session,
          nid_c:0,
          nid_rbc:0,
          nid_radio:0,
          q_sleepsession:Q_SLEEPSESSION_Ignore_session_establishment_order };
  
  const cpacket45_nid_mn_to_MoRC : NID_MN = 1234;
  
  const
    cpacket45_to_MoRC : Packet_Types_Pkg::P45_RadioNetworkRegistration_T
      = { valid:false, q_dir:Q_DIR_Reverse, nid_mn:0 };
  
  const
    cpacket42_q_rbc_ni_rbc_nid_radio_q_sleepsession_to_MoRC
      : Packet_Types_Pkg::P42_SessionManagement_T
      = {
          valid:false,
          q_dir:Q_DIR_Both_directions,
          q_rbc:Q_RBC_Establish_communication_session,
          nid_c:426,
          nid_rbc:1234,
          nid_radio:1234,
          q_sleepsession:Q_SLEEPSESSION_Ignore_session_establishment_order };
  
  const
    cdefault_manageT : Common_Types_Pkg::radioManagementMessage_T
      = {
          valid:false,
          messageSource:Common_Types_Pkg::msrc_undefined,
          Radio_Common_Header:{
              radioDevice:0,
              receivedSystemTime:0,
              nid_message:0,
              t_train:0.0,
              m_ack:M_ACK_No_acknowledgement_required,
              nid_lrbg:0,
              t_train_reference:0.0,
              nid_em:0,
              q_scale:Q_SCALE_10_cm_scale,
              d_sr:0,
              t_sh_rqst:0.0,
              d_ref:0,
              q_dir:Q_DIR_Reverse,
              d_emergencystop:0,
              m_version:M_VERSION_Previous_versions_according_to_e_g_EEIG_SRS_and_UIC_A200_SRS },
          p42:{
              valid:false,
              q_dir:Q_DIR_Reverse,
              q_rbc:Q_RBC_Terminate_communication_session,
              nid_c:0,
              nid_rbc:0,
              nid_radio:0,
              q_sleepsession:Q_SLEEPSESSION_Ignore_session_establishment_order },
          p45:{ valid:false, q_dir:Q_DIR_Reverse, nid_mn:0 } };
  
  type
    radioManagementMessage_T = {
      valid : bool,
      messageSource : Common_Types_Pkg::MsgSource_T,
      Radio_Common_Header : Radio_Types_Pkg::Radio_TrackTrain_Header_T,
      p42 : Packet_Types_Pkg::P42_SessionManagement_T,
      p45 : Packet_Types_Pkg::P45_RadioNetworkRegistration_T
    };
  
  node Master_Procedure(
      statusDMI_from_DMI : DMI_Types_Pkg::DMI_EVC_status_T;
      Status_MA_FS_SR_OS_LS_SH_from_MA_L2_Management : bool;
      Status_Mode_Change_from_Level_and_Mode_Management : bool;
      systemtime : Obu_BasicTypes_Pkg::T_internal_Type;
      mobileSwStatus_p_from_MoRC : MoRC_Pck::mobileSWStatus_Type;
      statusRBCSessioneEstabilished_status_from_MoRC
      : Radio_Types_Pkg::sessionStatus_Type;
      cabStatus_from_TIU : TIU_Types_Pkg::TIU_trainStatus_T;
      statusValid_Position_from_Position_Calculation : bool;
      statusLevel_from_Level_and_Mode_Management : bool)
    returns (
      DMI_Entry_Request_to_DMI
      : DMI_Messages_EVC_to_DMI_Pkg::DMI_Entry_Request_T;
      request_Start_Mobile_Terminal_and_RBC_Registration_to_MoRC
      : Common_Types_Pkg::radioManagementMessage_T;
      powerUp_to_MoRC : bool;
      statusstartofmissionongoing_to_MoRC : bool;
      powerOff_to_MoRC : bool;
      request_MA_FS_SR_OS_LS_SH_to_MA_L2_Management : bool;
      request_Mode_Change_SB_to_FS_to_Level_and_Mode_Management : bool;
      start_ack_to_TIU : bool default = false last = false)
  sig
    requestDriverID_to_DMI, requestStartRBCSession_to_MoRC,
    requestStartMobileTerminalRegistration_to_MoRC, power_Up_to_MoRC,
    requestTrainData_to_DMI, requestLevelStaus_from_Level_Management,
    power_Off_to_MoRC, requestSoM_to_DMI, requestTrainNumber_to_DMI;
  var
    statusCabOpen_from_TIU : bool;
    statusTrainNumberfirstvalidation_from_DMI : bool;
    statusValid_position_from_Positon_Calculation : bool;
    statusLevel2_or_3_from_Level_Management : bool;
    statusMobileRegistrated_from_MoRC : bool;
    statusRBCSessionEstablishmen_from_MoRC : bool;
    statusDriverID_from_DMI : bool;
    statusTrainData_from_DMI : bool;
    statusTrainNumbersecondvalidation_from_DMI : bool;
    statusStart_from_DMI : bool;
    statusAcknowledgementPositionReport_from_RBC : bool;
    sendingPositionReport_to_RBC : bool last = true;
    sendingTrainData_to_RBC : bool last = true;
    statusAcknowledgementofTrainData_from_RBC : bool;
    _L1 : bool;
    _L2 : DMI_Messages_EVC_to_DMI_Pkg::DMI_Entry_Request_T;
    _L3 : DMI_Types_Pkg::DMI_List_Entry_Request_T;
    _L4 : Obu_BasicTypes_Pkg::T_internal_Type;
    _L5 : DMI_Types_Pkg::DMI_EVC_status_T;
    _L21 : DMI_Types_Pkg::DMI_List_Entry_Request_T;
    _L22 : DMI_Types_Pkg::DMI_List_Entry_Request_T;
    _L23 : DMI_Types_Pkg::DMI_List_Entry_Request_T;
    _L25 : bool;
    _L28 : DMI_Types_Pkg::DMI_List_Entry_Request_T;
    _L29 : Common_Types_Pkg::radioManagementMessage_T;
    _L37 : Common_Types_Pkg::MsgSource_T;
    _L39 : Radio_Types_Pkg::Radio_TrackTrain_Header_T;
    _L40 : Packet_Types_Pkg::P42_SessionManagement_T;
    _L47 : Packet_Types_Pkg::P45_RadioNetworkRegistration_T;
    _L49 : Q_DIR;
    _L50 : NID_MN;
    _L61 : Common_Types_Pkg::radioManagementMessage_T;
    _L63 : Common_Types_Pkg::MsgSource_T;
    _L65 : Radio_Types_Pkg::Radio_TrackTrain_Header_T;
    _L67 : bool;
    _L69 : bool;
    _L70 : Common_Types_Pkg::radioManagementMessage_T;
    _L71 : MoRC_Pck::mobileSWStatus_Type;
    _L82 : MoRC_Pck::mobileSWConnectionStatus_Type;
    _L83 : bool;
    _L84 : MoRC_Pck::mobileSWConnectionStatus_Type;
    _L85 : Radio_Types_Pkg::sessionStatus_Type;
    _L86 : bool;
    _L89 : Radio_Types_Pkg::sessionStatus_Type;
    _L91 : bool;
    _L96 : bool;
    _L97 : TIU_Types_Pkg::TIU_trainStatus_T;
    _L104 : bool;
    _L105 : bool;
    _L107 : DMI_Types_Pkg::DMI_List_Entry_Request_T;
    _L108 : DMI_Types_Pkg::DMI_List_Entry_Request_T;
    _L125 : bool;
    _L126 : bool;
    _L127 : bool;
    _L128 : bool;
    _L130 : bool;
    _L131 : bool;
    _L147 : Packet_Types_Pkg::P42_SessionManagement_T;
    _L149 : Q_DIR;
    _L151 : Packet_Types_Pkg::P45_RadioNetworkRegistration_T;
    _L153 : Packet_Types_Pkg::P42_SessionManagement_T;
    _L154 : Common_Types_Pkg::radioManagementMessage_T;
    _L164 : bool;
    _L165 : DMI_Types_Pkg::DMI_List_Entry_Request_T;
    _L166 : DMI_Types_Pkg::DMI_List_Entry_Request_T;
    _L167 : bool;
    _L168 : bool;
    _L193 : bool;
    _L192 : Q_DIR;
    _L191 : Q_RBC;
    _L190 : NID_C;
    _L189 : NID_RBC;
    _L188 : NID_RADIO;
    _L187 : Q_SLEEPSESSION;
    _L194 : Common_Types_Pkg::radioManagementMessage_T;
    _L195 : bool;
    _L213 : bool;
    _L212 : bool;
    _L209 : bool;
    _L216 : bool;
    _L214 : bool;
    _L217 : bool;
    _L218 : bool;
    _L219 : bool;
  let
    
    automaton SM1
      initial state NP
        unless
          if statusCabOpen_from_TIU
            do let emit 'power_Up_to_MoRC; tel restart Awakness_of_Train;
        var
          _L1 : bool;
          _L3 : bool;
          _L2 : bool;
        let
          _L1= true;
          statusstartofmissionongoing_to_MoRC= _L1;
          request_Mode_Change_SB_to_FS_to_Level_and_Mode_Management= _L2;
          request_MA_FS_SR_OS_LS_SH_to_MA_L2_Management= _L3;
          _L2= false;
          _L3= false;
        tel

      state Awakness_of_Train
        unless
          if not statusCabOpen_from_TIU
            do let emit 'power_Off_to_MoRC; tel restart NP;
        var
          _L2 : bool;
          _L3 : bool;
          _L5 : bool;
        let
          
          automaton SM3
            state Waition_for_Driver_ID
              unless
                if statusDriverID_from_DMI
                  do let
                    emit 'requestTrainNumber_to_DMI;
                  tel restart first_Validation_for_Train_Number;

            state first_Validation_for_Train_Number
              unless
                if statusTrainNumberfirstvalidation_from_DMI and
                statusValid_position_from_Positon_Calculation
                  do let
                    emit 'requestLevelStaus_from_Level_Management;
                  tel restart request_Level;

            state request_Level
              unless
                if statusLevel2_or_3_from_Level_Management
                  do let
                    emit 'requestStartMobileTerminalRegistration_to_MoRC;
                  tel restart Waiting_for_Mobile_terminal_registration;

            state Waiting_for_RBC_Establishment
              unless
                if statusRBCSessionEstablishmen_from_MoRC
                  do let
                    sendingPositionReport_to_RBC= true;
                  tel restart Acknowlege_of_Position_from_RBC;

            state Acknowlege_of_Position_from_RBC
              unless
                if statusAcknowledgementPositionReport_from_RBC
                  do let
                    emit 'requestTrainData_to_DMI;
                  tel restart Validation_of_Train_Data_from_Driver;

            state Validation_of_Train_Data_from_Driver
              unless
                if statusTrainData_from_DMI
                  do let
                    emit 'requestTrainData_to_DMI;
                  tel restart Second_Validation_of_Train_Number_from_Driver;

            state Second_Validation_of_Train_Number_from_Driver
              unless
                if statusTrainNumbersecondvalidation_from_DMI
                  do let
                    sendingTrainData_to_RBC= true;
                  tel restart Waiting_for_Acknowledgement_of_Train_Data_from_RBC;

            state Waiting_for_Acknowledgement_of_Train_Data_from_RBC
              unless
                if statusAcknowledgementofTrainData_from_RBC
                  do let
                    emit 'requestSoM_to_DMI;
                  tel restart Waiting_of_Start_from_Driver;

            state Waiting_of_Start_from_Driver

            initial state SB
              unless
                if true
                  do let
                    emit 'requestDriverID_to_DMI;
                  tel restart Waition_for_Driver_ID;

            state Waiting_for_Mobile_terminal_registration
              unless
                if statusMobileRegistrated_from_MoRC
                  do let
                    emit 'requestStartRBCSession_to_MoRC;
                  tel restart Waiting_for_RBC_Establishment;
          returns ..;
          statusstartofmissionongoing_to_MoRC= _L2;
          _L2= true;
          request_MA_FS_SR_OS_LS_SH_to_MA_L2_Management= _L5;
          request_Mode_Change_SB_to_FS_to_Level_and_Mode_Management= _L3;
          _L3= false;
          _L5= false;
        tel
        until
          if statusStart_from_DMI and statusLevel2_or_3_from_Level_Management
            do restart SoM_L2_3_FS_SR_OS_LS_SH;

      state SoM_L2_3_FS_SR_OS_LS_SH
        var
          _L5 : bool;
          _L4 : bool;
          _L9 : bool;
          _L10 : bool;
          _L12 : bool;
          _L13 : bool;
        let
          _L4, _L5, _L13=
            #1 SoMProcedure_Pkg::SoM_SR_FS_OS_LS_SH_SN_UN(_L9, _L10);
          _L9= Status_MA_FS_SR_OS_LS_SH_from_MA_L2_Management;
          _L10= Status_Mode_Change_from_Level_and_Mode_Management;
          request_MA_FS_SR_OS_LS_SH_to_MA_L2_Management= _L4;
          request_Mode_Change_SB_to_FS_to_Level_and_Mode_Management= _L5;
          statusstartofmissionongoing_to_MoRC= _L12;
          _L12= false;
          start_ack_to_TIU= _L13;
        tel
    returns ..;
    _L1= 'requestDriverID_to_DMI;
    _L2=
      (make DMI_Messages_EVC_to_DMI_Pkg::DMI_Entry_Request_T)(_L25, _L4, _L22);
    _L3= DMI_Types_Pkg::Enter_revalidate_driver_identifier;
    _L4= systemtime;
    _L5= statusDMI_from_DMI;
    _L21= DMI_Types_Pkg::Enter_revalidate_train_running_number;
    _L22= if _L1 then _L3 else _L23;
    _L23= if _L168 then _L21 else _L107;
    _L25= _L1 or _L168 or _L105 or _L164;
    _L28= DMI_Types_Pkg::Spare;
    DMI_Entry_Request_to_DMI= _L2;
    statusTrainNumberfirstvalidation_from_DMI= _L104;
    _L29=
      (make Common_Types_Pkg::radioManagementMessage_T)(_L67, _L37, _L39, _L40,
        _L47);
    _L37= Common_Types_Pkg::msrc_OBU;
    _L39= cNID_BG_Radio_Header;
    _L40= cpacket42_to_MoRC;
    _L47=
      (make Packet_Types_Pkg::P45_RadioNetworkRegistration_T)(_L67, _L49, _L50);
    _L49= Q_DIR_Both_directions;
    _L50= cpacket45_nid_mn_to_MoRC;
    _L61=
      (make Common_Types_Pkg::radioManagementMessage_T)(_L69, _L63, _L65, _L147,
        _L151);
    _L63= Common_Types_Pkg::msrc_OBU;
    _L65= cNID_BG_Radio_Header;
    _L67= 'requestStartMobileTerminalRegistration_to_MoRC;
    request_Start_Mobile_Terminal_and_RBC_Registration_to_MoRC= _L70;
    _L69= 'requestStartRBCSession_to_MoRC;
    _L70= if _L67 then _L29 else _L154;
    _L71= mobileSwStatus_p_from_MoRC;
    _L82= MoRC_Pck::mswc_registered;
    _L83= _L84 = _L82;
    statusMobileRegistrated_from_MoRC= _L83;
    _L84= _L71.connectionStatus;
    _L85= Radio_Types_Pkg::morc_st_maintaining;
    _L86= _L89 = _L85;
    _L89= statusRBCSessioneEstabilished_status_from_MoRC;
    statusRBCSessionEstablishmen_from_MoRC= _L86;
    _L91= 'power_Up_to_MoRC;
    powerUp_to_MoRC= _L91;
    _L96= _L218 and _L219;
    _L97= cabStatus_from_TIU;
    statusCabOpen_from_TIU= _L96;
    _L104= _L5.DMI_TrainRunningNumberFirstValidation;
    _L105= 'requestTrainData_to_DMI;
    _L107= if _L105 then _L108 else _L165;
    _L108= DMI_Types_Pkg::Validate_train_data;
    _L125= _L5.DMI_DriverIdValidated;
    statusDriverID_from_DMI= _L125;
    _L126= _L5.DMI_TrainDataValidated;
    statusTrainData_from_DMI= _L126;
    _L127= _L5.DMI_TrainRunningNumberValidated;
    statusTrainNumbersecondvalidation_from_DMI= _L127;
    _L128= 'requestLevelStaus_from_Level_Management;
    _= _L128;
    statusValid_position_from_Positon_Calculation= _L130;
    _L130= statusValid_Position_from_Position_Calculation;
    powerOff_to_MoRC= _L131;
    _L131= 'power_Off_to_MoRC;
    _L147=
      (make Packet_Types_Pkg::P42_SessionManagement_T)(_L69, _L149, _L191,
        _L190, _L189, _L188, _L187);
    _L149= Q_DIR_Both_directions;
    _L151= cpacket45_to_MoRC;
    _L153= cpacket42_q_rbc_ni_rbc_nid_radio_q_sleepsession_to_MoRC;
    _L154= if _L69 then _L61 else _L194;
    _L164= 'requestSoM_to_DMI;
    _L165= if _L164 then _L166 else _L28;
    _L166= DMI_Types_Pkg::Show_main_window;
    statusLevel2_or_3_from_Level_Management= _L195;
    _L167= _L5.DMI_StartReceived;
    statusStart_from_DMI= _L167;
    _L168= 'requestTrainNumber_to_DMI;
    _L193, _L192, _L191, _L190, _L189, _L188, _L187=
      (flatten Packet_Types_Pkg::P42_SessionManagement_T)(_L153);
    _= _L193;
    _= _L192;
    _L194= cdefault_manageT;
    _L195= statusLevel_from_Level_and_Mode_Management;
    _L213= false;
    _L212= fby(_L209; 4; _L213);
    _L209= sendingPositionReport_to_RBC;
    statusAcknowledgementPositionReport_from_RBC= _L212;
    _L214= fby(_L217; 4; _L216);
    _L216= false;
    _L217= sendingTrainData_to_RBC;
    statusAcknowledgementofTrainData_from_RBC= _L214;
    _L218= _L97.deskOpen;
    _L219= _L97.valid;
  tel
  
end;

/* $*************** KCG Version 6.1.3 (build i6) ****************
** -
** Generation date: 2015-05-27T21:43:20
*************************************************************$ */
/* $*************** KCG Version 6.1.3 (build i6) ****************
** Command: x2s613 C:/Users/Baseliyos/Documents/GitHub_05_2015/model/Scade/System/ObuFunctions/Procedures/SoMProcedure_Pkg.xscade
** Generation date: 2015-05-27T21:43:20
*************************************************************$ */

/* xscade source: C:/Users/Baseliyos/Documents/GitHub_05_2015/model/Scade/System/ObuFunctions/Procedures/SoMProcedure_Pkg.xscade */
package SoMProcedure_Pkg
  node SoM_SR_FS_OS_LS_SH_SN_UN(
      Status_MA_FS_SR_OS_LS_SH_from_MA_L2_Management : bool;
      Status_Mode_Change_from_Level_and_Mode_Management : bool)
    returns (
      request_MA_FS_SR_OS_LS_SH_to_MA_L2_Management : bool;
      request_Mode_Change_SB_to_FS_to_Level_and_Mode_Management : bool;
      start_ack_to_TIU : bool default = false)
  sig
    requestMA_SoM_L2_3_FS_SR_OS_LS_SH,
    requestModeChange_SB_FS_to_Mode_and_Level_Management;
  var
    acknowledge_MA_L2_FS_from_MA_L2_Management : bool;
    acknowledge_Mode_Change_SB_to_FS_from_Level_and_Mode_Management : bool;
    _L1 : bool;
    _L5 : bool;
    _L6 : bool;
    _L8 : bool;
    _L4 : bool;
  let
    
    automaton SM1
      initial state State1
        unless
          if true
            do let
              emit 'requestMA_SoM_L2_3_FS_SR_OS_LS_SH;
            tel restart Waiting_for_MA_for_FS_or_SR_or_OS_LS_SH;

      state Waiting_for_MA_for_FS_or_SR_or_OS_LS_SH
        unless
          if acknowledge_MA_L2_FS_from_MA_L2_Management
            do let
              emit 'requestModeChange_SB_FS_to_Mode_and_Level_Management;
            tel restart Wait_for_Acknowledgment_for_mode_change_SB_to_FS_from_mode_and_Level_Management;

      state Wait_for_Acknowledgment_for_mode_change_SB_to_FS_from_mode_and_Level_Management
        unless
          if acknowledge_Mode_Change_SB_to_FS_from_Level_and_Mode_Management
            restart FS_Mode;

      state FS_Mode
        var
          _L2 : bool;
        let
          start_ack_to_TIU= _L2;
          _L2= true;
        tel
    returns ..;
    _L1= 'requestMA_SoM_L2_3_FS_SR_OS_LS_SH;
    request_MA_FS_SR_OS_LS_SH_to_MA_L2_Management= _L1;
    acknowledge_MA_L2_FS_from_MA_L2_Management= _L4;
    _L5= 'requestModeChange_SB_FS_to_Mode_and_Level_Management;
    _= _L5;
    _L6= Status_Mode_Change_from_Level_and_Mode_Management;
    request_Mode_Change_SB_to_FS_to_Level_and_Mode_Management= _L8;
    acknowledge_Mode_Change_SB_to_FS_from_Level_and_Mode_Management= _L6;
    _L8= false;
    _L4= Status_MA_FS_SR_OS_LS_SH_from_MA_L2_Management;
  tel
  
end;

/* $*************** KCG Version 6.1.3 (build i6) ****************
** -
** Generation date: 2015-05-27T21:43:20
*************************************************************$ */
/* $*************** KCG Version 6.1.3 (build i6) ****************
** Command: x2s613 C:/Program Files/Esterel Technologies/SCADE R15.2/SCADE/libraries/libdigital/digital.xscade
** Generation date: 2015-05-27T21:43:20
*************************************************************$ */

/* xscade source: C:/Program Files/Esterel Technologies/SCADE R15.2/SCADE/libraries/libdigital/digital.xscade */
package digital
  node FallingEdge(FE_Input : bool) returns (FE_Output : bool)
  var
    _L1 : bool;
    _L3 : bool;
    _L4 : bool;
    _L5 : bool;
  let
    _L1= FE_Input;
    FE_Output= _L3;
    _L3= _L4 and _L5;
    _L4= fby(_L1; 1; _L1);
    _L5= not _L1;
  tel
  
  node FallingEdgeNoRetrigger(FENR_Input : bool; NumberOfCycle : int)
    returns (FENR_Output : bool)
  var
    _L10 : bool;
    _L11 : bool;
    _L12 : bool;
    _L22 : int;
    _L23 : bool;
    _L26 : int;
    _L36 : bool;
    _L37 : bool;
    _L9 : bool;
    _L40 : bool;
    _L47 : bool;
    _L50 : bool;
    _L61 : bool;
    _L63 : bool;
    _L64 : bool;
    _L65 : int;
    _L68 : int;
  let
    _L9= FENR_Input;
    FENR_Output= _L40;
    _L10= pre _L9;
    _L11= not _L9;
    _L12= _L11 and _L10;
    _L22= 0;
    _L23= _L22 < _L65;
    _L26= NumberOfCycle;
    _L36= _L37 and _L63;
    _L37= not _L50;
    _L40= _L47 and _L23;
    _L47= _L50 or _L63;
    _L50= fby(_L40; 1; _L61);
    _L61= false;
    _L63= _L64 -> _L12;
    _L64= false;
    _L65= (activate #13 count_down every _L47 initial default _L68)(_L36, _L26);
    _L68= 0;
  tel
  
  node FallingEdgeRetrigger(FER_Input : bool; NumberOfCycle : int)
    returns (FER_Output : bool)
  var
    _L1 : bool;
    _L76 : bool;
    _L74 : bool;
    _L73 : bool;
    _L71 : int;
    _L70 : bool;
    _L68 : bool;
    _L65 : bool;
    _L64 : bool;
    _L63 : int;
    _L62 : bool;
    _L61 : bool;
    _L59 : bool;
    _L77 : int;
    _L79 : int;
  let
    _L1= FER_Input;
    FER_Output= _L62;
    _L76= _L63 < _L77;
    _L74= false;
    _L73= fby(_L62; 1; _L74);
    _L71= NumberOfCycle;
    _L70= false;
    _L68= _L61 and _L59;
    _L65= _L73 or _L64;
    _L64= _L70 -> _L68;
    _L63= 0;
    _L62= _L65 and _L76;
    _L61= not _L1;
    _L59= pre _L1;
    _L77= (activate #11 count_down every _L65 initial default _L79)(_L64, _L71);
    _L79= 0;
  tel
  
  node FlipFlopJK(Set : bool; Reset : bool; Init : bool)
    returns (FFJK_Output : bool)
  var
    _L10 : bool;
    _L11 : bool;
    _L12 : bool;
    _L2 : bool;
    _L4 : bool;
    _L5 : bool;
    _L6 : bool;
    _L9 : bool;
    _L18 : bool;
    _L20 : bool;
    _L21 : bool;
  let
    _L2= _L9 -> _L10;
    _L4= pre _L2;
    _L5= Set;
    _L6= Reset;
    _L9= Init;
    FFJK_Output= _L2;
    _L10= if _L12 then _L11 else _L18;
    _L11= not _L4;
    _L12= _L5 and _L6;
    _L18= _L5 or _L21;
    _L20= not _L6;
    _L21= _L20 and _L4;
  tel
  
  node #pragma kcg expand #end FlipFlopReset(
      Set : bool;
      Reset : bool;
      Init : bool)
    returns (FFR_Output : bool)
  var
    _L10 : bool;
    _L2 : bool;
    _L4 : bool;
    _L7 : bool;
    _L8 : bool;
    _L11 : bool;
    _L12 : bool;
    _L14 : bool;
  let
    _L2= _L10 -> _L14;
    _L4= pre _L2;
    _L7= Set;
    _L8= Reset;
    FFR_Output= _L2;
    _L10= Init;
    _L11= _L7 or _L4;
    _L12= not _L8;
    _L14= _L12 and _L11;
  tel
  
  node #pragma kcg expand #end FlipFlopSet(
      Set : bool;
      Reset : bool;
      Init : bool)
    returns (FFS_Output : bool)
  var
    _L10 : bool;
    _L2 : bool;
    _L4 : bool;
    _L5 : bool;
    _L6 : bool;
    _L11 : bool;
    _L12 : bool;
    _L13 : bool;
  let
    _L2= _L10 -> _L13;
    _L4= pre _L2;
    FFS_Output= _L2;
    _L5= Set;
    _L6= Reset;
    _L10= Init;
    _L11= not _L6;
    _L12= _L11 and _L4;
    _L13= _L5 or _L12;
  tel
  
  node RisingEdge(RE_Input : bool) returns (RE_Output : bool)
  var
    _L1 : bool;
    _L6 : bool;
    _L3 : bool;
    _L8 : bool;
  let
    _L1= RE_Input;
    RE_Output= _L6;
    _L3= fby(_L1; 1; _L1);
    _L6= _L8 and _L1;
    _L8= not _L3;
  tel
  
  node RisingEdgeRetrigger(RER_Input : bool; NumberOfCycle : int)
    returns (RER_Output : bool)
  var
    _L13 : bool;
    _L14 : bool;
    _L16 : bool;
    _L31 : bool;
    _L44 : int;
    _L43 : bool;
    _L41 : int;
    _L39 : bool;
    _L38 : bool;
    _L36 : bool;
    _L35 : bool;
    _L46 : bool;
    _L47 : bool;
    _L48 : int;
    _L50 : int;
  let
    RER_Output= _L43;
    _L13= RER_Input;
    _L14= pre _L31;
    _L16= _L13 and _L14;
    _L31= not _L13;
    _L44= 0;
    _L43= _L38 and _L35;
    _L41= NumberOfCycle;
    _L39= fby(_L43; 1; _L36);
    _L38= _L39 or _L46;
    _L36= false;
    _L35= _L44 < _L48;
    _L46= _L47 -> _L16;
    _L47= false;
    _L48= (activate #11 count_down every _L38 initial default _L50)(_L46, _L41);
    _L50= 0;
  tel
  
  function #pragma kcg expand #end Toggle(T_Input : bool)
    returns (T_On : bool; T_Off : bool)
  var
    _L3 : bool;
    _L9 : bool;
  let
    _L3= T_Input;
    T_On= _L3;
    T_Off= _L9;
    _L9= not _L3;
  tel
  
  node RisingEdgeNoRetrigger(RENR_Input : bool; NumberOfCycle : int)
    returns (RENR_Output : bool)
  var
    _L90 : bool;
    _L87 : bool;
    _L86 : int;
    _L85 : bool;
    _L84 : bool;
    _L82 : bool;
    _L81 : bool;
    _L80 : int;
    _L79 : bool;
    _L78 : bool;
    _L77 : bool;
    _L76 : bool;
    _L75 : bool;
    _L91 : bool;
    _L92 : bool;
    _L93 : int;
    _L95 : int;
  let
    RENR_Output= _L78;
    _L90= _L80 < _L93;
    _L87= fby(_L78; 1; _L92);
    _L86= NumberOfCycle;
    _L85= _L91 and _L76;
    _L84= false;
    _L82= _L87 or _L79;
    _L81= _L75 and _L79;
    _L80= 0;
    _L79= _L84 -> _L85;
    _L78= _L82 and _L90;
    _L77= not _L91;
    _L76= pre _L77;
    _L75= not _L87;
    _L91= RENR_Input;
    _L92= false;
    _L93= (activate #13 count_down every _L82 initial default _L95)(_L81, _L86);
    _L95= 0;
  tel
  
  node count_down(Reset : bool; N : int) returns (cpt : int)
  var
    _L1 : bool;
    _L2 : int;
    _L3 : int;
    _L4 : int;
    _L7 : int;
    _L8 : int;
    _L13 : int;
  let
    _L1= Reset;
    _L2= N;
    cpt= _L3;
    _L3= if _L1 then _L2 else _L8;
    _L4= _L3 - _L7;
    _L7= 1;
    _L8= _L2 -> _L13;
    _L13= pre _L4;
  tel
  
  node EitherEdge(EE_Input : bool) returns (EE_Output : bool)
  var
    _L1 : bool;
    _L3 : bool;
    _L4 : bool;
  let
    _L1= EE_Input;
    EE_Output= _L3;
    _L3= _L4 xor _L1;
    _L4= fby(_L1; 1; _L1);
  tel
  
  function #pragma kcg expand #end BoolVect2IntElt(Acc : int; bi : bool)
    returns (AccOut : int)
  var
    _L1 : int;
    _L2 : bool;
    _L4 : int;
    _L5 : int;
    _L6 : int;
    _L7 : int;
    _L8 : int;
    _L9 : int;
  let
    AccOut= _L8;
    _L1= Acc;
    _L2= bi;
    _L4= _L1 * _L9;
    _L5= if _L2 then _L6 else _L7;
    _L6= 1;
    _L7= 0;
    _L8= _L5 + _L4;
    _L9= 2;
  tel
  
  function Int2BoolVectElt(Acc : int) returns (AccOut : int; bi : bool)
  var
    _L1 : int;
    _L9 : int;
    _L10 : int;
    _L11 : int;
    _L12 : bool;
    _L13 : int;
  let
    AccOut= _L10;
    _L1= Acc;
    _L9= 2;
    _L10= _L1 div _L9;
    bi= _L12;
    _L11= _L1 mod _L9;
    _L12= _L11 = _L13;
    _L13= 1;
  tel
  
  function BoolVect2Int<<Nbool>>(BV : bool^Nbool) returns (Out : int)
  var
    _L2 : int;
    _L3 : int;
    _L4 : bool^Nbool;
  let
    _L2= (fold #1 BoolVect2IntElt <<Nbool>>)(_L3, _L4);
    _L3= 0;
    _L4= BV;
    Out= _L2;
  tel
  
  function Int2BoolVect<<Nbool>>(In : int) returns (BV : bool^Nbool)
  var
    #pragma kcg keep #end Acc : int;
    _L1 : int;
    _L4 : bool^Nbool;
    _L5 : bool^Nbool;
  let
    _L1= In;
    BV= _L5;
    Acc, _L4= (mapfold #1 Int2BoolVectElt <<Nbool>>)(_L1);
    _L5= reverse _L4;
    _= Acc;
  tel
  
end;

/* $*************** KCG Version 6.1.3 (build i6) ****************
** -
** Generation date: 2015-05-27T21:43:20
*************************************************************$ */
/* $*************** KCG Version 6.1.3 (build i6) ****************
** Command: x2s613 C:/Program Files/Esterel Technologies/SCADE R15.2/SCADE/libraries/libdigital/TruthTables.xscade
** Generation date: 2015-05-27T21:43:20
*************************************************************$ */

/* xscade source: C:/Program Files/Esterel Technologies/SCADE R15.2/SCADE/libraries/libdigital/TruthTables.xscade */
package truthtables
  open digital;
  type TruthTableValues = enum { T, F, X };
  
  function TruthTableElt(AccIn : bool; Cond : bool; TTelt : TruthTableValues)
    returns (AccOut : bool)
  var
    _L1 : bool;
    _L2 : bool;
    _L13 : bool;
    _L15 : bool;
    _L14 : bool;
    _L16 : bool;
    _L17 : TruthTableValues;
  let
    _L1= _L2 and _L13;
    _L2= AccIn;
    AccOut= _L1;
    _L13= (case _L17 of | T: _L14 | F: _L15 | _: _L16);
    _L14= Cond;
    _L15= not _L14;
    _L16= true;
    _L17= TTelt;
  tel
  
  function TruthTableLineIdx<<Ncond>>(
      Idx : int;
      AccIn : int;
      Conditions : bool^Ncond;
      TTline : TruthTableValues^Ncond)
    returns (AccOut : int)
  var
    _L2 : bool;
    _L3 : int;
    _L4 : int;
    _L8 : int;
    _L10 : bool^Ncond;
    _L11 : bool;
    _L12 : TruthTableValues^Ncond;
  let
    _L2= (fold #1 TruthTableElt <<Ncond>>)(_L11, _L10, _L12);
    _L3= if _L2 then _L8 else _L4;
    AccOut= _L3;
    _L4= AccIn;
    _L8= Idx;
    _L10= Conditions;
    _L11= true;
    _L12= TTline;
  tel
  
  function TruthTableIdx<<Ncond, Nlines>>(
      Conditions : bool^Ncond;
      Ttable : TruthTableValues^Ncond^Nlines)
    returns (LineIdx : int)
  var
    _L1 : bool^Ncond;
    _L2 : TruthTableValues^Ncond^Nlines;
    _L6 : int;
    _L8 : bool^Ncond^Nlines;
    _L9 : TruthTableValues^Ncond^Nlines;
    _L10 : int;
    _L11 : int;
    _L12 : int;
  let
    _L1= Conditions;
    _L2= Ttable;
    LineIdx= _L10;
    _L6= -1;
    _L8= _L1^Nlines;
    _L9= reverse _L2;
    _L10= _L11 - _L12;
    _L11= Nlines - 1;
    _L12= (foldi (#2 TruthTableLineIdx <<Ncond>>) <<Nlines>>)(_L6, _L8, _L9);
  tel
  
  function TruthTableExh<<Nbool, Nres>>(BV : bool^Nbool; ResultValues : 'T^Nres)
    returns (Result : 'T)
  var
    _L1 : bool^Nbool;
    _L3 : 'T;
    _L4 : 'T^Nres;
    _L5 : int;
  let
    _L1= BV;
    _L3= (_L4.[_L5] default ResultValues[0]);
    _L4= ResultValues;
    Result= _L3;
    _L5= (#3 BoolVect2Int <<Nbool>>)(_L1);
    assume A1 : Nres = (fold #2 $*$ <<Nbool>>)(1, 2^Nbool);
  tel
  
  function TruthTableLine<<Ncond>>(
      AccIn : 'T;
      Conditions : bool^Ncond;
      ResultValue : 'T;
      TTline : TruthTableValues^Ncond)
    returns (Continue : bool; AccOut : 'T)
  var
    _L2 : bool;
    _L3 : 'T;
    _L4 : 'T;
    _L10 : bool^Ncond;
    _L11 : bool;
    _L12 : TruthTableValues^Ncond;
    _L14 : 'T;
    _L15 : bool;
  let
    _L2= (fold #1 TruthTableElt <<Ncond>>)(_L11, _L10, _L12);
    _L3= if _L2 then _L14 else _L4;
    AccOut= _L3;
    _L4= AccIn;
    _L10= Conditions;
    _L11= true;
    _L12= TTline;
    _L14= ResultValue;
    Continue= _L15;
    _L15= not _L2;
  tel
  
  function TruthTable<<Ncond, Nlines>>(
      Conditions : bool^Ncond;
      ResultValues : 'T^(Nlines + 1);
      Ttable : TruthTableValues^Ncond^Nlines)
    returns (Result : 'T)
  var
    _L1 : bool^Ncond;
    _L2 : TruthTableValues^Ncond^Nlines;
    _L7 : 'T^(Nlines + 1);
    _L9 : bool^Ncond^Nlines;
    _L12 : 'T;
    _L16 : 'T^(Nlines + 1);
    _L17 : bool;
    _L19 : 'T;
    _L18 : int;
    _L21 : 'T^(Nlines - 1 - 0 + 1);
  let
    _L1= Conditions;
    _L2= Ttable;
    Result= _L19;
    _L7= ResultValues;
    _L9= _L1^Nlines;
    _L12= _L16[Nlines];
    _L16= ResultValues;
    _L17= true;
    _L18, _L19=
      (foldw (#4 TruthTableLine <<Ncond>>) <<Nlines>> if _L17)(_L12, _L9, _L21,
        _L2);
    _= _L18;
    _L21= _L7 [0 .. Nlines - 1];
  tel
  
end;

/* $*************** KCG Version 6.1.3 (build i6) ****************
** -
** Generation date: 2015-05-27T21:43:20
*************************************************************$ */
/* $*************** KCG Version 6.1.3 (build i6) ****************
** Command: x2s613 C:/Program Files/Esterel Technologies/SCADE R15.2/SCADE/libraries/liblinear/linear.xscade
** Generation date: 2015-05-27T21:43:20
*************************************************************$ */

/* xscade source: C:/Program Files/Esterel Technologies/SCADE R15.2/SCADE/libraries/liblinear/linear.xscade */
package linear
  function #pragma kcg expand #end Gain(G_Input : 'T; Gain : 'T)
    returns (G_Output : 'T)
    where 'T numeric
  var
    _L1 : 'T;
    _L2 : 'T;
    _L3 : 'T;
  let
    _L1= G_Input;
    _L2= Gain;
    G_Output= _L3;
    _L3= _L1 * _L2;
  tel
  
  node MeanCycle2(U : 'T) returns (MeanOn2Steps : real) where 'T numeric
  var
    _L1 : 'T;
    _L13 : 'T;
    _L14 : 'T;
    _L8 : real;
    _L9 : 'T;
  let
    _L1= U;
    MeanOn2Steps= _L8;
    _L8= _L14 / _L9;
    _L9= (2 : 'T);
    _L13= fby(_L1; 1; _L1);
    _L14= _L1 + _L13;
  tel
  
  node MeanCycle3(U : 'T) returns (MeanOn3Step : real) where 'T numeric
  var
    _L10 : 'T;
    _L11 : 'T;
    _L12 : real;
    _L6 : 'T;
    _L7 : 'T;
    _L9 : 'T;
  let
    MeanOn3Step= _L12;
    _L6= U;
    _L7= fby(_L6; 1; _L6);
    _L9= fby(_L7; 1; _L6);
    _L10= (3 : 'T);
    _L11= _L6 + _L7 + _L9;
    _L12= _L11 / _L10;
  tel
  
  node Derivative(u : real; TimeCycle : real) returns (Derivative : real)
  var
    _L1 : real;
    _L2 : real;
    _L3 : real;
    _L6 : real;
    _L7 : real;
    _L8 : real;
    _L9 : real;
  let
    _L1= _L3 - _L2;
    _L2= pre _L3;
    _L3= u;
    Derivative= _L6;
    _L6= _L7 -> _L8;
    _L7= 0.0;
    _L8= _L1 / _L9;
    _L9= TimeCycle;
  tel
  
  node #pragma kcg expand #end Filter1stOrderLoop(
      F1OL_Input : real;
      K1 : real;
      K2 : real;
      Init : real)
    returns (F1OL_Output : real)
  var
    _L9 : real;
    _L8 : real;
    _L7 : real;
    _L6 : real;
    _L5 : real;
    _L4 : real;
    _L3 : real;
    _L2 : real;
    _L1 : real;
  let
    _L9= Init;
    _L8= _L9 -> _L7;
    _L7= _L4 - _L6;
    _L6= _L5 * _L2;
    _L5= pre _L8;
    _L4= _L3 * _L1;
    F1OL_Output= _L8;
    _L3= F1OL_Input;
    _L2= K2;
    _L1= K1;
  tel
  
  node IntegrTrapez(
      U : real;
      Reset : bool;
      TimeCycle : real;
      LowLimit : real;
      HiLimit : real)
    returns (Y : real)
  var
    _L1 : real;
    _L10 : real;
    _L11 : real;
    _L12 : real;
    _L2 : real;
    _L3 : real;
    _L4 : real;
    _L6 : real;
    _L7 : real;
    _L8 : real;
    _L9 : real;
    _L13 : real;
    _L14 : real;
    _L15 : real;
    _L16 : real;
    _L17 : bool;
    _L18 : bool;
    _L20 : real;
    _L21 : real;
    _L22 : bool;
  let
    _L2= TimeCycle;
    _L3= pre _L1;
    _L4= pre _L20;
    _L6= _L4 + _L7;
    _L7= _L12 * _L8;
    _L8= _L2 / _L11;
    _L9= _L10 -> _L6;
    Y= _L20;
    _L10= 0.0;
    _L11= 2.0;
    _L12= _L1 + _L3;
    _L1= U;
    _L13= LowLimit;
    _L14= HiLimit;
    _L15= if _L17 then _L13 else _L9;
    _L16= if _L18 then _L14 else _L15;
    _L17= _L9 <= _L13;
    _L18= _L15 >= _L14;
    _L20= if _L22 then _L21 else _L16;
    _L21= 0.0;
    _L22= Reset;
  tel
  
  node IntegrFwd(
      U : real;
      Reset : bool;
      TimeCycle : real;
      LowLimit : real;
      HiLimit : real)
    returns (Y : real)
  var
    _L17 : bool;
    _L16 : bool;
    _L15 : real;
    _L14 : real;
    _L13 : real;
    _L12 : real;
    _L11 : real;
    _L8 : real;
    _L7 : real;
    _L5 : real;
    _L4 : real;
    _L3 : real;
    _L1 : real;
    _L19 : real;
    _L21 : real;
    _L22 : bool;
  let
    _L17= _L14 >= _L13;
    _L16= _L7 <= _L12;
    _L15= if _L17 then _L13 else _L14;
    _L14= if _L16 then _L12 else _L7;
    _L13= HiLimit;
    _L12= LowLimit;
    _L11= U;
    _L8= 0.0;
    Y= _L19;
    _L7= _L8 -> _L4;
    _L5= _L11 * _L1;
    _L4= _L3 + _L5;
    _L3= pre _L19;
    _L1= TimeCycle;
    _L19= if _L22 then _L21 else _L15;
    _L21= 0.0;
    _L22= Reset;
  tel
  
  node #pragma kcg expand #end Memory(
      M_Input : 'T;
      Reset : bool;
      MemCond : bool;
      InitVal : 'T)
    returns (Out : 'T)
  var
    _L8 : 'T;
    _L7 : 'T;
    _L6 : 'T;
    _L5 : 'T;
    _L3 : bool;
    _L2 : 'T;
    _L1 : bool;
    _L9 : 'T;
  let
    Out= _L8;
    _L8= if _L1 then _L2 else _L7;
    _L7= if _L3 then _L6 else _L5;
    _L6= M_Input;
    _L5= fby(_L8; 1; _L9);
    _L3= MemCond;
    _L2= InitVal;
    _L1= Reset;
    _L9= InitVal;
  tel
  
  node HitCrossingEither(HCE_Input : 'T; Offset : 'T)
    returns (HCE_Output : bool)
    where 'T numeric
  var
    _L1 : 'T;
    _L5 : 'T;
    _L24 : bool;
    _L25 : bool;
    _L26 : bool;
    _L28 : bool;
    _L29 : bool;
    _L30 : bool;
    _L31 : bool;
    _L43 : 'T;
  let
    _L1= HCE_Input;
    _L5= Offset;
    _L24= _L43 <= _L5;
    _L25= _L1 >= _L5;
    _L26= _L24 and _L25;
    _L28= _L43 >= _L5;
    _L29= _L1 <= _L5;
    _L30= _L28 and _L29;
    _L31= _L26 or _L30;
    HCE_Output= _L31;
    _L43= fby(_L1; 1; _L1);
  tel
  
  node HitCrossingFalling(HCF_Input : 'T; Offset : 'T)
    returns (HCF_Output : bool)
    where 'T numeric
  var
    _L1 : 'T;
    _L5 : 'T;
    _L10 : bool;
    _L18 : bool;
    _L22 : 'T;
    _L24 : bool;
    _L25 : bool;
    _L26 : bool;
    _L27 : bool;
    _L28 : bool;
    _L29 : bool;
    _L30 : bool;
  let
    _L1= HCF_Input;
    _L5= Offset;
    _L10= _L18 -> _L30;
    _L18= false;
    _L22= pre _L1;
    _L24= _L22 >= _L5;
    _L25= _L1 < _L5;
    _L26= _L24 and _L25;
    HCF_Output= _L10;
    _L27= _L22 > _L5;
    _L28= _L1 = _L5;
    _L29= _L27 and _L28;
    _L30= _L26 or _L29;
  tel
  
  node HitCrossingRising(HCR_Input : 'T; Offset : 'T)
    returns (HCR_Output : bool)
    where 'T numeric
  var
    _L1 : 'T;
    _L5 : 'T;
    _L10 : bool;
    _L18 : bool;
    _L22 : 'T;
    _L24 : bool;
    _L25 : bool;
    _L26 : bool;
    _L27 : bool;
    _L28 : bool;
    _L29 : bool;
    _L30 : bool;
  let
    _L1= HCR_Input;
    _L5= Offset;
    _L10= _L18 -> _L30;
    _L18= false;
    _L22= pre _L1;
    _L24= _L22 <= _L5;
    _L25= _L1 > _L5;
    _L26= _L24 and _L25;
    HCR_Output= _L10;
    _L27= _L22 < _L5;
    _L28= _L1 = _L5;
    _L29= _L27 and _L28;
    _L30= _L26 or _L29;
  tel
  
  node #pragma kcg expand #end MemoryBasic(
      BM_Input : 'T;
      Init : 'T;
      Write : bool)
    returns (Memorized : 'T)
  var
    _L2 : 'T;
    _L4 : 'T;
    _L5 : bool;
    _L6 : 'T;
    _L7 : 'T;
  let
    _L2= BM_Input;
    Memorized= _L4;
    _L4= if _L5 then _L2 else _L6;
    _L5= Write;
    _L6= fby(_L4; 1; _L7);
    _L7= Init;
  tel
  
end;

/* $*************** KCG Version 6.1.3 (build i6) ****************
** -
** Generation date: 2015-05-27T21:43:20
*************************************************************$ */
/* $*************** KCG Version 6.1.3 (build i6) ****************
** Command: x2s613 C:/Program Files/Esterel Technologies/SCADE R15.2/SCADE/libraries/liblinear/filters.xscade
** Generation date: 2015-05-27T21:43:20
*************************************************************$ */

/* xscade source: C:/Program Files/Esterel Technologies/SCADE R15.2/SCADE/libraries/liblinear/filters.xscade */
package filters
  node TransferFcn01(In : real; Num : real; Den : real^2) returns (Out : real)
  var
    _L44 : real;
    _L40 : real;
    _L29 : real;
    _L65 : real;
    _L66 : real;
    _L69 : real;
    _L72 : real;
    _L77 : real;
    _L78 : real;
  let
    Out= _L65;
    _L44= _L72 * _L65;
    _L40= _L29 * _L69;
    _L29= In;
    _L65= _L77 / _L78;
    _L66= _L40 - _L44;
    _L69= Num;
    _L72= Den[1];
    _L77= fby(_L66; 1; 0.0);
    _L78= Den[0];
  tel
  
  node private SumDelay(Delay : real; Val : real) returns (Out : real)
  var
    _L2 : real;
    _L3 : real;
    _L15 : real;
    _L21 : real;
  let
    _L2= Delay;
    _L3= Val;
    Out= _L15;
    _L15= _L21 + _L3;
    _L21= fby(_L2; 1; 0.0);
  tel
  
  node Filter01(In : real; Num : real; Den : real^2) returns (Out : real)
  var
    _L46 : real;
    _L66 : real;
    _L69 : real;
    _L71 : real;
    _L72 : real;
    _L73 : real;
    _L74 : real;
    _L76 : real;
    _L77 : real;
  let
    _L46= _L73 / _L66;
    Out= _L46;
    _L66= Den[0];
    _L69= In;
    _L71= _L69 * _L72;
    _L72= Num;
    _L73= _L71 - _L77;
    _L74= _L76 * _L46;
    _L76= Den[1];
    _L77= fby(_L74; 1; 0.0);
  tel
  
  node Filter11(In : real; Num : real^2; Den : real^2) returns (Out : real)
  var
    _L200 : real;
    _L203 : real;
    _L229 : real;
    _L230 : real;
    _L231 : real;
    _L232 : real;
    _L233 : real;
    _L234 : real;
    _L235 : real;
    _L243 : real;
    _L244 : real;
    _L245 : real;
  let
    _L203= In;
    _L200= _L230 * _L203;
    _L229= _L231 / _L245;
    Out= _L229;
    _L230= Num[0];
    _L231= _L200 + _L244;
    _L232= Den[1];
    _L233= Num[1];
    _L234= _L203 * _L233;
    _L235= _L232 * _L229;
    _L243= _L234 - _L235;
    _L244= fby(_L243; 1; 0.0);
    _L245= Den[0];
  tel
  
  node Filter0D<<Ds>>(In : real; Num : real; Den : real^Ds) returns (Out : real)
  var
    _L3 : real;
    _L14 : real^(Ds - 1);
    _L68 : real;
    _L73 : real^(Ds - 1);
    _L16 : real^(Ds - 1);
    _L116 : real;
    _L126 : real;
    _L129 : real;
    _L132 : real^(Ds - 1 - 1 + 1);
    _L134 : real^Ds;
    _L135 : real;
    _L136 : real;
    _L137 : real;
    _L138 : real;
  let
    _L3= In;
    _L14= reverse _L16;
    _L68= (fold #2 SumDelay <<Ds - 1>>)(_L126, _L14);
    Out= _L116;
    _L73= _L116^(Ds - 1);
    _L116= _L138 / _L136;
    _L126= 0.0;
    _L129= _L3 * _L135;
    _L132= _L134 [1 .. Ds - 1];
    _L134= Den;
    _L135= Num;
    _L136= Den[0];
    _L137= fby(_L68; 1; 0.0);
    _L138= _L129 - _L137;
    _L16= (map #14 $*$ <<Ds - 1>>)(_L132, _L73);
  tel
  
  node FilterNN<<Ns>>(In : real; Num : real^Ns; Den : real^Ns)
    returns (Out : real)
  var
    _L3 : real;
    _L7 : real^(Ns - 1);
    _L68 : real;
    _L71 : real^(Ns - 1);
    _L73 : real^(Ns - 1);
    _L10 : real^(Ns - 1);
    _L16 : real^(Ns - 1);
    _L116 : real;
    _L126 : real;
    _L128 : real^(Ns - 1);
    _L129 : real^Ns;
    _L132 : real^Ns;
    _L133 : real;
    _L134 : real^(Ns - 1 - 1 + 1);
    _L135 : real;
    _L141 : real;
    _L140 : real;
    _L142 : real;
    _L143 : real;
    _L144 : real^(Ns - 1 - 1 + 1);
  let
    _L3= In;
    _L7= _L3^(Ns - 1);
    _L68= (fold #3 SumDelay <<Ns - 1>>)(_L126, _L128);
    Out= _L116;
    _L73= _L116^(Ns - 1);
    _L116= _L143 / _L133;
    _L126= 0.0;
    _L128= reverse _L71;
    _L129= Num;
    _L132= Den;
    _L133= Den[0];
    _L134= _L129 [1 .. Ns - 1];
    _L135= fby(_L68; 1; 0.0);
    _L140= Num[0];
    _L141= In;
    _L142= _L141 * _L140;
    _L143= _L142 + _L135;
    _L144= _L132 [1 .. Ns - 1];
    _L10= (map #19 $*$ <<Ns - 1>>)(_L7, _L134);
    _L16= (map #22 $*$ <<Ns - 1>>)(_L144, _L73);
    _L71= (map #25 $-$ <<Ns - 1>>)(_L10, _L16);
  tel
  
  node FilterND<<Ns, Ds>>(In : real; Num : real^Ns; Den : real^Ds)
    returns (Out : real)
  var
    _L7 : real^(Ns - 1);
    _L68 : real;
    _L71 : real^(Ds - 1);
    _L73 : real^(Ds - 1);
    _L10 : real^(Ns - 1);
    _L16 : real^(Ds - 1);
    _L116 : real;
    _L118 : real;
    _L120 : real^(Ns - 1 + (Ds - Ns));
    _L124 : real^(Ds - Ns);
    _L126 : real;
    _L128 : real;
    _L129 : real^(Ds - 1);
    _L130 : real^Ns;
    _L133 : real^Ds;
    _L134 : real;
    _L135 : real^(Ds - 1 - 1 + 1);
    _L136 : real^(Ns - 1 - 1 + 1);
    _L137 : real;
    _L139 : real;
    _L138 : real;
    _L140 : real;
    _L143 : real;
  let
    _L7= _L128^(Ns - 1);
    _L68= (fold #3 SumDelay <<Ds - 1>>)(_L126, _L129);
    Out= _L116;
    _L73= _L116^(Ds - 1);
    _L116= _L137 / _L134;
    _L118= 0.0;
    _L120= _L10 @ _L124;
    _L124= _L118^(Ds - Ns);
    _L126= 0.0;
    _L128= In;
    _L129= reverse _L71;
    _L130= Num;
    _L133= Den;
    _L134= Den[0];
    _L135= _L133 [1 .. Ds - 1];
    _L136= _L130 [1 .. Ns - 1];
    _L137= _L140 + _L143;
    _L138= In;
    _L139= Num[0];
    _L140= _L138 * _L139;
    _L143= fby(_L68; 1; 0.0);
    _L10= (map #22 $*$ <<Ns - 1>>)(_L7, _L136);
    _L16= (map #25 $*$ <<Ds - 1>>)(_L135, _L73);
    _L71= (map #28 $-$ <<Ds - 1>>)(_L120, _L16);
  tel
  
  node TransferFcn02(In : real; Num : real; Den : real^3) returns (Out : real)
  var
    _L29 : real;
    _L65 : real;
    _L75 : real;
    _L76 : real;
    _L77 : real;
    _L78 : real;
    _L79 : real;
    _L80 : real;
    _L81 : real;
    _L85 : real;
    _L86 : real;
    _L87 : real;
    _L107 : real;
  let
    Out= _L65;
    _L29= In;
    _L65= _L107 / _L87;
    _L75= Den[2];
    _L76= _L75 * _L65;
    _L77= _L29 * _L78;
    _L78= Num;
    _L80= fby(_L79; 1; 0.0);
    _L81= _L85 * _L65;
    _L85= Den[1];
    _L86= _L80 - _L81;
    _L87= Den[0];
    _L79= _L77 - _L76;
    _L107= fby(_L86; 1; 0.0);
  tel
  
  node Filter02(In : real; Num : real; Den : real^3) returns (Out : real)
  var
    _L29 : real;
    _L40 : real;
    _L46 : real;
    _L63 : real;
    _L64 : real;
    _L65 : real;
    _L66 : real;
    _L67 : real;
    _L68 : real;
    _L69 : real;
    _L70 : real;
    _L74 : real;
    _L75 : real;
  let
    _L29= In;
    _L40= _L29 * _L63;
    _L46= _L74 / _L69;
    Out= _L46;
    _L63= Num;
    _L65= Den[1];
    _L66= _L65 * _L46;
    _L67= _L68 * _L46;
    _L68= Den[2];
    _L69= Den[0];
    _L70= fby(_L66; 1; 0.0);
    _L74= _L64 - _L75;
    _L75= fby(_L67; 2; 0.0);
    _L64= _L40 - _L70;
  tel
  
  node TransferFcn0D<<Ds>>(In : real; Num : real; Den : real^Ds)
    returns (Out : real)
  var
    _L4 : real^(Ds - 2 - 1 + 1);
    _L5 : real^Ds;
    _L6 : real;
    _L7 : real;
    _L8 : real;
    _L9 : real;
    _L10 : real;
    _L11 : real;
    _L18 : real;
    _L19 : real^(Ds - 2);
    _L20 : real;
    _L21 : real;
    _L22 : real;
    _L23 : real^(Ds - 2);
    _L26 : real^(Ds - 2);
  let
    _L4= _L5 [1 .. Ds - 2];
    _L5= Den;
    _L6= In;
    _L7= Num;
    _L8= _L6 * _L7;
    _L9= Den[Ds - 1];
    _L10= _L9 * _L21;
    _L19= reverse _L23;
    _L20= fby(_L18; 1; 0.0);
    _L21= _L20 / _L22;
    _L22= Den[0];
    Out= _L21;
    _L26= _L21^(Ds - 2);
    _L11= _L8 - _L10;
    _L18= (fold #14 SumDelay <<Ds - 2>>)(_L11, _L19);
    _L23= (map #17 $*$ <<Ds - 2>>)(_L4, _L26);
  tel
  
  node Filter01Norm(In : real; Num : real; Den : real) returns (Out : real)
  var
    _L69 : real;
    _L71 : real;
    _L72 : real;
    _L73 : real;
    _L74 : real;
    _L76 : real;
    _L77 : real;
  let
    Out= _L73;
    _L69= In;
    _L71= _L69 * _L72;
    _L72= Num;
    _L73= _L71 - _L77;
    _L74= _L76 * _L73;
    _L76= Den;
    _L77= fby(_L74; 1; 0.0);
  tel
  
  node Filter12(In : real; Num : real^2; Den : real^3) returns (Out : real)
  var
    _L200 : real;
    _L203 : real;
    _L229 : real;
    _L230 : real;
    _L231 : real;
    _L232 : real;
    _L233 : real;
    _L234 : real;
    _L235 : real;
    _L243 : real;
    _L244 : real;
    _L245 : real;
    _L248 : real;
    _L249 : real;
    _L250 : real;
    _L253 : real;
  let
    _L203= In;
    _L200= _L230 * _L203;
    _L229= _L248 / _L245;
    Out= _L229;
    _L230= Num[0];
    _L231= _L200 + _L244;
    _L232= Den[1];
    _L233= Num[1];
    _L234= _L203 * _L233;
    _L235= _L232 * _L229;
    _L243= _L234 - _L235;
    _L244= fby(_L243; 1; 0.0);
    _L245= Den[0];
    _L248= _L231 - _L250;
    _L249= _L253 * _L229;
    _L250= fby(_L249; 2; 0.0);
    _L253= Den[2];
  tel
  
  node TransferFcn12(In : real; Num : real^2; Den : real^3) returns (Out : real)
  var
    _L29 : real;
    _L65 : real;
    _L75 : real;
    _L76 : real;
    _L77 : real;
    _L78 : real;
    _L79 : real;
    _L80 : real;
    _L81 : real;
    _L85 : real;
    _L86 : real;
    _L87 : real;
    _L93 : real;
    _L94 : real;
    _L97 : real;
    _L98 : real;
    _L104 : real;
  let
    Out= _L65;
    _L29= In;
    _L65= _L98 / _L87;
    _L75= Den[2];
    _L76= _L75 * _L65;
    _L77= _L78 * _L29;
    _L78= Num[1];
    _L80= fby(_L79; 1; 0.0);
    _L81= _L85 * _L65;
    _L85= Den[1];
    _L87= Den[0];
    _L93= _L94 - _L81;
    _L86= _L80 + _L93;
    _L94= _L97 * _L104;
    _L97= Num[0];
    _L98= fby(_L86; 1; 0.0);
    _L79= _L77 - _L76;
    _L104= In;
  tel
  
  node TransferFcnND<<Ns, Ds>>(In : real; Num : real^Ns; Den : real^Ds)
    returns (Out : real)
  var
    _L4 : real^(Ds - 1 - 1 + 1);
    _L5 : real^Ds;
    _L6 : real;
    _L7 : real^Ns;
    _L18 : real;
    _L19 : real^(Ds - 1);
    _L20 : real;
    _L21 : real;
    _L22 : real;
    _L23 : real^(Ds - 1);
    _L26 : real^(Ds - 1);
    _L31 : real^Ns;
    _L32 : real^Ns;
    _L36 : real^(Ds - Ns - 1 + Ns);
    _L38 : real;
    _L41 : real^(Ds - 1);
    _L47 : real;
    _L48 : real^(Ds - Ns - 1);
  let
    _L4= _L5 [1 .. Ds - 1];
    _L5= Den;
    _L6= In;
    _L7= Num;
    _L18= (fold #3 SumDelay <<Ds - 1>>)(_L47, _L19);
    _L19= reverse _L41;
    _L20= fby(_L18; 1; 0.0);
    _L21= _L20 / _L22;
    _L22= Den[0];
    Out= _L21;
    _L26= _L21^(Ds - 1);
    _L31= _L6^Ns;
    _L36= _L48 @ _L32;
    _L48= _L38^(Ds - Ns - 1);
    _L38= 0.0;
    _L47= 0.0;
    _L32= (map #17 $*$ <<Ns>>)(_L31, _L7);
    _L23= (map #19 $*$ <<Ds - 1>>)(_L4, _L26);
    _L41= (map #22 $-$ <<Ds - 1>>)(_L36, _L23);
  tel
  
  node Filter02Norm(In : real; Num : real; Den : real^2) returns (Out : real)
  var
    _L29 : real;
    _L40 : real;
    _L63 : real;
    _L64 : real;
    _L65 : real;
    _L66 : real;
    _L67 : real;
    _L68 : real;
    _L70 : real;
    _L74 : real;
    _L75 : real;
  let
    _L29= In;
    _L40= _L29 * _L63;
    Out= _L74;
    _L63= Num;
    _L65= Den[0];
    _L66= _L65 * _L74;
    _L67= _L68 * _L74;
    _L68= Den[1];
    _L70= fby(_L66; 1; 0.0);
    _L74= _L64 - _L75;
    _L75= fby(_L67; 2; 0.0);
    _L64= _L40 - _L70;
  tel
  
  node Filter11Norm(In : real; Num : real^2; Den : real) returns (Out : real)
  var
    _L200 : real;
    _L203 : real;
    _L230 : real;
    _L231 : real;
    _L232 : real;
    _L233 : real;
    _L234 : real;
    _L235 : real;
    _L243 : real;
    _L244 : real;
  let
    _L203= In;
    _L200= _L230 * _L203;
    Out= _L231;
    _L230= Num[0];
    _L231= _L200 + _L244;
    _L232= Den;
    _L233= Num[1];
    _L234= _L203 * _L233;
    _L235= _L232 * _L231;
    _L243= _L234 - _L235;
    _L244= fby(_L243; 1; 0.0);
  tel
  
  node Filter12Norm(In : real; Num : real^2; Den : real^2) returns (Out : real)
  var
    _L200 : real;
    _L203 : real;
    _L230 : real;
    _L231 : real;
    _L232 : real;
    _L233 : real;
    _L234 : real;
    _L235 : real;
    _L243 : real;
    _L244 : real;
    _L248 : real;
    _L249 : real;
    _L250 : real;
    _L253 : real;
  let
    _L203= In;
    _L200= _L230 * _L203;
    Out= _L248;
    _L230= Num[0];
    _L231= _L200 + _L244;
    _L232= Den[0];
    _L233= Num[1];
    _L234= _L203 * _L233;
    _L235= _L232 * _L248;
    _L243= _L234 - _L235;
    _L244= fby(_L243; 1; 0.0);
    _L248= _L231 - _L250;
    _L249= _L253 * _L248;
    _L250= fby(_L249; 2; 0.0);
    _L253= Den[1];
  tel
  
  node Filter0DNorm<<Ds>>(In : real; Num : real; Den : real^Ds)
    returns (Out : real)
  var
    _L3 : real;
    _L14 : real^Ds;
    _L68 : real;
    _L73 : real^Ds;
    _L16 : real^Ds;
    _L126 : real;
    _L129 : real;
    _L134 : real^Ds;
    _L135 : real;
    _L137 : real;
    _L138 : real;
  let
    _L3= In;
    _L14= reverse _L16;
    _L68= (fold #2 SumDelay <<Ds>>)(_L126, _L14);
    Out= _L138;
    _L73= _L138^Ds;
    _L126= 0.0;
    _L129= _L3 * _L135;
    _L134= Den;
    _L135= Num;
    _L137= fby(_L68; 1; 0.0);
    _L138= _L129 - _L137;
    _L16= (map #8 $*$ <<Ds>>)(_L134, _L73);
  tel
  
  node FilterNDNorm<<Ns, Ds>>(In : real; Num : real^Ns; Den : real^Ds)
    returns (Out : real)
  var
    _L7 : real^(Ns - 1);
    _L68 : real;
    _L71 : real^Ds;
    _L73 : real^Ds;
    _L10 : real^(Ns - 1);
    _L16 : real^Ds;
    _L118 : real;
    _L120 : real^(Ns - 1 + (Ds - Ns + 1));
    _L124 : real^(Ds - Ns + 1);
    _L126 : real;
    _L128 : real;
    _L129 : real^Ds;
    _L130 : real^Ns;
    _L133 : real^Ds;
    _L136 : real^(Ns - 1 - 1 + 1);
    _L137 : real;
    _L139 : real;
    _L138 : real;
    _L140 : real;
    _L143 : real;
  let
    _L7= _L128^(Ns - 1);
    _L68= (fold #3 SumDelay <<Ds>>)(_L126, _L129);
    Out= _L137;
    _L73= _L137^Ds;
    _L118= 0.0;
    _L120= _L10 @ _L124;
    _L124= _L118^(Ds - Ns + 1);
    _L126= 0.0;
    _L128= In;
    _L129= reverse _L71;
    _L130= Num;
    _L133= Den;
    _L136= _L130 [1 .. Ns - 1];
    _L137= _L140 + _L143;
    _L138= In;
    _L139= Num[0];
    _L140= _L138 * _L139;
    _L143= fby(_L68; 1; 0.0);
    _L10= (map #17 $*$ <<Ns - 1>>)(_L7, _L136);
    _L16= (map #20 $*$ <<Ds>>)(_L133, _L73);
    _L71= (map #22 $-$ <<Ds>>)(_L120, _L16);
  tel
  
  node FilterNNNorm<<Ns>>(In : real; Num : real^Ns; Den : real^(Ns - 1))
    returns (Out : real)
  var
    _L3 : real;
    _L7 : real^(Ns - 1);
    _L68 : real;
    _L71 : real^(Ns - 1);
    _L73 : real^(Ns - 1);
    _L10 : real^(Ns - 1);
    _L16 : real^(Ns - 1);
    _L126 : real;
    _L128 : real^(Ns - 1);
    _L129 : real^Ns;
    _L132 : real^(Ns - 1);
    _L134 : real^(Ns - 1 - 1 + 1);
    _L135 : real;
    _L141 : real;
    _L140 : real;
    _L142 : real;
    _L143 : real;
  let
    _L3= In;
    _L7= _L3^(Ns - 1);
    _L68= (fold #3 SumDelay <<Ns - 1>>)(_L126, _L128);
    Out= _L143;
    _L73= _L143^(Ns - 1);
    _L126= 0.0;
    _L128= reverse _L71;
    _L129= Num;
    _L132= Den;
    _L134= _L129 [1 .. Ns - 1];
    _L135= fby(_L68; 1; 0.0);
    _L140= Num[0];
    _L141= In;
    _L142= _L141 * _L140;
    _L143= _L142 + _L135;
    _L10= (map #15 $*$ <<Ns - 1>>)(_L7, _L134);
    _L16= (map #18 $*$ <<Ns - 1>>)(_L132, _L73);
    _L71= (map #21 $-$ <<Ns - 1>>)(_L10, _L16);
  tel
  
end;

/* $*************** KCG Version 6.1.3 (build i6) ****************
** -
** Generation date: 2015-05-27T21:43:20
*************************************************************$ */
/* $*************** KCG Version 6.1.3 (build i6) ****************
** Command: x2s613 C:/Program Files/Esterel Technologies/SCADE R15.2/SCADE/libraries/libmath/vect.xscade
** Generation date: 2015-05-27T21:43:20
*************************************************************$ */

/* xscade source: C:/Program Files/Esterel Technologies/SCADE R15.2/SCADE/libraries/libmath/vect.xscade */
package vect
  function #pragma kcg expand #end ScalProd<<n>>(V : 'T^n; W : 'T^n)
    returns (SP : 'T)
    where 'T numeric
  var
    _L2 : 'T^n;
    _L3 : 'T^n;
    _L4 : 'T;
    _L6 : 'T;
    _L7 : 'T^n;
  let
    _L2= V;
    _L3= W;
    SP= _L6;
    _L4= (0 : 'T);
    _L6= (fold #2 $+$ <<n>>)(_L4, _L7);
    _L7= (map #1 $*$ <<n>>)(_L2, _L3);
  tel
  
  function MatVectProd<<m, n>>(A : 'T^n^m; V : 'T^n)
    returns (R : 'T^m)
    where 'T numeric
  var
    _L1 : 'T^n^m;
    _L2 : 'T^n;
    _L4 : 'T^n^m;
    _L7 : 'T^m;
  let
    _L1= A;
    _L2= V;
    R= _L7;
    _L7= (map (#1 ScalProd <<n>>) <<m>>)(_L1, _L4);
    _L4= _L2^m;
  tel
  
  function MatProd<<m, n, p>>(A : 'T^n^m; B : 'T^p^n)
    returns (C : 'T^p^m)
    where 'T numeric
  var
    _L1 : 'T^n^m;
    _L2 : 'T^p^n;
    _L4 : 'T^p^n^m;
    _L7 : 'T^p^m;
  let
    _L1= A;
    _L2= B;
    C= _L7;
    _L4= _L2^m;
    _L7= (map (#1 VectMatProd <<n, p>>) <<m>>)(_L1, _L4);
  tel
  
  function VectMatProd<<m, n>>(V : 'T^m; A : 'T^n^m)
    returns (R : 'T^n)
    where 'T numeric
  var
    _L1 : 'T^n^m;
    _L2 : 'T^m;
    _L4 : 'T^m^n;
    _L5 : 'T^m^n;
    _L8 : 'T^n;
  let
    _L1= A;
    _L2= V;
    R= _L8;
    _L8= (map (#1 ScalProd <<m>>) <<n>>)(_L5, _L4);
    _L4= _L2^n;
    _L5= transpose (_L1; 1; 2);
  tel
  
  function MatAdd<<m, n>>(A : 'T^n^m; B : 'T^n^m)
    returns (C : 'T^n^m)
    where 'T numeric
  var
    _L2 : 'T^n^m;
    _L3 : 'T^n^m;
    _L4 : 'T^n^m;
  let
    _L2= (map (#1 VectAdd <<n>>) <<m>>)(_L3, _L4);
    _L3= A;
    _L4= B;
    C= _L2;
  tel
  
  function Inv4x4(A : real^4^4; Epsilon : real)
    returns (InvA : real^4^4; Error : bool)
  var
    Det : real;
    _L5 : bool;
    _L4 : real;
    _L3 : real;
    _L2 : real^4^4;
    _L1 : real;
  let
    _L5= _L3 <= _L4;
    _L4= Epsilon;
    assume A1 : Epsilon >= 0.0;
    _L3= if Det < 0.0 then - Det else Det;
    Error= _L5;
    activate IfBlock1 if Error
      then let
        InvA= 0.0^4^4;
      tel
      else var
        C00 : real;
        C01 : real;
        C02 : real;
        C10 : real;
        C11 : real;
        C12 : real;
        C20 : real;
        C21 : real;
        C22 : real;
        C03 : real;
        C13 : real;
        C23 : real;
        C30 : real;
        C31 : real;
        C32 : real;
        C33 : real;
        C0011 : real;
        C0021 : real;
        C0031 : real;
        C0110 : real;
        C0120 : real;
        C0130 : real;
        C0210 : real;
        C0220 : real;
        C0230 : real;
        C0310 : real;
        C0320 : real;
        C0330 : real;
        C1001 : real;
        C1021 : real;
        C1031 : real;
        C1100 : real;
        C1120 : real;
        C1130 : real;
        C1200 : real;
        C1220 : real;
        C1230 : real;
        C1300 : real;
        C1320 : real;
        C1330 : real;
        C2001 : real;
        C2031 : real;
        C2011 : real;
        C2100 : real;
        C2110 : real;
        C2130 : real;
        C2200 : real;
        C2210 : real;
        C2230 : real;
        C2300 : real;
        C2310 : real;
        C2330 : real;
        C3001 : real;
        C3011 : real;
        C3021 : real;
        C3100 : real;
        C3110 : real;
        C3120 : real;
        C3200 : real;
        C3220 : real;
        C3210 : real;
        C3300 : real;
        C3310 : real;
        C3320 : real;
      let
        InvA=
          [[C00 / Det, C10 / Det, C20 / Det, C30 / Det], [C01 / Det, C11 / Det,
              C21 / Det, C31 / Det], [C02 / Det, C12 / Det, C22 / Det, C32 /
              Det], [C03 / Det, C13 / Det, C23 / Det, C33 / Det]];
        C00= A[1][1] * C0011 + A[2][1] * C0021 + A[3][1] * C0031;
        C0011= A[2][2] * A[3][3] - A[2][3] * A[3][2];
        C0021= - A[1][2] * A[3][3] + A[1][3] * A[3][2];
        C0031= A[1][2] * A[2][3] - A[1][3] * A[2][2];
        C01= A[1][0] * C0110 + A[2][0] * C0120 + A[3][0] * C0130;
        C0110= - A[2][2] * A[3][3] + A[2][3] * A[3][2];
        C0120= A[1][2] * A[3][3] - A[1][3] * A[3][2];
        C0130= - A[1][2] * A[2][3] + A[1][3] * A[2][2];
        C02= A[1][0] * C0210 + A[2][0] * C0220 + A[3][0] * C0230;
        C0210= A[2][1] * A[3][3] - A[2][3] * A[3][1];
        C0220= - A[1][1] * A[3][3] + A[1][3] * A[3][1];
        C0230= A[1][1] * A[2][3] - A[1][3] * A[2][1];
        C03= A[1][0] * C0310 + A[2][0] * C0320 + A[3][0] * C0330;
        C0310= - A[2][1] * A[3][2] + A[2][2] * A[3][1];
        C0320= A[1][1] * A[3][2] - A[1][2] * A[3][1];
        C0330= - A[1][1] * A[2][2] + A[1][2] * A[2][1];
        C10= A[0][1] * C1001 + A[2][1] * C1021 + A[3][1] * C1031;
        C1001= - A[2][2] * A[3][3] + A[2][3] * A[3][2];
        C1021= A[0][2] * A[3][3] - A[0][3] * A[3][2];
        C1031= - A[0][2] * A[2][3] + A[0][3] * A[2][2];
        C11= A[0][0] * C1100 + A[2][0] * C1120 + A[3][0] * C1130;
        C1100= A[2][2] * A[3][3] - A[2][3] * A[3][2];
        C1120= - A[0][2] * A[3][3] + A[0][3] * A[3][2];
        C1130= A[0][2] * A[2][3] - A[0][3] * A[2][2];
        C12= A[0][0] * C1200 + A[2][0] * C1220 + A[3][0] * C1230;
        C1200= - A[2][1] * A[3][3] + A[2][3] * A[3][1];
        C1220= A[0][1] * A[3][3] - A[0][3] * A[3][1];
        C1230= - A[0][1] * A[2][3] + A[0][3] * A[2][1];
        C13= A[0][0] * C1300 + A[2][0] * C1320 + A[3][0] * C1330;
        C1300= A[2][1] * A[3][2] - A[2][2] * A[3][1];
        C1320= - A[0][1] * A[3][2] + A[0][2] * A[3][1];
        C1330= A[0][1] * A[2][2] - A[0][2] * A[2][1];
        C20= A[0][1] * C2001 + A[1][1] * C2011 + A[3][1] * C2031;
        C2001= A[1][2] * A[3][3] - A[1][3] * A[3][2];
        C2011= - A[0][2] * A[3][3] + A[0][3] * A[3][2];
        C2031= A[0][2] * A[1][3] - A[0][3] * A[1][2];
        C21= A[0][0] * C2100 + A[1][0] * C2110 + A[3][0] * C2130;
        C2100= - A[1][2] * A[3][3] + A[1][3] * A[3][2];
        C2110= A[0][2] * A[3][3] - A[0][3] * A[3][2];
        C2130= - A[0][2] * A[1][3] + A[0][3] * A[1][2];
        C22= A[0][0] * C2200 + A[1][0] * C2210 + A[3][0] * C2230;
        C2200= A[1][1] * A[3][3] - A[1][3] * A[3][1];
        C2210= - A[0][1] * A[3][3] + A[0][3] * A[3][1];
        C2230= A[0][1] * A[1][3] - A[0][3] * A[1][1];
        C23= A[0][0] * C2300 + A[1][0] * C2310 + A[3][0] * C2330;
        C2300= - A[1][1] * A[3][2] + A[1][2] * A[3][1];
        C2310= A[0][1] * A[3][2] - A[0][2] * A[3][1];
        C2330= - A[0][1] * A[1][2] + A[0][2] * A[1][1];
        C30= A[0][1] * C3001 + A[1][1] * C3011 + A[2][1] * C3021;
        C3001= - A[1][2] * A[2][3] + A[1][3] * A[2][2];
        C3011= A[0][2] * A[2][3] - A[0][3] * A[2][2];
        C3021= - A[0][2] * A[1][3] + A[0][3] * A[1][2];
        C31= A[0][0] * C3100 + A[1][0] * C3110 + A[2][0] * C3120;
        C3100= A[1][2] * A[2][3] - A[1][3] * A[2][2];
        C3110= - A[0][2] * A[2][3] + A[0][3] * A[2][2];
        C3120= A[0][2] * A[1][3] - A[0][3] * A[1][2];
        C32= A[0][0] * C3200 + A[1][0] * C3210 + A[2][0] * C3220;
        C3200= - A[1][1] * A[2][3] + A[1][3] * A[2][1];
        C3210= A[0][1] * A[2][3] - A[0][3] * A[2][1];
        C3220= - A[0][1] * A[1][3] + A[0][3] * A[1][1];
        C33= A[0][0] * C3300 + A[1][0] * C3310 + A[2][0] * C3320;
        C3300= A[1][1] * A[2][2] - A[1][2] * A[2][1];
        C3310= - A[0][1] * A[2][2] + A[0][2] * A[2][1];
        C3320= A[0][1] * A[1][2] - A[0][2] * A[1][1];
      tel
    
    returns ..;
    Det= _L1;
    _L2= A;
    _L1= #1 Det4x4(_L2);
  tel
  
  function Inv3x3(A : real^3^3; Epsilon : real)
    returns (InvA : real^3^3; Error : bool)
  var
    Det : real;
    _L8 : bool;
    _L7 : real;
    _L6 : real;
    _L5 : real^3^3;
    _L4 : real;
  let
    _L8= _L6 <= _L7;
    _L7= Epsilon;
    assume A1 : Epsilon >= 0.0;
    _L6= if Det < 0.0 then - Det else Det;
    Error= _L8;
    activate IfBlock1 if Error
      then let
        InvA= 0.0^3^3;
      tel
      else var
        C00 : real;
        C01 : real;
        C02 : real;
        C10 : real;
        C11 : real;
        C12 : real;
        C20 : real;
        C21 : real;
        C22 : real;
      let
        InvA=
          [[C00 / Det, C10 / Det, C20 / Det], [C01 / Det, C11 / Det, C21 / Det],
            [C02 / Det, C12 / Det, C22 / Det]];
        C00= A[1][1] * A[2][2] - A[1][2] * A[2][1];
        C01= - A[1][0] * A[2][2] + A[1][2] * A[2][0];
        C02= A[1][0] * A[2][1] - A[1][1] * A[2][0];
        C10= - A[0][1] * A[2][2] + A[0][2] * A[2][1];
        C11= A[0][0] * A[2][2] - A[0][2] * A[2][0];
        C12= - A[0][0] * A[2][1] + A[2][0] * A[0][1];
        C20= A[0][1] * A[1][2] - A[0][2] * A[1][1];
        C21= - A[0][0] * A[1][2] + A[0][2] * A[1][0];
        C22= A[0][0] * A[1][1] - A[0][1] * A[1][0];
      tel
    
    returns ..;
    Det= _L4;
    _L5= A;
    _L4= #1 Det3x3(_L5);
  tel
  
  function Inv2x2(A : real^2^2; Epsilon : real)
    returns (InvA : real^2^2; Error : bool)
  var
    Det : real;
    _L1 : real;
    _L2 : real^2^2;
    _L3 : real;
    _L4 : real;
    _L5 : bool;
  let
    _L1= #1 Det2x2(_L2);
    _L2= A;
    Det= _L1;
    activate IfBlock1 if Error
      then let
        InvA= 0.0^2^2;
      tel
      else let
        InvA=
          [[A[1][1] / Det, - A[0][1] / Det], [- A[1][0] / Det, A[0][0] / Det]];
      tel
    
    returns ..;
    Error= _L5;
    _L3= if Det < 0.0 then - Det else Det;
    assume A1 : Epsilon >= 0.0;
    _L4= Epsilon;
    _L5= _L3 <= _L4;
  tel
  
  function Det4x4(A : 'T^4^4) returns (Det : 'T) where 'T numeric
  var
    C00 : 'T;
    C01 : 'T;
    C02 : 'T;
    C03 : 'T;
    C0330 : 'T;
    C0320 : 'T;
    C0310 : 'T;
    C0230 : 'T;
    C0220 : 'T;
    C0210 : 'T;
    C0130 : 'T;
    C0120 : 'T;
    C0110 : 'T;
    C0031 : 'T;
    C0021 : 'T;
    C0011 : 'T;
  let
    Det= A[0][0] * C00 + A[0][1] * C01 + A[0][2] * C02 + A[0][3] * C03;
    C00= A[1][1] * C0011 + A[2][1] * C0021 + A[3][1] * C0031;
    C0011= A[2][2] * A[3][3] - A[2][3] * A[3][2];
    C0021= - A[1][2] * A[3][3] + A[1][3] * A[3][2];
    C0031= A[1][2] * A[2][3] - A[1][3] * A[2][2];
    C01= A[1][0] * C0110 + A[2][0] * C0120 + A[3][0] * C0130;
    C0110= - A[2][2] * A[3][3] + A[2][3] * A[3][2];
    C0120= A[1][2] * A[3][3] - A[1][3] * A[3][2];
    C0130= - A[1][2] * A[2][3] + A[1][3] * A[2][2];
    C02= A[1][0] * C0210 + A[2][0] * C0220 + A[3][0] * C0230;
    C0210= A[2][1] * A[3][3] - A[2][3] * A[3][1];
    C0220= - A[1][1] * A[3][3] + A[1][3] * A[3][1];
    C0230= A[1][1] * A[2][3] - A[1][3] * A[2][1];
    C03= A[1][0] * C0310 + A[2][0] * C0320 + A[3][0] * C0330;
    C0310= - A[2][1] * A[3][2] + A[2][2] * A[3][1];
    C0320= A[1][1] * A[3][2] - A[1][2] * A[3][1];
    C0330= - A[1][1] * A[2][2] + A[1][2] * A[2][1];
  tel
  
  function Det3x3(A : 'T^3^3) returns (Det : 'T) where 'T numeric
  var
    C00 : 'T;
    C01 : 'T;
    C02 : 'T;
  let
    Det= A[0][0] * C00 + A[0][1] * C01 + A[0][2] * C02;
    C00= A[1][1] * A[2][2] - A[1][2] * A[2][1];
    C01= - A[1][0] * A[2][2] + A[1][2] * A[2][0];
    C02= A[1][0] * A[2][1] - A[1][1] * A[2][0];
  tel
  
  function Det2x2(A : 'T^2^2) returns (Det : 'T) where 'T numeric
  let
    Det= A[0][0] * A[1][1] - A[0][1] * A[1][0];
  tel
  
  function MatSub<<m, n>>(A : 'T^n^m; B : 'T^n^m)
    returns (C : 'T^n^m)
    where 'T numeric
  var
    _L3 : 'T^n^m;
    _L2 : 'T^n^m;
    _L1 : 'T^n^m;
  let
    _L1= (map (#1 VectSub <<n>>) <<m>>)(_L3, _L2);
    _L2= B;
    _L3= A;
    C= _L1;
  tel
  
  function VectSub<<n>>(U : 'T^n; V : 'T^n) returns (W : 'T^n) where 'T numeric
  var
    _L3 : 'T^n;
    _L2 : 'T^n;
    _L1 : 'T^n;
  let
    _L1= (map #1 $-$ <<n>>)(_L3, _L2);
    _L2= V;
    W= _L1;
    _L3= U;
  tel
  
  function VectAdd<<n>>(U : 'T^n; V : 'T^n) returns (W : 'T^n) where 'T numeric
  var
    _L1 : 'T^n;
    _L2 : 'T^n;
    _L3 : 'T^n;
  let
    _L1= (map #1 $+$ <<n>>)(_L2, _L3);
    _L2= U;
    _L3= V;
    W= _L1;
  tel
  
end;

/* $*************** KCG Version 6.1.3 (build i6) ****************
** -
** Generation date: 2015-05-27T21:43:20
*************************************************************$ */
/* $*************** KCG Version 6.1.3 (build i6) ****************
** Command: x2s613 C:/Program Files/Esterel Technologies/SCADE R15.2/SCADE/libraries/libmath/math.xscade
** Generation date: 2015-05-27T21:43:20
*************************************************************$ */

/* xscade source: C:/Program Files/Esterel Technologies/SCADE R15.2/SCADE/libraries/libmath/math.xscade */
package math
  function #pragma kcg expand #end Abs(A_Input : 'T)
    returns (A_Output : 'T)
    where 'T numeric
  var
    _L1 : bool;
    _L2 : 'T;
    _L3 : 'T;
    _L5 : 'T;
    _L8 : 'T;
  let
    _L1= _L8 <= _L5;
    _L2= if _L1 then _L5 else _L3;
    _L3= - _L5;
    _L5= A_Input;
    A_Output= _L2;
    _L8= (0 : 'T);
  tel
  
  function #pragma kcg expand #end BoolToInt(BTI_Input : bool)
    returns (BTI_Output : int)
  var
    _L1 : bool;
    _L2 : int;
    _L3 : int;
    _L4 : int;
  let
    _L1= BTI_Input;
    BTI_Output= _L2;
    _L2= if _L1 then _L3 else _L4;
    _L3= 1;
    _L4= 0;
  tel
  
  function #pragma kcg expand #end BoolToReal(BTR_Input : bool)
    returns (BTR_Output : real)
  var
    _L10 : real;
    _L5 : bool;
    _L6 : real;
    _L9 : real;
  let
    _L5= BTR_Input;
    BTR_Output= _L6;
    _L6= if _L5 then _L10 else _L9;
    _L9= 0.0;
    _L10= 1.0;
  tel
  
  function #pragma kcg expand #end InRangeInIn(IRII_Input : 'T; A : 'T; B : 'T)
    returns (IRII_Output : bool)
    where 'T numeric
  var
    _L10 : 'T;
    _L12 : bool;
    _L13 : 'T;
    _L2 : bool;
    _L4 : bool;
    _L8 : 'T;
  let
    _L2= _L12 and _L4;
    _L4= _L8 >= _L10;
    _L8= IRII_Input;
    IRII_Output= _L2;
    _L10= A;
    _L12= _L13 >= _L8;
    _L13= B;
    assume A1 : A <= B;
  tel
  
  function #pragma kcg expand #end InRangeInOut(IRIO_Input : 'T; A : 'T; B : 'T)
    returns (IRIO_Output : bool)
    where 'T numeric
  var
    _L3 : 'T;
    _L14 : bool;
    _L13 : 'T;
    _L12 : 'T;
    _L10 : bool;
    _L17 : bool;
  let
    _L3= IRIO_Input;
    _L14= _L3 >= _L12;
    _L13= B;
    _L12= A;
    _L10= _L17 and _L14;
    IRIO_Output= _L10;
    _L17= _L13 > _L3;
    assume A1 : A <= B;
  tel
  
  function #pragma kcg expand #end InRangeOutIn(IROI_Input : 'T; A : 'T; B : 'T)
    returns (IROI_Output : bool)
    where 'T numeric
  var
    _L3 : 'T;
    _L7 : bool;
    _L29 : bool;
    _L24 : 'T;
    _L23 : 'T;
    _L30 : bool;
  let
    _L3= IROI_Input;
    IROI_Output= _L29;
    _L7= _L3 > _L23;
    _L29= _L30 and _L7;
    _L24= B;
    _L23= A;
    _L30= _L24 >= _L3;
    assume A1 : A <= B;
  tel
  
  function #pragma kcg expand #end InRangeOutOut(
      IROO_Input : 'T;
      A : 'T;
      B : 'T)
    returns (IROO_Output : bool)
    where 'T numeric
  var
    _L3 : 'T;
    _L29 : bool;
    _L28 : bool;
    _L24 : 'T;
    _L23 : 'T;
    _L30 : bool;
  let
    _L3= IROO_Input;
    IROO_Output= _L29;
    _L29= _L28 and _L30;
    _L28= _L24 > _L3;
    _L24= B;
    _L23= A;
    _L30= _L3 > _L23;
    assume A1 : A <= B;
  tel
  
  function #pragma kcg expand #end Max(I1 : 'T; I2 : 'T)
    returns (Ma_Output : 'T)
    where 'T numeric
  var
    _L1 : 'T;
    _L2 : 'T;
    _L3 : bool;
    _L4 : 'T;
  let
    _L1= I1;
    _L2= I2;
    _L3= _L1 >= _L2;
    _L4= if _L3 then _L1 else _L2;
    Ma_Output= _L4;
  tel
  
  function Max3(I1 : 'T; I2 : 'T; I3 : 'T)
    returns (Ma3_Output : 'T)
    where 'T numeric
  var
    _L1 : 'T;
    _L2 : 'T;
    _L3 : 'T;
    _L4 : bool;
    _L5 : bool;
    _L6 : bool;
    _L7 : bool;
    _L8 : 'T;
    _L9 : 'T;
  let
    _L1= I1;
    _L2= I2;
    _L3= I3;
    _L4= _L1 >= _L2;
    _L5= _L1 >= _L3;
    _L6= _L2 >= _L3;
    _L7= _L4 and _L5;
    _L8= if _L7 then _L1 else _L9;
    _L9= if _L6 then _L2 else _L3;
    Ma3_Output= _L8;
  tel
  
  function #pragma kcg expand #end Mean3(I1 : 'T; I2 : 'T; I3 : 'T)
    returns (Me3_Output : real)
    where 'T numeric
  var
    _L1 : 'T;
    _L2 : 'T;
    _L3 : 'T;
    _L4 : 'T;
    _L5 : real;
    _L6 : 'T;
  let
    _L1= I1;
    _L2= I2;
    _L3= I3;
    _L4= _L1 + _L2 + _L3;
    _L5= _L4 / _L6;
    _L6= (3 : 'T);
    Me3_Output= _L5;
  tel
  
  function #pragma kcg expand #end Min(I1 : 'T; I2 : 'T)
    returns (Mi_Output : 'T)
    where 'T numeric
  var
    _L21 : 'T;
    _L22 : 'T;
    _L24 : 'T;
    _L25 : bool;
  let
    _L21= I1;
    _L22= I2;
    _L24= if _L25 then _L21 else _L22;
    _L25= _L21 <= _L22;
    Mi_Output= _L24;
  tel
  
  function Min3(I1 : 'T; I2 : 'T; I3 : 'T)
    returns (Mi3_Output : 'T)
    where 'T numeric
  var
    _L1 : bool;
    _L2 : bool;
    _L3 : bool;
    _L4 : 'T;
    _L5 : 'T;
    _L6 : 'T;
    _L7 : bool;
    _L8 : 'T;
    _L9 : 'T;
  let
    _L1= _L4 <= _L5;
    _L2= _L4 <= _L6;
    _L3= _L5 <= _L6;
    _L4= I1;
    _L5= I2;
    _L6= I3;
    _L7= _L1 and _L2;
    _L8= if _L7 then _L4 else _L9;
    _L9= if _L3 then _L5 else _L6;
    Mi3_Output= _L8;
  tel
  
  function Sign(S_Input : real) returns (S_Ouput : real)
  var
    _L1 : real;
    _L15 : real;
    _L16 : real;
    _L4 : bool;
    _L5 : bool;
    _L7 : real;
    _L8 : real;
    _L20 : real;
    _L21 : real;
  let
    _L1= S_Input;
    _L4= _L1 > _L15;
    _L5= _L15 = _L1;
    S_Ouput= _L7;
    _L7= if _L4 then _L16 else _L8;
    _L8= if _L5 then _L21 else _L20;
    _L15= 0.0;
    _L16= 1.0;
    _L20= -1.0;
    _L21= 0.0;
  tel
  
  function #pragma kcg expand #end Mean(I1 : 'T; I2 : 'T)
    returns (Me_output : real)
    where 'T numeric
  var
    _L1 : 'T;
    _L2 : 'T;
    _L3 : real;
    _L4 : 'T;
    _L5 : 'T;
  let
    _L1= I1;
    _L2= I2;
    _L3= _L4 / _L5;
    _L4= _L1 + _L2;
    _L5= (2 : 'T);
    Me_output= _L3;
  tel
  
  function Round(R_Input : real) returns (R_Output : int)
  var
    _L2 : bool;
    _L4 : real;
    _L5 : real;
    _L7 : real;
    _L8 : int;
    _L9 : real;
    _L10 : int;
    _L12 : real;
    _L17 : real;
    _L22 : real;
    _L21 : real;
    _L20 : real;
    _L19 : real;
    _L18 : bool;
    _L25 : real;
    _L26 : real;
    _L27 : bool;
    _L34 : real;
  let
    _L2= _L12 >= _L17;
    _L4= if _L2 then _L5 else _L34;
    _L5= _L34 + _L7;
    _L7= 1.0;
    _L8= int  _L25;
    R_Output= _L8;
    _L9= R_Input;
    _L10= int  _L9;
    _L12= _L9 - _L34;
    _L17= 0.5;
    _L22= _L34 - _L21;
    _L21= 1.0;
    _L20= -0.5;
    _L19= if _L18 then _L22 else _L34;
    _L18= _L12 <= _L20;
    _L25= if _L27 then _L19 else _L4;
    _L26= 0.0;
    _L27= _L12 < _L26;
    _L34= real  _L10;
  tel
  
  function OctetToInt(
      b1 : bool;
      b2 : bool;
      b3 : bool;
      b4 : bool;
      b5 : bool;
      b6 : bool;
      b7 : bool;
      b8 : bool)
    returns (OTI_Output : int)
  var
    _L1 : bool;
    _L2 : bool;
    _L3 : bool;
    _L4 : bool;
    _L5 : int;
    _L6 : int;
    _L7 : int;
    _L10 : int;
    _L9 : int;
    _L8 : int;
    _L13 : int;
    _L12 : int;
    _L11 : int;
    _L16 : int;
    _L15 : int;
    _L14 : int;
    _L17 : int;
    _L18 : int;
    _L19 : int;
    _L23 : int;
    _L22 : int;
    _L21 : int;
    _L20 : int;
    _L31 : int;
    _L30 : int;
    _L29 : int;
    _L28 : int;
    _L32 : int;
    _L33 : bool;
    _L34 : bool;
    _L35 : bool;
    _L36 : bool;
    _L40 : int;
    _L39 : int;
    _L38 : int;
    _L37 : int;
    _L43 : int;
    _L42 : int;
    _L41 : int;
  let
    _L1= b1;
    _L2= b2;
    _L3= b3;
    _L4= b4;
    _L5= if _L1 then _L6 else _L7;
    _L6= 1;
    _L7= 0;
    _L10= 2;
    _L9= 0;
    _L8= if _L2 then _L10 else _L9;
    _L13= 4;
    _L12= 0;
    _L11= if _L3 then _L13 else _L12;
    _L16= 8;
    _L15= 0;
    _L14= if _L4 then _L16 else _L15;
    _L17= _L11 + _L32;
    _L18= _L8 + _L17;
    _L19= _L5 + _L18;
    OTI_Output= _L19;
    _L23= 0;
    _L22= 16;
    _L21= _L20 + _L29;
    _L20= if _L33 then _L22 else _L23;
    _L31= 0;
    _L30= 32;
    _L29= _L28 + _L40;
    _L28= if _L34 then _L30 else _L31;
    _L32= _L14 + _L21;
    _L33= b5;
    _L34= b6;
    _L35= b7;
    _L36= b8;
    _L40= _L37 + _L43;
    _L39= 64;
    _L38= 0;
    _L37= if _L35 then _L39 else _L38;
    _L43= if _L36 then _L42 else _L41;
    _L42= 128;
    _L41= 0;
  tel
  
  function RoundCeil(RC_Input : real) returns (RC_Output : int)
  var
    _L1 : real;
    _L2 : bool;
    _L3 : real;
    _L4 : int;
    _L6 : int;
    _L7 : real;
    _L9 : int;
    _L10 : real;
    _L11 : int;
    _L12 : real;
    _L14 : bool;
  let
    _L1= RC_Input;
    _L2= _L1 <= _L3;
    _L3= 0.0;
    _L4= if _L2 then _L6 else _L9;
    _L6= int  _L1;
    _L7= real  _L6;
    _L9= if _L14 then _L6 else _L11;
    _L10= _L1 + _L12;
    _L11= int  _L10;
    _L12= 1.0;
    RC_Output= _L4;
    _L14= _L7 = _L1;
  tel
  
  function RoundFloor(RF_Input : real) returns (RF_Output : int)
  var
    _L1 : real;
    _L24 : bool;
    _L25 : real;
    _L26 : int;
    _L30 : real;
    _L31 : real;
    _L32 : int;
    _L33 : int;
    _L38 : int;
    _L41 : real;
    _L43 : bool;
  let
    _L1= RF_Input;
    RF_Output= _L26;
    _L24= _L1 >= _L25;
    _L25= 0.0;
    _L26= if _L24 then _L33 else _L38;
    _L30= _L1 - _L31;
    _L31= 1.0;
    _L32= int  _L30;
    _L33= int  _L1;
    _L38= if _L43 then _L33 else _L32;
    _L41= real  _L33;
    _L43= _L41 = _L1;
  tel
  
  function #pragma kcg expand #end IntToBool(ITB_Input : int)
    returns (ITB_Output : bool)
  var
    _L1 : int;
    _L2 : bool;
    _L3 : int;
  let
    _L1= ITB_Input;
    _L2= _L1 <> _L3;
    ITB_Output= _L2;
    _L3= 0;
  tel
  
  function #pragma kcg expand #end RealToBool(RTB_Input : real)
    returns (RTB_Output : bool)
  var
    _L3 : bool;
    _L2 : real;
    _L1 : real;
  let
    _L3= _L2 <> _L1;
    _L2= RTB_Input;
    _L1= 0.0;
    RTB_Output= _L3;
  tel
  
end;

/* $*************** KCG Version 6.1.3 (build i6) ****************
** -
** Generation date: 2015-05-27T21:43:21
*************************************************************$ */
/* $*************** KCG Version 6.1.3 (build i6) ****************
** Command: x2s613 C:/Program Files/Esterel Technologies/SCADE R15.2/SCADE/libraries/libmathext/mathext.xscade
** Generation date: 2015-05-27T21:43:21
*************************************************************$ */

/* xscade source: C:/Program Files/Esterel Technologies/SCADE R15.2/SCADE/libraries/libmathext/mathext.xscade */
package mathext
  function imported #pragma kcg name AcosR_mathext #end AcosR(Input1 : real)
    returns (Output1 : real);
  
  function imported #pragma kcg name AcoshR_mathext #end AcoshR(Input1 : real)
    returns (Output1 : real);
  
  function imported #pragma kcg name AsinR_mathext #end AsinR(Input1 : real)
    returns (Output1 : real);
  
  function imported #pragma kcg name AsinhR_mathext #end AsinhR(Input1 : real)
    returns (Output1 : real);
  
  function imported #pragma kcg name Atan2R_mathext #end Atan2R(
      Input1 : real;
      Input2 : real)
    returns (Output1 : real);
  
  function imported #pragma kcg name AtanR_mathext #end AtanR(Input1 : real)
    returns (Output1 : real);
  
  function imported #pragma kcg name AtanhR_mathext #end AtanhR(Input1 : real)
    returns (Output1 : real);
  
  function imported #pragma kcg name CosR_mathext #end CosR(Input1 : real)
    returns (Output1 : real);
  
  function imported #pragma kcg name CoshR_mathext #end CoshR(Input1 : real)
    returns (Output1 : real);
  
  function imported #pragma kcg name ExpR_mathext #end ExpR(Input1 : real)
    returns (Output1 : real);
  
  function imported #pragma kcg name LnR_mathext #end LnR(Input1 : real)
    returns (Output1 : real);
  
  function imported #pragma kcg name LogR_mathext #end LogR(Input1 : real)
    returns (Output1 : real);
  
  function imported #pragma kcg name PowerRR_mathext #end PowerRR(
      P_Input : real;
      Power : real)
    returns (P_Output : real);
  
  function imported #pragma kcg name SinR_mathext #end SinR(Input1 : real)
    returns (Output1 : real);
  
  function imported #pragma kcg name SinhR_mathext #end SinhR(Input1 : real)
    returns (Output1 : real);
  
  function imported #pragma kcg name SqrtR_mathext #end SqrtR(Input1 : real)
    returns (Output1 : real);
  
  function imported #pragma kcg name TanR_mathext #end TanR(Input1 : real)
    returns (Output1 : real);
  
  function imported #pragma kcg name TanhR_mathext #end TanhR(Input1 : real)
    returns (Output1 : real);
  
  function imported #pragma kcg name TenPowR_mathext #end TenPowR(Input1 : real)
    returns (Output1 : real);
  
  function Square(Square_In : 'T) returns (Square_Out : 'T) where 'T numeric
  var
    _L1 : 'T;
    _L2 : 'T;
  let
    _L1= Square_In;
    _L2= _L1 * _L1;
    Square_Out= _L2;
  tel
  
  function Inv(Inv_In : 'T) returns (Inv_Out : real) where 'T numeric
  var
    _L1 : 'T;
    _L2 : 'T;
    _L3 : real;
  let
    _L1= Inv_In;
    _L2= (1 : 'T);
    _L3= _L2 / _L1;
    Inv_Out= _L3;
  tel
  
  function HypotR(HypotR_I1 : real; HypotR_I2 : real) returns (HypotR_O : real)
  var
    _L1 : real;
    _L2 : real;
    _L3 : real;
    _L4 : real;
    _L5 : real;
    _L6 : real;
  let
    _L1= HypotR_I2;
    _L2= HypotR_I1;
    _L3= _L2 * _L2;
    _L4= _L1 * _L1;
    _L5= _L3 + _L4;
    _L6= #4 SqrtR(_L5);
    HypotR_O= _L6;
  tel
  
  function imported #pragma kcg name PowerI_mathext #end PowerI(
      P_Input : int;
      Power : int)
    returns (P_Output : int);
  
  function imported #pragma kcg name PowerR_mathext #end PowerR(
      P_Input : real;
      Power : int)
    returns (P_Output : real);
  
  function #pragma kcg expand #end SinCosR(Input1 : real)
    returns (Output1 : real; Output2 : real)
  var
    _L1 : real;
    _L2 : real;
    _L3 : real;
  let
    _L1= Input1;
    _L2= #1 SinR(_L1);
    _L3= #1 CosR(_L1);
    Output1= _L2;
    Output2= _L3;
  tel
  
end;

/* $*************** KCG Version 6.1.3 (build i6) ****************
** -
** Generation date: 2015-05-27T21:43:21
*************************************************************$ */
/* $*************** KCG Version 6.1.3 (build i6) ****************
** Command: x2s613 C:/Program Files/Esterel Technologies/SCADE R15.2/SCADE/libraries/libpwlinear/pwlinear.xscade
** Generation date: 2015-05-27T21:43:21
*************************************************************$ */

/* xscade source: C:/Program Files/Esterel Technologies/SCADE R15.2/SCADE/libraries/libpwlinear/pwlinear.xscade */
package pwlinear
  function DeadBandSymmetrical(DBS_Input : 'T; Tolerance : 'T)
    returns (DBS_Output : 'T)
    where 'T numeric
  var
    _L26 : 'T;
    _L25 : bool;
    _L22 : 'T;
    _L20 : 'T;
    _L19 : 'T;
    _L18 : bool;
    _L17 : 'T;
    _L30 : 'T;
    _L31 : 'T;
    _L34 : 'T;
  let
    _L17= if _L25 then _L20 else _L26;
    _L18= _L34 >= _L30;
    _L19= _L34 - _L30;
    _L20= _L30 + _L34;
    _L22= (0 : 'T);
    _L25= _L31 >= _L34;
    _L26= if _L18 then _L19 else _L22;
    _L30= Tolerance;
    _L31= - _L30;
    DBS_Output= _L17;
    _L34= DBS_Input;
  tel
  
  function DeadBandUnSymmetrical(DBUS_Input : 'T; LowTol : 'T; HiTol : 'T)
    returns (DBUS_Output : 'T)
    where 'T numeric
  var
    _L10 : 'T;
    _L8 : 'T;
    _L7 : 'T;
    _L5 : 'T;
    _L3 : bool;
    _L2 : bool;
    _L1 : 'T;
    _L11 : 'T;
    _L13 : 'T;
    _L15 : 'T;
  let
    _L10= DBUS_Input;
    _L8= (0 : 'T);
    _L7= HiTol;
    DBUS_Output= _L1;
    _L5= if _L3 then _L13 else _L8;
    _L3= _L10 >= _L7;
    _L2= _L11 >= _L10;
    _L1= if _L2 then _L15 else _L5;
    _L11= LowTol;
    _L13= _L10 - _L7;
    _L15= _L10 - _L11;
    assume A1 : LowTol <= HiTol;
  tel
  
  function #pragma kcg expand #end LimiterUnSymmetrical(
      LUS_Input : 'T;
      LowLimit : 'T;
      HighLimit : 'T)
    returns (LUS_Output : 'T)
    where 'T numeric
  var
    _L1 : bool;
    _L11 : 'T;
    _L13 : 'T;
    _L15 : 'T;
    _L2 : bool;
    _L3 : 'T;
    _L9 : 'T;
  let
    _L1= _L3 >= _L15;
    _L2= _L3 <= _L13;
    _L3= LUS_Input;
    _L9= if _L1 then _L15 else _L11;
    _L11= if _L2 then _L13 else _L3;
    _L13= LowLimit;
    _L15= HighLimit;
    LUS_Output= _L9;
    assume A1 : LowLimit <= HighLimit;
  tel
  
  function PreLoadSymmetrical(PLS_Input : 'T; Offset : 'T; Slope : 'T)
    returns (PLS_Output : 'T)
    where 'T numeric
  var
    _L1 : bool;
    _L10 : 'T;
    _L2 : 'T;
    _L4 : 'T;
    _L5 : 'T;
    _L6 : 'T;
    _L8 : 'T;
    _L9 : 'T;
    _L12 : 'T;
  let
    _L1= _L6 > _L12;
    _L2= if _L1 then _L10 else _L5;
    _L4= _L8 + _L2;
    _L5= - _L10;
    _L6= PLS_Input;
    _L8= _L6 * _L9;
    _L9= Slope;
    _L10= Offset;
    PLS_Output= _L4;
    _L12= (0 : 'T);
  tel
  
  function #pragma kcg expand #end PreLoadUnSymmetrical(
      PLUS_Input : 'T;
      NegOffset : 'T;
      PosOffset : 'T;
      Slope : 'T)
    returns (PLUS_Output : 'T)
    where 'T numeric
  var
    _L1 : 'T;
    _L12 : 'T;
    _L14 : 'T;
    _L15 : 'T;
    _L4 : bool;
    _L5 : 'T;
    _L7 : 'T;
    _L9 : 'T;
    _L16 : 'T;
  let
    _L1= PLUS_Input;
    PLUS_Output= _L7;
    _L4= _L1 < _L16;
    _L5= if _L4 then _L12 else _L15;
    _L7= _L9 + _L5;
    _L9= _L1 * _L14;
    _L12= NegOffset;
    _L14= Slope;
    _L15= PosOffset;
    _L16= (0 : 'T);
  tel
  
  node ClockCounter(Reset : bool) returns (Count : int)
  var
    _L1 : int;
    _L2 : int;
    _L6 : int;
    _L7 : int;
    _L8 : int;
    _L11 : int;
    _L13 : bool;
    _L16 : int;
  let
    _L2= if _L13 then _L16 else _L7;
    Count= _L1;
    _L6= pre _L1;
    _L7= _L8 + _L6;
    _L8= 1;
    _L1= _L11 -> _L2;
    _L11= 0;
    _L13= Reset;
    _L16= 0;
  tel
  
  function Quantizer(Q_Input : real; Interval : real) returns (Q_Output : real)
  var
    _L8 : real;
    _L11 : real;
    _L12 : real;
    _L13 : real;
    _L142 : real;
    _L140 : bool;
    _L139 : real;
    _L138 : real;
    _L137 : real;
    _L136 : real;
    _L135 : real;
    _L134 : real;
    _L133 : int;
    _L130 : real;
    _L129 : bool;
    _L128 : real;
    _L127 : real;
    _L126 : real;
    _L125 : bool;
    _L124 : real;
  let
    _L8= Q_Input;
    Q_Output= _L13;
    _L11= Interval;
    _L12= _L8 / _L11;
    _L13= _L136 * _L11;
    _L142= _L12 - _L124;
    _L140= _L142 <= _L137;
    _L139= _L124 - _L126;
    _L138= 1.0;
    _L137= -0.5;
    _L136= if _L125 then _L134 else _L127;
    _L135= _L124 + _L138;
    _L134= if _L140 then _L139 else _L124;
    _L133= int  _L12;
    _L130= 0.0;
    _L129= _L142 >= _L128;
    _L128= 0.5;
    _L127= if _L129 then _L135 else _L124;
    _L126= 1.0;
    _L125= _L142 < _L130;
    _L124= real  _L133;
    assume A1 : Interval <> 0.0;
  tel
  
  node RateLimiter(
      RL_Input : real;
      Rising : real;
      Falling : real;
      deltaT : real)
    returns (RL_Output : real)
  var
    _L1 : real;
    _L6 : real;
    _L7 : real;
    _L8 : bool;
    _L9 : real;
    _L10 : real;
    _L12 : bool;
    _L13 : real;
    _L14 : real;
    _L38 : real;
    _L40 : real;
    _L41 : real;
    _L42 : real;
    _L46 : real;
    _L47 : real;
  let
    _L1= RL_Input;
    RL_Output= _L9;
    _L6= Rising;
    _L7= Falling;
    _L8= _L38 < _L7;
    _L9= if _L8 then _L10 else _L13;
    _L12= _L38 > _L6;
    _L13= if _L12 then _L14 else _L1;
    _L10= _L46 + _L41;
    _L14= _L46 + _L42;
    _L38= _L47 / _L40;
    _L40= deltaT;
    _L41= _L7 * _L40;
    _L42= _L6 * _L40;
    _L46= fby(_L9; 1; _L1);
    _L47= _L1 - _L46;
    assume A1 : Falling <= Rising;
  tel
  
  node Counter(Incr : 'T; Reset : bool) returns (Count : 'T) where 'T numeric
  var
    _L2 : 'T;
    _L3 : bool;
    _L4 : 'T;
    _L9 : 'T;
    _L18 : 'T;
    _L46 : 'T;
  let
    _L2= Incr;
    _L3= Reset;
    Count= _L9;
    _L4= if _L3 then _L46 else _L18;
    _L9= _L4 + _L2;
    _L18= fby(_L9; 1; _L46);
    _L46= (0 : 'T);
  tel
  
  node FallingHysteresis(LL : 'T; FH_Input : 'T; UL : 'T; Init : bool)
    returns (FH_Output : bool)
    where 'T numeric
  var
    _L10 : bool;
    _L9 : bool;
    _L6 : bool;
    _L5 : bool;
    _L4 : bool;
    _L3 : 'T;
    _L2 : 'T;
    _L1 : 'T;
    _L16 : bool;
    _L17 : bool;
  let
    _L10= _L2 < _L3;
    _L9= _L2 <= _L1;
    _L6= pre _L17;
    _L5= _L4 -> _L6;
    _L4= Init;
    FH_Output= _L17;
    _L3= LL;
    _L2= FH_Input;
    _L1= UL;
    _L16= _L9 and _L5;
    _L17= _L10 or _L16;
    assume A1 : LL <= UL;
  tel
  
  node RisingHysteresis(UL : 'T; A : 'T; LL : 'T; Init : bool)
    returns (S : bool)
    where 'T numeric
  var
    _L6 : 'T;
    _L7 : 'T;
    _L8 : 'T;
    _L9 : bool;
    _L10 : bool;
    _L11 : bool;
    _L15 : bool;
    _L16 : bool;
    _L22 : bool;
    _L24 : bool;
  let
    _L6= UL;
    _L7= A;
    _L8= LL;
    S= _L24;
    _L9= Init;
    _L10= _L9 -> _L11;
    _L11= pre _L24;
    _L15= _L7 > _L6;
    _L16= _L7 >= _L8;
    _L22= _L16 and _L10;
    _L24= _L15 or _L22;
    assume A1 : UL <= LL;
  tel
  
  function #pragma kcg expand #end LimiterSymmetrical(
      LS_Input : 'T;
      BandOrigin : 'T;
      Tolerance : 'T)
    returns (LS_Output : 'T)
    where 'T numeric
  var
    Upper_limit : 'T;
    Lower_limit : 'T;
    _L1 : bool;
    _L10 : 'T;
    _L2 : bool;
    _L5 : 'T;
    _L7 : 'T;
    _L8 : 'T;
    _L9 : 'T;
  let
    _L1= _L8 >= Upper_limit;
    _L2= _L8 <= Lower_limit;
    Lower_limit= _L9 - _L10;
    Upper_limit= _L10 + _L9;
    _L5= if _L1 then Upper_limit else _L7;
    _L7= if _L2 then Lower_limit else _L8;
    _L8= LS_Input;
    LS_Output= _L5;
    _L9= BandOrigin;
    _L10= Tolerance;
  tel
  
end;

/* $*************** KCG Version 6.1.3 (build i6) ****************
** -
** Generation date: 2015-05-27T21:43:21
*************************************************************$ */
/* $*************** KCG Version 6.1.3 (build i6) ****************
** Command: x2s613 C:/Program Files/Esterel Technologies/SCADE R15.2/SCADE/libraries/libpwlinear/lut.xscade
** Generation date: 2015-05-27T21:43:21
*************************************************************$ */

/* xscade source: C:/Program Files/Esterel Technologies/SCADE R15.2/SCADE/libraries/libpwlinear/lut.xscade */
package lut
  type LutIndex = { k : int, f : real };
  
  function Interp1D<<Xs>>(IdxX : LutIndex; Y : real^Xs) returns (OutY : real)
  var
    Idx : int;
    _L23 : real;
    _L29 : int;
    _L28 : int;
    _L27 : int;
    _L26 : int;
    _L25 : real;
    _L21 : real^Xs;
    _L20 : real;
    _L16 : real;
    _L2 : LutIndex;
    _L15 : real;
    _L6 : real;
    _L5 : int;
  let
    _L23= (_L21.[_L28] default 0.0);
    _L29= 1;
    _L28= _L29 + _L27;
    _L27= Idx;
    _L26= Idx;
    _L25= (_L21.[_L26] default 0.0);
    _L21= Y;
    _L20= _L23 - _L25;
    Idx= _L5;
    _L16= _L15 + _L25;
    _L2= IdxX;
    OutY= _L16;
    _L15= _L6 * _L20;
    _L5, _L6= (flatten LutIndex)(_L2);
    assume A1 : 0 <= Idx and Idx < Xs - 1;
  tel
  
  function Interp2DFloor<<Xs, Ys>>(
      IdxX : LutIndex;
      IdxY : LutIndex;
      Z : real^Ys^Xs)
    returns (OutZ : real)
  var
    i : int;
    j : int;
    Fx : real;
    Fy : real;
    _L1 : LutIndex;
    _L2 : LutIndex;
    _L6 : real;
    _L5 : int;
    _L7 : int;
    _L8 : real;
    _L11 : real;
    _L16 : real;
    _L21 : real;
    _L18 : real;
    _L45 : real;
    _L47 : real;
    _L48 : real;
    _L49 : real;
    _L50 : real;
    _L53 : bool;
    _L54 : real;
    _L56 : real;
    _L55 : bool;
  let
    _L1= IdxX;
    _L2= IdxY;
    _L5, _L6= (flatten LutIndex)(_L1);
    i= _L5;
    j= _L7;
    _L7, _L8= (flatten LutIndex)(_L2);
    Fx= _L6;
    Fy= _L8;
    _L11= (Z.[i + 1][j] default 0.0);
    _L16= (Z.[i][j] default 0.0);
    _L18= (Z.[i + 1][j + 1] default 0.0);
    _L21= (Z.[i][j + 1] default 0.0);
    OutZ= _L48;
    _L45= Fx;
    _L47= Fy;
    _L48= if _L53 then _L49 else _L50;
    _L49= if _L55 then _L16 else _L11;
    _L50= if _L55 then _L21 else _L18;
    _L54= 1.0;
    _L56= 1.0;
    _L53= _L47 < _L54;
    _L55= _L45 < _L56;
    assume A2 : 0 <= j and j < Ys - 1;
    assume A1 : 0 <= i and i < Xs - 1;
  tel
  
  function PreLutDirect(
      InX : real;
      Orig : real;
      Step : real;
      NbElem : int;
      Extrapol : bool)
    returns (OutIndex : LutIndex)
  var
    bLow : bool;
    bHigh : bool;
    F0 : real;
    N : int;
    _L1 : real;
    _L17 : bool;
    _L45 : bool;
    _L48 : LutIndex;
    _L49 : int;
    _L56 : bool;
    _L71 : int;
    _L75 : LutIndex;
    _L86 : LutIndex;
    _L87 : int;
    _L88 : real;
    _L89 : bool;
    _L93 : int;
    _L92 : real;
    _L94 : LutIndex;
    _L98 : LutIndex;
    _L100 : LutIndex;
    _L103 : real;
    _L162 : LutIndex;
    _L163 : LutIndex;
    _L165 : real;
    _L164 : real;
    _L166 : real;
    _L167 : real;
    _L169 : real;
    _L171 : int;
    _L173 : int;
    _L174 : bool;
    _L175 : real;
    _L176 : real;
    _L177 : real;
    _L182 : LutIndex;
    _L180 : real;
    _L178 : real;
    _L181 : int;
    _L184 : int;
    _L185 : int;
    _L186 : real;
    _L187 : real;
    _L172 : int;
  let
    _L1= InX;
    bLow= _L17;
    _L45= bLow;
    _L48= (make LutIndex)(_L49, _L175);
    _L49= 0;
    _L56= bHigh;
    _L71= NbElem - 2;
    _L75= (make LutIndex)(_L71, _L177);
    _L86= (make LutIndex)(_L87, _L88);
    _L87= 0;
    _L88= 0.0;
    _L89= Extrapol;
    _L92= 1.0;
    _L93= NbElem - 2;
    OutIndex= _L98;
    _L94= (make LutIndex)(_L93, _L92);
    _L98= if _L45 then _L163 else _L100;
    _L100= if _L56 then _L162 else _L182;
    _L17= _L1 <= _L103;
    _L103= Orig;
    _L162= if _L89 then _L75 else _L94;
    _L163= if _L89 then _L48 else _L86;
    F0= _L167;
    _L164= InX;
    _L165= Orig;
    _L166= _L164 - _L165;
    _L167= _L166 / _L169;
    _L169= Step;
    _L171= int  _L167;
    N= _L171;
    _L173= NbElem;
    bHigh= _L174;
    _L175= F0;
    _L176= F0;
    _L182= (make LutIndex)(_L181, _L178);
    _L180= F0;
    _L178= _L180 - _L186;
    _L181= N;
    _L184= N;
    _L177= _L176 - _L187;
    _L185= NbElem - 2;
    _L186= real  _L184;
    _L187= real  _L185;
    _L174= _L172 > _L173;
    _L172= N;
  tel
  
  function private #pragma kcg expand #end CalculateFloor(
      Acc : real;
      InX : real;
      X : real;
      Y : real)
    returns (Out : real)
  var
    _L8 : real;
    _L40 : real;
    _L77 : bool;
    _L84 : real;
    _L85 : real;
    _L74 : real;
  let
    _L8= Acc;
    _L40= InX;
    Out= _L84;
    _L84= if _L77 then _L8 else _L85;
    _L85= Y;
    _L77= _L40 < _L74;
    _L74= X;
  tel
  
  function Lut1DCeil<<Xs>>(InX : real; X : real^Xs; Y : real^Xs)
    returns (OutY : real)
  var
    i : int;
    _L191 : real^Xs;
    _L190 : real^Xs;
    _L189 : real;
    _L186 : int;
    _L192 : real;
    _L193 : real^Xs;
    _L194 : real^Xs;
    _L198 : int;
    _L197 : int;
    _L199 : int;
    _L200 : int;
  let
    OutY= _L192;
    _L186= 0;
    i= (foldi #1 SearchIdxCeil <<Xs>>)(_L186, _L191, _L194);
    _L189= InX;
    _L190= X;
    _L191= _L189^Xs;
    _L192= (_L193.[_L199] default 0.0);
    _L193= Y;
    _L194= reverse _L190;
    _L197= _L198 - i;
    _L198= Xs;
    _L199= _L197 - _L200;
    _L200= 1;
  tel
  
  function private CalculateNearest(
      Acc : real;
      InX : real;
      Xi1 : real;
      Xi2 : real;
      Yi1 : real;
      Yi2 : real)
    returns (Out : real)
  var
    _L8 : real;
    _L40 : real;
    _L74 : real;
    _L77 : bool;
    _L84 : real;
    _L85 : real;
    _L87 : real;
    _L88 : real;
    _L89 : real;
    _L91 : real;
    _L98 : real;
    _L99 : real;
    _L100 : real;
    _L101 : bool;
  let
    _L8= Acc;
    _L40= InX;
    _L74= Xi1;
    Out= _L84;
    _L84= if _L77 then _L8 else _L98;
    _L85= Xi2;
    _L87= Xi1;
    _L88= Yi1;
    _L89= Yi2;
    _L91= InX;
    _L98= if _L101 then _L88 else _L89;
    _L100= _L91 - _L87;
    _L99= _L85 - _L91;
    _L101= _L99 > _L100;
    _L77= _L40 < _L74;
  tel
  
  function Lut1DNearest<<Xs>>(InX : real; X : real^Xs; Y : real^Xs)
    returns (OutY : real)
  var
    i : int;
    _L189 : real^(Xs - 2 - 0 + 1);
    _L188 : real^(Xs - 1 - 1 + 1);
    _L187 : real;
    _L185 : int;
    _L184 : real^(Xs - 1);
    _L191 : real^Xs;
    _L190 : real;
  let
    _L184= _L187^(Xs - 1);
    _L185= 0;
    i= (foldi #1 SearchNearest <<Xs - 1>>)(_L185, _L184, _L189, _L188);
    _L187= InX;
    _L188= X [1 .. Xs - 1];
    _L189= X [0 .. Xs - 2];
    OutY= _L190;
    _L190= (_L191.[i] default 0.0);
    _L191= Y;
  tel
  
  function private #pragma kcg expand #end CalculateCeil(
      Acc : real;
      InX : real;
      X : real;
      Y : real)
    returns (Out : real)
  var
    _L8 : real;
    _L40 : real;
    _L77 : bool;
    _L84 : real;
    _L85 : real;
    _L74 : real;
  let
    _L8= Acc;
    _L40= InX;
    Out= _L84;
    _L84= if _L77 then _L8 else _L85;
    _L85= Y;
    _L74= X;
    _L77= _L40 <= _L74;
  tel
  
  function Lut2DFloor<<Xs, Ys>>(
      InX : real;
      InY : real;
      X : real^Xs;
      Y : real^Ys;
      Z : real^Ys^Xs)
    returns (OutZ : real)
  var
    i : int;
    j : int;
    _L2 : real;
    _L6 : real;
    _L11 : int;
    _L12 : int;
    _L14 : real^Xs;
    _L15 : int;
    _L19 : int;
    _L18 : real^Ys;
    _L20 : real;
    _L22 : real^Xs;
    _L23 : real^Ys;
  let
    _L2= InX;
    _L6= InY;
    OutZ= _L20;
    _L12= 0;
    _L18= Y;
    _L19= 0;
    i= _L11;
    j= _L15;
    _L20= (Z.[i][j] default 0.0);
    _L22= _L2^Xs;
    _L23= _L6^Ys;
    _L11= (foldi #6 SearchIdxFloor <<Xs>>)(_L12, _L22, _L14);
    _L15= (foldi #8 SearchIdxFloor <<Ys>>)(_L19, _L23, _L18);
    _L14= X;
  tel
  
  function private #pragma kcg expand #end SearchIdxFloor(
      i : int;
      Acc : int;
      InX : real;
      Xi : real)
    returns (Out : int)
  var
    _L8 : int;
    _L40 : real;
    _L77 : bool;
    _L84 : int;
    _L74 : real;
    _L86 : int;
  let
    _L8= Acc;
    _L40= InX;
    Out= _L84;
    _L84= if _L77 then _L8 else _L86;
    _L74= Xi;
    _L86= i;
    _L77= _L40 < _L74;
  tel
  
  function Lut2DCeil<<Xs, Ys>>(
      InX : real;
      InY : real;
      X : real^Xs;
      Y : real^Ys;
      Z : real^Ys^Xs)
    returns (OutZ : real)
  var
    i : int;
    j : int;
    _L2 : real;
    _L6 : real;
    _L11 : int;
    _L13 : int;
    _L14 : real^Xs;
    _L15 : int;
    _L18 : real^Ys;
    _L17 : int;
    _L20 : real;
    _L22 : real^Xs;
    _L23 : real^Ys;
    _L24 : real^Xs;
    _L27 : real^Ys;
  let
    _L2= InX;
    _L6= InY;
    OutZ= _L20;
    _L13= 0;
    _L14= X;
    _L17= 0;
    _L18= Y;
    i= _L11;
    j= _L15;
    _L20= (Z.[Xs - i - 1][Ys - j - 1] default 0.0);
    _L22= _L2^Xs;
    _L23= _L6^Ys;
    _L11= (foldi #8 SearchIdxCeil <<Xs>>)(_L13, _L22, _L24);
    _L15= (foldi #10 SearchIdxCeil <<Ys>>)(_L17, _L23, _L27);
    _L24= reverse _L14;
    _L27= reverse _L18;
  tel
  
  function private #pragma kcg expand #end SearchIdxCeil(
      i : int;
      Acc : int;
      InX : real;
      Xi : real)
    returns (Out : int)
  var
    _L8 : int;
    _L40 : real;
    _L77 : bool;
    _L84 : int;
    _L74 : real;
    _L86 : int;
  let
    _L8= Acc;
    _L40= InX;
    Out= _L84;
    _L84= if _L77 then _L8 else _L86;
    _L74= Xi;
    _L86= i;
    _L77= _L40 > _L74;
  tel
  
  function private SearchNearest(
      i : int;
      Acc : int;
      InX : real;
      Xi1 : real;
      Xi2 : real)
    returns (Out : int)
  var
    _L8 : int;
    _L40 : real;
    _L74 : real;
    _L77 : bool;
    _L84 : int;
    _L85 : real;
    _L87 : real;
    _L91 : real;
    _L98 : int;
    _L99 : real;
    _L100 : real;
    _L101 : bool;
    _L102 : int;
    _L103 : int;
    _L104 : int;
  let
    _L8= Acc;
    _L40= InX;
    _L74= Xi1;
    Out= _L84;
    _L84= if _L77 then _L8 else _L98;
    _L85= Xi2;
    _L87= Xi1;
    _L91= InX;
    _L98= if _L101 then _L102 else _L103;
    _L100= _L91 - _L87;
    _L99= _L85 - _L91;
    _L101= _L99 > _L100;
    _L77= _L40 < _L74;
    _L102= i;
    _L103= _L102 + _L104;
    _L104= 1;
  tel
  
  function Lut2DNearest<<Xs, Ys>>(
      InX : real;
      InY : real;
      X : real^Xs;
      Y : real^Ys;
      Z : real^Ys^Xs)
    returns (OutZ : real)
  var
    i : int;
    j : int;
    _L2 : real;
    _L6 : real;
    _L11 : int;
    _L13 : int;
    _L14 : real^(Xs - 2 - 0 + 1);
    _L15 : int;
    _L18 : real^(Ys - 1 - 1 + 1);
    _L17 : int;
    _L20 : real;
    _L21 : real^(Xs - 1 - 1 + 1);
    _L26 : real^(Ys - 2 - 0 + 1);
    _L27 : real^(Xs - 1);
    _L28 : real^(Ys - 1);
  let
    _L2= InX;
    _L6= InY;
    OutZ= _L20;
    _L13= 0;
    _L14= X [0 .. Xs - 2];
    _L17= 0;
    _L18= Y [1 .. Ys - 1];
    i= _L11;
    j= _L15;
    _L20= (Z.[i][j] default 0.0);
    _L21= X [1 .. Xs - 1];
    _L26= Y [0 .. Ys - 2];
    _L27= _L2^(Xs - 1);
    _L28= _L6^(Ys - 1);
    _L11= (foldi #14 SearchNearest <<Xs - 1>>)(_L13, _L27, _L14, _L21);
    _L15= (foldi #17 SearchNearest <<Ys - 1>>)(_L17, _L28, _L26, _L18);
  tel
  
  function Interp1DFloor<<Xs>>(IdxX : LutIndex; Y : real^Xs)
    returns (OutY : real)
  var
    Idx : int;
    _L6 : real;
    _L5 : int;
    _L2 : LutIndex;
    _L21 : real^Xs;
    _L23 : real;
    _L25 : real;
    _L26 : int;
    _L27 : int;
    _L28 : int;
    _L29 : int;
    _L30 : real;
    _L32 : bool;
    _L33 : real;
  let
    _L5, _L6= (flatten LutIndex)(_L2);
    OutY= _L30;
    _L2= IdxX;
    Idx= _L5;
    _L21= Y;
    _L25= (_L21.[_L28] default 0.0);
    _L26= Idx;
    _L27= Idx;
    _L28= _L29 + _L27;
    _L29= 1;
    _L23= (_L21.[_L26] default 0.0);
    _L30= if _L32 then _L23 else _L25;
    _L32= _L6 < _L33;
    _L33= 1.0;
    assume A1 : 0 <= Idx and Idx < Xs - 1;
  tel
  
  function Interp2D<<Xs, Ys>>(IdxX : LutIndex; IdxY : LutIndex; Z : real^Ys^Xs)
    returns (OutZ : real)
  var
    i : int;
    j : int;
    Fx : real;
    Fy : real;
    _L1 : LutIndex;
    _L2 : LutIndex;
    _L6 : real;
    _L5 : int;
    _L7 : int;
    _L8 : real;
    _L11 : real;
    _L12 : real;
    _L13 : real;
    _L14 : real;
    _L15 : real;
    _L16 : real;
    _L21 : real;
    _L18 : real;
    _L37 : real;
    _L41 : real;
    _L40 : real;
    _L39 : real;
    _L38 : real;
    _L44 : real;
    _L43 : real;
    _L42 : real;
  let
    _L1= IdxX;
    _L2= IdxY;
    _L5, _L6= (flatten LutIndex)(_L1);
    i= _L5;
    j= _L7;
    _L7, _L8= (flatten LutIndex)(_L2);
    Fx= _L6;
    Fy= _L8;
    _L11= (Z.[i][j] default 0.0);
    _L12= _L14 + _L11;
    _L14= _L15 * _L13;
    _L15= Fx;
    _L16= (Z.[i + 1][j] default 0.0);
    _L18= (Z.[i][j + 1] default 0.0);
    _L21= (Z.[i + 1][j + 1] default 0.0);
    _L37= Fy;
    OutZ= _L43;
    _L13= _L16 - _L11;
    _L38= Fx;
    _L39= _L40 + _L18;
    _L40= _L38 * _L41;
    _L41= _L21 - _L18;
    _L42= _L39 - _L12;
    _L43= _L44 + _L12;
    _L44= _L37 * _L42;
    assume A1 : 0 <= i and i < Xs - 1;
    assume A2 : 0 <= j and j < Ys - 1;
  tel
  
  function #pragma kcg expand #end SearchIdx(
      i : int;
      AccIn : int;
      InX : real;
      X : real)
    returns (AccOut : int)
  var
    _L1 : real;
    _L2 : bool;
    _L7 : int;
    _L8 : real;
    _L9 : int;
    _L10 : int;
  let
    _L1= InX;
    _L2= _L1 >= _L8;
    _L7= i;
    AccOut= _L9;
    _L8= X;
    _L9= if _L2 then _L7 else _L10;
    _L10= AccIn;
  tel
  
  function #pragma kcg expand #end Proj<<N>>(
      Idx : int;
      Input1 : 'T^N;
      DefVal : 'T)
    returns (Output1 : 'T; Output2 : 'T)
  var
    _L1 : 'T^N;
    _L2 : int;
    _L6 : 'T;
    _L5 : 'T;
    _L4 : int;
    _L3 : int;
  let
    _L1= Input1;
    _L2= Idx;
    _L3= _L2 + _L4;
    _L4= 1;
    _L5= (_L1.[_L2] default DefVal);
    _L6= (_L1.[_L3] default DefVal);
    Output1= _L5;
    Output2= _L6;
  tel
  
  function #pragma kcg expand #end PreLutNoSat<<Xs>>(InX : real; X : real^Xs)
    returns (F : real; Idx : int)
  var
    idx : int;
    X2 : real;
    X1 : real;
    _L33 : int;
    _L39 : real^(Xs - 2 - 0 + 1);
    _L40 : real^(Xs - 1);
    _L42 : real;
    _L41 : real;
  let
    idx= (foldi #1 SearchIdx <<Xs - 1>>)(_L33, _L40, _L39);
    Idx= idx;
    _L33= 0;
    _L39= X [0 .. Xs - 2];
    _L40= InX^(Xs - 1);
    X1= _L41;
    X2= _L42;
    _L41= (X.[Idx] default 0.0);
    _L42= (X.[Idx + 1] default 0.0);
    activate IfBlock2 if X1 = X2
      then var
        _L4 : real;
      let
        F= _L4;
        _L4= 0.0;
      tel
      else var
        _L4 : real;
      let
        _L4= (InX - X1) / (X2 - X1);
        F= _L4;
      tel
    
    returns ..;
    assume A1 : (fold #2 $and$ <<Xs - 1>>)(true, (map
        #2 $<=$
        <<Xs - 1>>)(X [0 .. Xs - 2], X [1 .. Xs - 1]));
  tel
  
  function Lut1DNoSat<<Xs>>(InX : real; X : real^Xs; Y : real^Xs)
    returns (OutY : real)
  var
    Idx : int;
    _L16 : real;
    _L24 : real;
    _L25 : real;
    _L26 : real^Xs;
    _L27 : real^Xs;
    _L28 : real;
    _L29 : real;
  let
    _L25, Idx= (#1 PreLutNoSat <<Xs>>)(_L16, _L27);
    _L16= InX;
    _L24= #1 InterpolateLinear(_L25, _L29, _L28);
    OutY= _L24;
    _L26= Y;
    _L29, _L28= (#1 Proj <<Xs>>)(Idx, _L26, 0.0);
    _L27= X;
  tel
  
  function Limiter<<Xs>>(Val : real; Range : real^Xs)
    returns (LimitedVal : real)
  var
    _L1 : real;
    _L2 : real;
    _L3 : real;
    _L4 : bool;
    _L5 : real;
    _L6 : real;
    _L7 : bool;
  let
    _L1= Val;
    _L2= Range[0];
    _L3= Range[Xs - 1];
    _L4= _L1 < _L2;
    _L5= if _L4 then _L2 else _L6;
    _L6= if _L7 then _L3 else _L1;
    _L7= _L1 > _L3;
    LimitedVal= _L5;
  tel
  
  function #pragma kcg expand #end InterpolateLinear(
      F : real;
      Y1 : real;
      Y2 : real)
    returns (Y : real)
  var
    _L9 : real;
    _L8 : real;
    _L6 : real;
    _L11 : real;
    _L12 : real;
    _L13 : real;
  let
    _L6= _L12 - _L13;
    Y= _L9;
    _L8= _L11 * _L6;
    _L9= _L8 + _L13;
    _L11= F;
    _L12= Y2;
    _L13= Y1;
  tel
  
  function Lut1DFloor<<Xs>>(InX : real; X : real^Xs; Y : real^Xs)
    returns (OutY : real)
  var
    i : int;
    _L188 : real^Xs;
    _L187 : real^Xs;
    _L186 : real^Xs;
    _L185 : real;
    _L184 : real;
    _L182 : int;
  let
    _L182= 0;
    i= (foldi #1 SearchIdxFloor <<Xs>>)(_L182, _L186, _L188);
    _L184= InX;
    _L185= (_L187.[i] default 0.0);
    _L186= _L184^Xs;
    _L187= Y;
    _L188= X;
    OutY= _L185;
  tel
  
  function Lut3DNearest<<Xs, Ys, Zs>>(
      InX : real;
      InY : real;
      InZ : real;
      X : real^Xs;
      Y : real^Ys;
      Z : real^Zs;
      W : real^Zs^Ys^Xs)
    returns (OutW : real)
  var
    i : int;
    j : int;
    k : int;
    _L2 : real;
    _L6 : real;
    _L11 : int;
    _L13 : int;
    _L14 : real^(Xs - 2 - 0 + 1);
    _L15 : int;
    _L18 : real^(Ys - 1 - 1 + 1);
    _L17 : int;
    _L20 : real;
    _L21 : real^(Xs - 1 - 1 + 1);
    _L26 : real^(Ys - 2 - 0 + 1);
    _L27 : real^(Xs - 1);
    _L28 : real^(Ys - 1);
    _L34 : int;
    _L33 : real^(Zs - 1 - 1 + 1);
    _L32 : real^(Zs - 1);
    _L31 : int;
    _L30 : real^(Zs - 2 - 0 + 1);
    _L29 : real;
  let
    _L2= InX;
    _L6= InY;
    OutW= _L20;
    _L13= 0;
    _L14= X [0 .. Xs - 2];
    _L17= 0;
    _L18= Y [1 .. Ys - 1];
    i= _L11;
    j= _L15;
    _L20= (W.[i][j][k] default 0.0);
    _L21= X [1 .. Xs - 1];
    _L26= Y [0 .. Ys - 2];
    _L27= _L2^(Xs - 1);
    _L28= _L6^(Ys - 1);
    _L11= (foldi #1 SearchNearest <<Xs - 1>>)(_L13, _L27, _L14, _L21);
    _L15= (foldi #2 SearchNearest <<Ys - 1>>)(_L17, _L28, _L26, _L18);
    _L29= InZ;
    _L30= Z [0 .. Zs - 2];
    _L31= (foldi #3 SearchNearest <<Zs - 1>>)(_L34, _L32, _L30, _L33);
    _L32= _L29^(Zs - 1);
    _L33= Z [1 .. Zs - 1];
    _L34= 0;
    k= _L31;
  tel
  
  function Lut2DNoSat<<Xs, Ys>>(
      InX : real;
      InY : real;
      X : real^Xs;
      Y : real^Ys;
      Z : real^Ys^Xs)
    returns (OutZ : real)
  var
    rateY : real;
    rateX : real;
    idxY : int;
    idxX : int;
    _L22 : real;
    _L52 : real;
    _L79 : real;
    _L82 : real;
    _L83 : int;
    _L84 : real;
    _L87 : real;
    _L93 : int;
    _L94 : real;
    _L95 : real;
    _L96 : real;
    _L97 : real;
    _L98 : real;
    _L99 : real;
    _L101 : real;
    _L100 : real;
  let
    _L94, _L93= (#1 PreLutNoSat <<Xs>>)(_L52, X);
    _L22= #3 InterpolateLinear(_L95, _L79, _L87);
    OutZ= _L22;
    _L52= InX;
    _L79= #1 InterpolateLinear(_L96, _L98, _L99);
    _L82, _L83= (#2 PreLutNoSat <<Ys>>)(_L84, Y);
    _L84= InY;
    _L87= #2 InterpolateLinear(_L97, _L101, _L100);
    rateY= _L82;
    rateX= _L94;
    idxX= _L93;
    idxY= _L83;
    _L95= rateX;
    _L96= rateY;
    _L97= rateY;
    _L98= (Z.[idxX][idxY] default 0.0);
    _L99= (Z.[idxX][idxY + 1] default 0.0);
    _L100= (Z.[idxX + 1][idxY + 1] default 0.0);
    _L101= (Z.[idxX + 1][idxY] default 0.0);
  tel
  
  function #pragma kcg expand #end Lut2D<<Xs, Ys>>(
      InX : real;
      InY : real;
      X : real^Xs;
      Y : real^Ys;
      Z : real^Ys^Xs;
      Extrapol : bool)
    returns (OutZ : real)
  var
    Xsat : real;
    Ysat : real;
    _L52 : real;
    _L53 : real;
    _L54 : real;
  let
    activate IfBlock1 if Extrapol
      then var
        _L2 : real;
        _L3 : real;
      let
        Xsat= _L2;
        _L2= InX;
        _L3= InY;
        Ysat= _L3;
      tel
      else var
        _L1 : real;
        _L2 : real;
        _L3 : real;
        _L4 : real;
      let
        Xsat= _L2;
        _L1= InX;
        _L2= #1 Limiter2(_L1, X[0], X[Xs - 1]);
        _L3= #2 Limiter2(_L4, Y[0], Y[Ys - 1]);
        _L4= InY;
        Ysat= _L3;
      tel
    
    returns ..;
    _L52= (#1 Lut2DNoSat <<Xs, Ys>>)(_L53, _L54, X, Y, Z);
    _L53= Xsat;
    _L54= Ysat;
    OutZ= _L52;
  tel
  
  function #pragma kcg expand #end Lut1D<<Xs>>(
      InX : real;
      X : real^Xs;
      Y : real^Xs;
      Extrapol : bool)
    returns (OutY : real)
  var
    Xsat : real;
    _L16 : real;
    _L18 : real;
  let
    activate IfBlock1 if Extrapol
      then var
        _L2 : real;
      let
        Xsat= _L2;
        _L2= InX;
      tel
      else var
        _L1 : real;
        _L2 : real;
      let
        Xsat= _L2;
        _L1= InX;
        _L2= #1 Limiter2(_L1, X[0], X[Xs - 1]);
      tel
    
    returns ..;
    _L16= (#1 Lut1DNoSat <<Xs>>)(_L18, X, Y);
    _L18= Xsat;
    OutY= _L16;
  tel
  
  function Lut3DNoSat<<Xs, Ys, Zs>>(
      InX : real;
      InY : real;
      InZ : real;
      X : real^Xs;
      Y : real^Ys;
      Z : real^Zs;
      W : real^Zs^Ys^Xs)
    returns (OutW : real)
  var
    rateY : real;
    idxY : int;
    rateZ : real;
    idxZ : int;
    rateX : real;
    idxX : int;
    _L190 : real;
    _L189 : real;
    _L188 : real;
    _L187 : real;
    _L186 : real;
    _L185 : real;
    _L184 : real;
    _L183 : real;
    _L182 : real;
    _L181 : real;
    _L180 : real;
    _L179 : real;
    _L178 : real;
    _L177 : real;
    _L175 : real;
    _L176 : int;
    _L174 : real;
    _L172 : real;
    _L173 : int;
    _L171 : real;
    _L170 : real;
    _L169 : real;
    _L168 : real;
    _L167 : real;
    _L166 : real;
    _L164 : real;
    _L165 : int;
    _L163 : real;
    _L162 : real;
  let
    _L162= InY;
    rateZ= _L172;
    _L163= #14 InterpolateLinear(_L166, _L180, _L170);
    _L164, _L165= (#6 PreLutNoSat <<Xs>>)(_L184, X);
    _L166= rateY;
    _L167= (W.[idxX + 1][idxY + 1][idxZ + 1] default 0.0);
    _L168= #13 InterpolateLinear(_L187, _L185, _L171);
    _L169= (W.[idxX + 1][idxY][idxZ + 1] default 0.0);
    _L170= #12 InterpolateLinear(_L181, _L190, _L167);
    idxX= _L165;
    _L171= (W.[idxX][idxY][idxZ + 1] default 0.0);
    _L172, _L173= (#5 PreLutNoSat <<Zs>>)(_L177, Z);
    _L174= #11 InterpolateLinear(_L187, _L189, _L188);
    idxY= _L176;
    _L175, _L176= (#4 PreLutNoSat <<Ys>>)(_L162, Y);
    _L177= InZ;
    rateX= _L164;
    _L178= #10 InterpolateLinear(_L182, _L186, _L163);
    _L179= rateY;
    _L180= #9 InterpolateLinear(_L181, _L183, _L169);
    _L181= rateZ;
    _L182= rateX;
    _L183= (W.[idxX + 1][idxY][idxZ] default 0.0);
    _L184= InX;
    rateY= _L175;
    idxZ= _L173;
    _L185= (W.[idxX][idxY][idxZ] default 0.0);
    _L186= #8 InterpolateLinear(_L179, _L168, _L174);
    OutW= _L178;
    _L187= rateZ;
    _L188= (W.[idxX][idxY + 1][idxZ + 1] default 0.0);
    _L189= (W.[idxX][idxY + 1][idxZ] default 0.0);
    _L190= (W.[idxX + 1][idxY + 1][idxZ] default 0.0);
  tel
  
  function #pragma kcg expand #end Lut3D<<Xs, Ys, Zs>>(
      InX : real;
      InY : real;
      InZ : real;
      X : real^Xs;
      Y : real^Ys;
      Z : real^Zs;
      W : real^Zs^Ys^Xs;
      Extrapol : bool)
    returns (OutW : real)
  var
    In1Sat : real;
    In3Sat : real;
    In2Sat : real;
    _L89 : real;
    _L90 : real;
    _L91 : real;
    _L92 : real;
  let
    activate IfBlock1 if Extrapol
      then var
        _L1 : real;
        _L2 : real;
        _L3 : real;
      let
        _L1= InX;
        _L2= InY;
        _L3= InZ;
        In1Sat= _L1;
        In2Sat= _L2;
        In3Sat= _L3;
      tel
      else var
        _L1 : real;
        _L2 : real;
        _L3 : real;
        _L4 : real;
        _L5 : real;
        _L6 : real;
      let
        _L1= InX;
        _L2= InY;
        _L3= InZ;
        In1Sat= _L4;
        In2Sat= _L5;
        In3Sat= _L6;
        _L4= #1 Limiter2(_L1, X[0], X[Xs - 1]);
        _L5= #2 Limiter2(_L2, Y[0], Y[Ys - 1]);
        _L6= #3 Limiter2(_L3, Z[0], Z[Zs - 1]);
      tel
    
    returns ..;
    _L89= (#1 Lut3DNoSat <<Xs, Ys, Zs>>)(_L90, _L91, _L92, X, Y, Z, W);
    _L90= In1Sat;
    _L91= In2Sat;
    _L92= In3Sat;
    OutW= _L89;
  tel
  
  function #pragma kcg expand #end PreLut<<Xs>>(
      InX : real;
      X : real^Xs;
      Extrapol : bool)
    returns (Out : LutIndex)
  var
    Xsat : real;
    _L44 : int;
    _L43 : real;
    _L45 : real;
    _L50 : LutIndex;
  let
    activate IfBlock1 if Extrapol
      then var
        _L7 : real;
      let
        Xsat= _L7;
        _L7= InX;
      tel
      else var
        _L5 : real;
        _L6 : real;
      let
        _L5= InX;
        Xsat= _L6;
        _L6= #1 Limiter2(_L5, X[0], X[Xs - 1]);
      tel
    
    returns ..;
    _L43, _L44= (#1 PreLutNoSat <<Xs>>)(_L45, X);
    _L45= Xsat;
    _L50= (make LutIndex)(_L44, _L43);
    Out= _L50;
  tel
  
  function private Limiter2(Val : real; Low : real; High : real)
    returns (LimitedVal : real)
  var
    _L1 : real;
    _L2 : real;
    _L3 : real;
    _L4 : bool;
    _L5 : real;
    _L6 : real;
    _L7 : bool;
  let
    _L1= Val;
    _L2= Low;
    _L3= High;
    _L4= _L1 < _L2;
    _L5= if _L4 then _L2 else _L6;
    _L6= if _L7 then _L3 else _L1;
    _L7= _L1 > _L3;
    LimitedVal= _L5;
  tel
  
end;

/* $*************** KCG Version 6.1.3 (build i6) ****************
** -
** Generation date: 2015-05-27T21:43:21
*************************************************************$ */
/* $*************** KCG Version 6.1.3 (build i6) ****************
** Command: x2s613 C:/Program Files/Esterel Technologies/SCADE R15.2/SCADE/libraries/libverif/libverif.xscade
** Generation date: 2015-05-27T21:43:21
*************************************************************$ */

/* xscade source: C:/Program Files/Esterel Technologies/SCADE R15.2/SCADE/libraries/libverif/libverif.xscade */
package verif
  node AlwaysAfterFirstCond(Input1 : bool; Cond : bool) returns (Output1 : bool)
  var
    _L1 : bool;
    _L2 : bool;
    _L3 : bool;
    _L4 : bool;
  let
    _L1= Cond;
    _L2= Input1;
    Output1= _L4;
    _L3= #1 HasNeverBeenTrue(_L1);
    _L4= _L3 or _L2;
  tel
  
  node #pragma kcg expand #end HasNeverBeenTrue(Input1 : bool)
    returns (Output1 : bool)
  var
    _L1 : bool;
    _L2 : bool;
    _L3 : bool;
    _L4 : bool;
    _L5 : bool;
  let
    _L1= Input1;
    Output1= _L2;
    _L2= _L4 -> _L5;
    _L3= pre _L2;
    _L4= not _L1;
    _L5= _L4 and _L3;
  tel
  
  function #pragma kcg expand #end Implies(A : bool; B : bool)
    returns (C : bool)
  var
    _L1 : bool;
    _L2 : bool;
    _L3 : bool;
    _L4 : bool;
  let
    _L1= A;
    _L2= B;
    C= _L3;
    _L3= _L4 or _L2;
    _L4= not _L1;
  tel
  
  node AtLeastNTicks(Input1 : bool; N : int) returns (Output1 : bool)
  var
    cnt : int;
    _L1 : bool;
    _L2 : int;
    _L3 : int;
    _L5 : int;
    _L6 : int;
    _L7 : int;
    _L8 : int;
    _L10 : int;
    _L11 : int;
    _L22 : int;
    _L23 : int;
    _L24 : bool;
    _L25 : bool;
    _L32 : bool;
    _L33 : int;
  let
    _L1= Input1;
    _L2= N;
    Output1= _L25;
    _L3= _L10 + _L6;
    _L5= cnt;
    _L6= _L8 -> _L7;
    _L7= pre _L5;
    _L8= 0;
    _L10= 1;
    _L11= if _L1 then _L3 else _L8;
    cnt= _L33;
    _L22= N;
    _L23= cnt;
    _L24= _L23 >= _L22;
    _L25= _L24 and _L1;
    _L32= _L11 < _L2;
    _L33= if _L32 then _L11 else _L2;
  tel
  
  node ImpliesWithinNTick(Input1 : bool; Input2 : bool; N : int)
    returns (Output1 : bool)
  var
    _L5 : bool;
    _L4 : bool;
    _L2 : bool;
    _L1 : bool;
  let
    _L5= #1 Implies(_L4, _L1);
    _L4= #2 AtLeastNTicks(_L2, N);
    Output1= _L5;
    _L2= Input1;
    _L1= Input2;
  tel
  
  node AfterNthTick<<N>>(Input1 : bool) returns (Output1 : bool)
  var
    _L6 : bool;
    _L5 : bool;
    _L4 : bool;
    _L3 : bool;
    _L2 : bool;
    _L1 : bool;
  let
    _L6= false;
    _L5= true;
    _L4= true;
    _L3= if _L2 then _L1 else _L4;
    _L2= fby(_L5; N; _L6);
    Output1= _L3;
    _L1= Input1;
  tel
  
end;

/* $*************** KCG Version 6.1.3 (build i6) ****************
** -
** Generation date: 2015-05-27T21:43:21
*************************************************************$ */
/* $*************** KCG Version 6.1.3 (build i6) ****************
** Command: x2s613 C:/Users/Baseliyos/Documents/GitHub_05_2015/model/Scade/System/ObuFunctions/Obu_BasicTypes/Obu_BasicTypes_Pkg.xscade
** Generation date: 2015-05-27T21:43:21
*************************************************************$ */

/* xscade source: C:/Users/Baseliyos/Documents/GitHub_05_2015/model/Scade/System/ObuFunctions/Obu_BasicTypes/Obu_BasicTypes_Pkg.xscade */
package Obu_BasicTypes_Pkg
  const cLocWithInAcc_0 : LocWithInAcc_T = { nominal:0, d_min:0, d_max:0 };
  
  const
    cOdometryInitialValue : OdometryLocations_T
      = { o_nominal:0, o_min:0, o_max:0 };
  
  type L_internal_Type = int;
  
  type T_internal_Type = int;
  
  type V_internal_Type = int;
  
  type G_internal_Type = int;
  
  type A_internal_Type = int;
  
  type Location_T = L_internal_Type;
  
  type
    LocWithInAcc_T = {
      nominal : L_internal_Type,
      d_min : L_internal_Type,
      d_max : L_internal_Type
    };
  
  type
    OdometryLocations_T = {
      o_nominal : L_internal_Type,
      o_min : L_internal_Type,
      o_max : L_internal_Type
    };
  
  type
    odometry_T = {
      valid : bool,
      timestamp : T_internal_Type,
      odo : OdometryLocations_T,
      speed : OdometrySpeeds_T,
      acceleration : A_internal_Type,
      motionState : odoMotionState_T,
      motionDirection : odoMotionDirection_T
    };
  
  type Speed_T = V_internal_Type;
  
  type odoMotionState_T = enum { noMotion, Motion };
  
  type odoMotionDirection_T = enum { unknownDirection, cabAFirst, cabBFirst };
  
  type BCD_T = int;
  
  type
    OdometrySpeeds_T = {
      v_safeNominal : V_internal_Type,
      v_rawNominal : V_internal_Type,
      v_lower : V_internal_Type,
      v_upper : V_internal_Type
    };
  
end;

/* $*************** KCG Version 6.1.3 (build i6) ****************
** -
** Generation date: 2015-05-27T21:43:21
*************************************************************$ */
/* $*************** KCG Version 6.1.3 (build i6) ****************
** Command: x2s613 C:/Users/Baseliyos/Documents/GitHub_05_2015/model/Scade/System/APITypes/API_Msg_Pkg..xscade
** Generation date: 2015-05-27T21:43:21
*************************************************************$ */

/* xscade source: C:/Users/Baseliyos/Documents/GitHub_05_2015/model/Scade/System/APITypes/API_Msg_Pkg..xscade */
package API_Msg_Pkg
  type
    API_TelegramHeader_T = {
      present : bool,
      checkResult : bool,
      api_bad_balise_received : bool,
      api_header : BG_Types_Pkg::TelegramHeader_T,
      centerOfBalisePosition : BG_Types_Pkg::centerOfBalisePosition_T
    };
  
  type
    API_TrackSideInput_T = {
      valid : bool,
      systemTimeMsgReceived : Obu_BasicTypes_Pkg::T_internal_Type,
      msg_type : Common_Types_Pkg::MsgSource_T,
      btm_msg : API_TelegramHeader_T,
      rtm_msg : API_RadioMsgHeader_T,
      packets : Common_Types_Pkg::CompressedPackets_T
    };
  
  type
    API_RadioMsgHeader_T = {
      present : bool,
      apiConsistencyError : bool,
      Radio_Common_Header : Radio_Types_Pkg::Radio_TrackTrain_Header_T,
      Radio_MetaData : Common_Types_Pkg::RadioMetadata_T
    };
  
end;

/* $*************** KCG Version 6.1.3 (build i6) ****************
** -
** Generation date: 2015-05-27T21:43:21
*************************************************************$ */
/* $*************** KCG Version 6.1.3 (build i6) ****************
** Command: x2s613 C:/Users/Baseliyos/Documents/GitHub_05_2015/model/Scade/System/APITypes/TIU_Types_Pkg.xscade
** Generation date: 2015-05-27T21:43:21
*************************************************************$ */

/* xscade source: C:/Users/Baseliyos/Documents/GitHub_05_2015/model/Scade/System/APITypes/TIU_Types_Pkg.xscade */
package TIU_Types_Pkg
  const
    emptyTIUInfo : Message_Train_Interface_to_EVC_T
      = {
          train_status:{
              valid:false,
              m_sleeping_st:signal_active,
              m_passiveshunting_st:passive_shunting_permitted,
              m_nonleading_st:non_leading_signall_status_not_defined,
              m_cab_st:both_desks_are_closed,
              m_directioncontroller_st:direction_controller_in_neutral,
              m_trainintegrity_st:train_is_not_integer,
              m_traction_st:traction_on },
          brake_status:{
              valid:false,
              m_regenerativebrake_st:is_active,
              m_eddycurrentbrake_st:is_active,
              m_magneticshoebrake_st:is_active,
              m_electropneumaticbrake_st:is_active,
              m_additionalbrake_st:is_active },
          brake_pressure:{ valid:false, pressure:0 },
          train_data_entry_type:fixed_entry_type,
          train_data_info:{
              valid:false,
              acknowledgedByDriver:false,
              trainCategory:NC_TRAIN_Train_does_not_belong_to_any_of_the_Other_International_Train_Category,
              trainLength:0,
              brakePerctage:0,
              maxTrainSpeed:0,
              loadingGauge:M_LOADINGGAUGE_The_train_does_not_fit_to_any_of_the_interoperable_loading_gauge_profiles,
              axleLoadCategory:M_AXLELOADCAT_A,
              airtightSystem:M_AIRTIGHT_Not_fitted,
              axleNumber:0,
              nationSystems:[0, 0, 0],
              tractionSystem:[{
                    m_voltage:M_VOLTAGE_Line_not_fitted_with_any_traction_system,
                    nid_ctraction:0 }, {
                    m_voltage:M_VOLTAGE_Line_not_fitted_with_any_traction_system,
                    nid_ctraction:0 }, {
                    m_voltage:M_VOLTAGE_Line_not_fitted_with_any_traction_system,
                    nid_ctraction:0 }] },
          type_I_train_and_brake_inhibition:{
              valid:false,
              nothing_to_resume_profile_follow:{
                  d_test_trackcond:{ now:0, distance:0 },
                  l_test_trackcond:{ now:0, distance:0 },
                  m_trackcond:non_stopping_area },
              empty_profile_initial_state_to_be_resumed:{
                  now:0,
                  distance:0 } } };
  
  type
    Type_I_train_commands_T = {
      valid : bool,
      m_pantograph_cm : M_pantograph_command_T,
      m_airtightness_cm : M_airtightness_command_T,
      m_mainpowerswitch_cm : M_mainpowerswitch_command_T,
      m_traction_cutoff_cm : M_traction_cutoff_command_T
    };
  
  type
    Type_I_train_and_brake_inhibition_with_distance_commands_T = {
      valid : bool,
      nothing_to_resume_profile_follow : nothing_to_resume_profile_follow_T,
      empty_profile_initial_state_to_be_resumed : D_test_trackinit_T
    };
  
  type
    S_nothing_to_resume_profile_follow_T = {
      nIter : int,
      value : A_nothing_to_resume_profile_follow_T
    };
  
  type
    Passenger_door_control_info_T = { valid : bool, door_control_info : int };
  
  type Brake_pressure_value_T = { valid : bool, pressure : int };
  
  type
    nothing_to_resume_profile_follow_T = {
      d_test_trackcond : D_test_trackcond_T,
      l_test_trackcond : L_test_trackcond_T,
      m_trackcond : M_trackcond_T
    };
  
  type NID_ctraction_T = int;
  
  type
    Mode_control_and_train_status_T = {
      valid : bool,
      m_sleeping_st : M_sleeping_signal_status_T,
      m_passiveshunting_st : M_passiveshunting_signal_status_T,
      m_nonleading_st : M_nonleading_signal_status_T,
      m_cab_st : M_cab_signal_status_T,
      m_directioncontroller_st : M_directioncontroller_signal_status_T,
      m_trainintegrity_st : M_trainintegrity_signal_status_T,
      m_traction_st : M_traction_signal_status_T
    };
  
  type
    Message_Train_Interface_to_EVC_T = {
      train_status : Mode_control_and_train_status_T,
      brake_status : Brake_status_T,
      brake_pressure : Brake_pressure_value_T,
      train_data_entry_type : M_train_data_entry_type_T,
      train_data_info : trainData_T,
      type_I_train_and_brake_inhibition : Type_I_train_and_brake_inhibition_with_distance_commands_T
    };
  
  type
    Message_EVC_to_Train_Interface_T = {
      isolation_status : Isolation_Status_T,
      brake_command : Brake_command_T,
      brake_inhibition : Brake_inhibition_command_T,
      type_I_train_commands : Type_I_train_commands_T,
      change_traction_system : Change_traction_system_T,
      passenger_door_control_info : Passenger_door_control_info_T,
      change_of_allowed_current_consumption : Change_of_allowed_current_consumption_T
    };
  
  type
    M_voltage_types_T = enum {
      line_not_fitted_with_any_traction_system,
      ac_25kV_50Hz,
      ac_15kV_16_7Hz,
      dc_3kV,
      dc_1_5kV,
      dc_600_750kV
    };
  
  type
    M_voltage_T = {
      voltage_type : M_voltage_types_T,
      NID_ctraction : NID_ctraction_T
    };
  
  type
    trainData_T = {
      valid : bool,
      acknowledgedByDriver : bool,
      trainCategory : NC_TRAIN,
      trainLength : Obu_BasicTypes_Pkg::L_internal_Type,
      brakePerctage : int,
      maxTrainSpeed : Obu_BasicTypes_Pkg::V_internal_Type,
      loadingGauge : M_LOADINGGAUGE,
      axleLoadCategory : M_AXLELOADCAT,
      airtightSystem : M_AIRTIGHT,
      axleNumber : int,
      nationSystems : Packet_TrainTypes_Pkg::aNID_NTC_T,
      tractionSystem : Packet_TrainTypes_Pkg::aTractionIdentity_T
    };
  
  type
    M_trackcond_T = enum {
      non_stopping_area,
      tunnel_stopping_area,
      sound_horn,
      powerless_section_lower_pantograph,
      radio_hole,
      air_tightness,
      switch_off_regenerative_brake,
      switch_off_eddy_current_brake_for_service_brake,
      switch_off_magnetic_shoe_brake,
      powerless_section_switch_off_main_power_switch,
      switch_off_eddy_current_brake_for_emergency_brake
    };
  
  type M_current_T = { no_restriction : bool, restriction : int };
  
  type
    Change_traction_system_T = {
      valid : bool,
      d_test_traction : D_test_traction_T,
      m_voltage : M_voltage_T
    };
  
  type
    M_traction_cutoff_command_T = enum {
      traction_cutoff_command_not_defined,
      apply_traction_cutoff,
      release_traction_cutoff
    };
  
  type
    M_mainpowerswitch_command_T = enum {
      open_main_power_swicth,
      close_main_power_switch
    };
  
  type
    M_airtightness_command_T = enum {
      airtightness_command_not_defined,
      tunnel_condition_active,
      tunnel_condition_not_active
    };
  
  type
    M_pantograph_command_T = enum {
      pantograph_command_not_defined,
      lower_pantograph,
      raise_pantograph
    };
  
  type
    M_train_data_entry_type_T = enum {
      fixed_entry_type,
      flexible_entry_type,
      switchable_entry_type,
      no_entry_type
    };
  
  type
    M_eddy_current_brake_inhibition_T = enum {
      eddy_current_brake_inhibition_not_defined,
      inhibit_for_service_brake,
      inhibit_for_emergency_brake,
      inhibit_for_both_service_emergency_brake,
      do_not_inhibit_for_service_brake,
      do_not_inhibit_for_emergency_brake,
      do_not_inhibit_for_both_service_emergency_brake
    };
  
  type
    M_brake_inhibit_command_T = enum {
      brake_inhibit_not_defined,
      inhibit_brake,
      do_not_inhibit_brake
    };
  
  type
    M_brake_signal_command_T = enum {
      brake_signal_command_not_defined,
      apply_brake,
      release_brake
    };
  
  type
    M_brake_status_T = enum {
      brake_status_not_defined,
      is_active,
      is_not_active
    };
  
  type
    M_Isolation_status_T = enum {
      on_board_equipment_is_isolated,
      on_board_equipement_is_not_isolated,
      isolation_status_not_defined
    };
  
  type M_traction_signal_status_T = enum { traction_on, traction_off };
  
  type
    M_trainintegrity_signal_status_T = enum {
      train_is_not_integer,
      train_is_integer
    };
  
  type
    M_directioncontroller_signal_status_T = enum {
      direction_controller_in_neutral,
      direction_controller_in_forward,
      direction_controller_in_backward
    };
  
  type
    M_cab_signal_status_T = enum {
      cab_signal_status_not_defined,
      both_desks_are_closed,
      desk_A_is_open,
      desk_B_is_open,
      both_desks_are_open
    };
  
  type
    M_nonleading_signal_status_T = enum {
      non_leading_signall_status_not_defined,
      non_leading_permitted,
      non_leading_not_permitted
    };
  
  type
    M_passiveshunting_signal_status_T = enum {
      passive_shunting_permitted,
      passive_shunting_not_permitted
    };
  
  type M_sleeping_signal_status_T = enum { signal_active, signal_not_active };
  
  type L_test_trackcond_T = D_test_distance_T;
  
  type D_test_traction_T = D_test_distance_T;
  
  type D_test_trackinit_T = D_test_distance_T;
  
  type D_test_trackcond_T = D_test_distance_T;
  
  type D_test_distance_T = { now : int, distance : int };
  
  type D_test_current_T = D_test_distance_T;
  
  type
    Change_of_allowed_current_consumption_T = {
      valid : bool,
      d_test_current : D_test_current_T,
      m_current : M_current_T
    };
  
  type
    Brake_status_T = {
      valid : bool,
      m_regenerativebrake_st : M_brake_status_T,
      m_eddycurrentbrake_st : M_brake_status_T,
      m_magneticshoebrake_st : M_brake_status_T,
      m_electropneumaticbrake_st : M_brake_status_T,
      m_additionalbrake_st : M_brake_status_T
    };
  
  type
    Brake_inhibition_command_T = {
      valid : bool,
      m_regenerativebrake_cm : M_brake_inhibit_command_T,
      m_eddycurrentbrake_cm : M_eddy_current_brake_inhibition_T,
      m_magneticshoebrake_cm : M_brake_inhibit_command_T
    };
  
  type
    Brake_command_T = {
      valid : bool,
      m_servicebrake_cm : M_brake_signal_command_T,
      m_emergencybrake_cm : M_brake_signal_command_T
    };
  
  type
    A_nothing_to_resume_profile_follow_T = nothing_to_resume_profile_follow_T^32;
  
  type
    Isolation_Status_T = {
      valid : bool,
      isolation_status : M_Isolation_status_T
    };
  
  type
    TIU_trainStatus_T = {
      valid : bool,
      deskOpen : bool,
      ownCab : cab_ID_T,
      activeCab : cab_ID_T
    };
  
  type
    TIU_commandStatus_T = {
      valid : bool,
      emergencyBrakeActive : bool,
      isolationStatus : bool
    };
  
  type cab_ID_T = enum { CabUndefined, CabA, CabB };
  
end;

/* $*************** KCG Version 6.1.3 (build i6) ****************
** -
** Generation date: 2015-05-27T21:43:21
*************************************************************$ */
/* $*************** KCG Version 6.1.3 (build i6) ****************
** Command: x2s613 C:/Users/Baseliyos/Documents/GitHub_05_2015/model/Scade/System/APITypes/API_TIU_Pkg.xscade
** Generation date: 2015-05-27T21:43:21
*************************************************************$ */

/* xscade source: C:/Users/Baseliyos/Documents/GitHub_05_2015/model/Scade/System/APITypes/API_TIU_Pkg.xscade */
package API_TIU_Pkg
  type
    TIU_Input_msg = {
      valid : bool,
      info : TIU_Types_Pkg::Message_Train_Interface_to_EVC_T
    };
  
  type
    TIU_Output_msg = {
      valid : bool,
      info : TIU_Types_Pkg::Message_EVC_to_Train_Interface_T
    };
  
end;

/* $*************** KCG Version 6.1.3 (build i6) ****************
** -
** Generation date: 2015-05-27T21:43:21
*************************************************************$ */
/* $*************** KCG Version 6.1.3 (build i6) ****************
** Command: x2s613 C:/Users/Baseliyos/Documents/GitHub_05_2015/model/Scade/System/APITypes/API_RadioCommunication_Pkg.xscade
** Generation date: 2015-05-27T21:43:21
*************************************************************$ */

/* xscade source: C:/Users/Baseliyos/Documents/GitHub_05_2015/model/Scade/System/APITypes/API_RadioCommunication_Pkg.xscade */
package API_RadioCommunication_Pkg
  const
    cInitOutputToRadioAPI : Radio_Types_Pkg::Radio_TrainTrack_Message_T
      = {
          present:false,
          header:{
              present:false,
              nid_message:0,
              t_train:0.0,
              nid_engine:0,
              xQ_MARQSTREASON:Q_MARQSTREASON_Start_selected_by_driver,
              xT_TRAIN:0.0 },
          packets:{
              p0:{
                  valid:false,
                  packet0:{
                      NID_PACKET:0,
                      L_PACKET:0,
                      qscale:Q_SCALE_10_cm_scale,
                      NID_LRBG:0,
                      D_LRBG:0,
                      dirlrbg:Q_DIRLRBG_Reverse,
                      dlrbg:Q_DLRBG_Reverse,
                      L_DOUBTOVER:0,
                      L_DOUBTUNDER:0,
                      length:Q_LENGTH_No_train_integrity_information_available,
                      L_TRAININT:0,
                      V_TRAIN:0,
                      dirtrain:Q_DIRTRAIN_Reverse,
                      mode:M_MODE_Full_Supervision,
                      level:M_LEVEL_Level_0,
                      NID_NTC:0 } },
              p1:{
                  valid:false,
                  packet1:{
                      NID_PACKET:0,
                      L_PACKET:0,
                      qscale:Q_SCALE_10_cm_scale,
                      NID_LRBG:0,
                      NID_PRVLRBG:0,
                      D_LRBG:0,
                      dirlrbg:Q_DIRLRBG_Reverse,
                      dlrbg:Q_DLRBG_Reverse,
                      L_DOUBTOVER:0,
                      L_DOUBTUNDER:0,
                      length:Q_LENGTH_No_train_integrity_information_available,
                      L_TRAININT:0,
                      V_TRAIN:0,
                      dirtrain:Q_DIRTRAIN_Reverse,
                      mode:M_MODE_Full_Supervision,
                      level:M_LEVEL_Level_0,
                      NID_NTC:0 } },
              p3:{
                  valid:false,
                  number:0,
                  aNID_RADIO:[{
                        valid:false,
                        telephoneNumber:[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                          0, 0] }] },
              p4:{
                  valid:false,
                  M_ERROR:M_ERROR_Balise_group_linking_consistency_error },
              p5:{ valid:false, TrainRunningNumber:0 },
              p11:{
                  valid:false,
                  NC_CDTRAIN:NC_CDTRAIN_Cant_Deficiency_80_mm,
                  NC_TRAIN:NC_TRAIN_Train_does_not_belong_to_any_of_the_Other_International_Train_Category,
                  l_train:0,
                  v_maxtrain:0,
                  m_loadinggoage:M_LOADINGGAUGE_The_train_does_not_fit_to_any_of_the_interoperable_loading_gauge_profiles,
                  m_axleloadcat:M_AXLELOADCAT_A,
                  m_airtight:M_AIRTIGHT_Not_fitted,
                  n_axle:0,
                  nIter_tractionIdentity:0,
                  tractionIdentity:[{
                        m_voltage:M_VOLTAGE_Line_not_fitted_with_any_traction_system,
                        nid_ctraction:0 }, {
                        m_voltage:M_VOLTAGE_Line_not_fitted_with_any_traction_system,
                        nid_ctraction:0 }, {
                        m_voltage:M_VOLTAGE_Line_not_fitted_with_any_traction_system,
                        nid_ctraction:0 }],
                  nIter_ntc:0,
                  nid_ntc:[0, 0, 0] } } };
  
  type
    API_CommunicationStatus_T = {
      CommunicationSessionNumber : int,
      mobileInformation : radioUnitToEVC_T
    };
  
  type
    radioUnitToEVC_T = {
      valid : bool,
      network_ID : int,
      health_Status : connectionStatusRadioUnit_T,
      responseRadioUnit : responseRadioUnit_T
    };
  
  type
    API_EuroRadioOutput_T = {
      firstOutput : Radio_Types_Pkg::Radio_TrainTrack_Message_T,
      secondOutput : Radio_Types_Pkg::Radio_TrainTrack_Message_T,
      thirdOutput : Radio_Types_Pkg::Radio_TrainTrack_Message_T,
      radioEVCtoUnit : RadioManagement_T
    };
  
  type
    RadioManagement_T = {
      valid : bool,
      cmd : cmdRadioUnit_T,
      networkID : NID_MN
    };
  
  type
    cmdRadioUnit_T = enum {
      cmdr_not_relevant,
      cmdr_connection_request,
      cmdr_disconnection_request,
      cmdr_reset_connection,
      cmdr_networkUnregister,
      cmdr_networkRegister
    };
  
  type
    responseRadioUnit_T = enum {
      rspr_not_relevant,
      rspr_connection_confirmation,
      rspr_connection_lost,
      rspr_connection_failure,
      rspr_connection_not_established
    };
  
  type
    connectionStatusRadioUnit_T = enum {
      conn_unknown,
      conn_no_connection,
      conn_ConnectionUp,
      conn_SetupFailed
    };
  
end;

/* $*************** KCG Version 6.1.3 (build i6) ****************
** -
** Generation date: 2015-05-27T21:43:21
*************************************************************$ */
/* $*************** KCG Version 6.1.3 (build i6) ****************
** Command: x2s613 C:/Users/Baseliyos/Documents/GitHub_05_2015/model/Scade/System/APITypes/DMI_Messages_Bothways_Pkg.xscade
** Generation date: 2015-05-27T21:43:21
*************************************************************$ */

/* xscade source: C:/Users/Baseliyos/Documents/GitHub_05_2015/model/Scade/System/APITypes/DMI_Messages_Bothways_Pkg.xscade */
package DMI_Messages_Bothways_Pkg
  const cDiverIdentifierLength : int = 9;
  
  type
    DMI_Train_Running_Number_T = {
      valid : bool,
      systemTime : Obu_BasicTypes_Pkg::T_internal_Type,
      trainRunningNumber : NID_OPERATIONAL
    };
  
  type
    DMI_Adhesion_Factor_Data_T = {
      valid : bool,
      systemTime : Obu_BasicTypes_Pkg::T_internal_Type,
      adhesionFactor : M_ADHESION
    };
  
  type
    DMI_Driver_Identifier_T = {
      valid : bool,
      systemTime : Obu_BasicTypes_Pkg::T_internal_Type,
      driverIdentifier : driverIdentifier_T
    };
  
  type
    DMI_Train_Data_T = {
      valid : bool,
      systemTime : Obu_BasicTypes_Pkg::T_internal_Type,
      trainCategory : NC_TRAIN,
      l_train : Obu_BasicTypes_Pkg::L_internal_Type,
      m_brakeperct : DMI_Types_Pkg::M_BRAKEPERCT,
      v_maxTrain : Obu_BasicTypes_Pkg::V_internal_Type,
      m_axleLoad : M_AXLELOADCAT,
      m_airTight : M_AIRTIGHT,
      m_loadingGauge : M_LOADINGGAUGE
    };
  
  type driverIdentifier_T = char^cDiverIdentifierLength;
  
  type
    DMI_Level_Data_T = {
      valid : bool,
      systemTime : Obu_BasicTypes_Pkg::T_internal_Type,
      level : DMI_Types_Pkg::DMI_level_T
    };
  
end;

/* $*************** KCG Version 6.1.3 (build i6) ****************
** -
** Generation date: 2015-05-27T21:43:21
*************************************************************$ */
/* $*************** KCG Version 6.1.3 (build i6) ****************
** Command: x2s613 C:/Users/Baseliyos/Documents/GitHub_05_2015/model/Scade/System/APITypes/DMI_Messages_DMI_to_EVC_Pkg.xscade
** Generation date: 2015-05-27T21:43:21
*************************************************************$ */

/* xscade source: C:/Users/Baseliyos/Documents/GitHub_05_2015/model/Scade/System/APITypes/DMI_Messages_DMI_to_EVC_Pkg.xscade */
package DMI_Messages_DMI_to_EVC_Pkg
  type
    DMI_Status_T = {
      valid : bool,
      systemTime : Obu_BasicTypes_Pkg::T_internal_Type,
      statusSet : DMI_Types_Pkg::DMI_StatusSet_T,
      nAlive : int
    };
  
  type
    DMI_Driver_Request_T = {
      valid : bool,
      systemTime : Obu_BasicTypes_Pkg::T_internal_Type,
      m_request : DMI_Types_Pkg::DMI_Request_T
    };
  
  type
    DMI_Text_Message_Ack_T = {
      valid : bool,
      systemTime : Obu_BasicTypes_Pkg::T_internal_Type,
      messageIdentifier : NID_MESSAGE,
      acknowledged : bool
    };
  
  type
    DMI_Set_VBC_Data_T = {
      valid : bool,
      systemTime : Obu_BasicTypes_Pkg::T_internal_Type
    };
  
  type
    DMI_Radio_Net_Data_T = {
      valid : bool,
      systemTime : Obu_BasicTypes_Pkg::T_internal_Type
    };
  
  type
    DMI_SetVBC_Data_Ack_T = {
      valid : bool,
      systemTime : Obu_BasicTypes_Pkg::T_internal_Type
    };
  
  type
    DMI_RmVBC_Data_Ack_T = {
      valid : bool,
      systemTime : Obu_BasicTypes_Pkg::T_internal_Type
    };
  
  type
    DMI_NTC_Output_T = {
      valid : bool,
      systemTime : Obu_BasicTypes_Pkg::T_internal_Type
    };
  
  type
    DMI_Rm_VBC_Data_T = {
      valid : bool,
      systemTime : Obu_BasicTypes_Pkg::T_internal_Type
    };
  
  type
    DMI_Icon_Ack_T = {
      valid : bool,
      systemTime : Obu_BasicTypes_Pkg::T_internal_Type,
      DMI_nid_icon_identifier : int
    };
  
  type
    DMI_Sounds_Status_T = {
      valid : bool,
      systemTime : Obu_BasicTypes_Pkg::T_internal_Type
    };
  
  type
    DMI_Train_Data_Ack_T = {
      valid : bool,
      systemTime : Obu_BasicTypes_Pkg::T_internal_Type,
      acknowledged : bool
    };
  
  type
    DMI_Identifier_T = {
      valid : bool,
      systemTime : Obu_BasicTypes_Pkg::T_internal_Type,
      DMI_Identifier : DMI_Types_Pkg::DMI_DMI_Identifier_T,
      Cabin_Identifier : DMI_Types_Pkg::DMI_Cabin_Identifier_T,
      l_name : L_TEXT,
      DMI_name : DMI_Types_Pkg::DMI_TEXT,
      M_VERSION : M_VERSION
    };
  
end;

/* $*************** KCG Version 6.1.3 (build i6) ****************
** -
** Generation date: 2015-05-27T21:43:21
*************************************************************$ */
/* $*************** KCG Version 6.1.3 (build i6) ****************
** Command: x2s613 C:/Users/Baseliyos/Documents/GitHub_05_2015/model/Scade/System/APITypes/DMI_Messages_EVC_to_DMI_Pkg.xscade
** Generation date: 2015-05-27T21:43:21
*************************************************************$ */

/* xscade source: C:/Users/Baseliyos/Documents/GitHub_05_2015/model/Scade/System/APITypes/DMI_Messages_EVC_to_DMI_Pkg.xscade */
package DMI_Messages_EVC_to_DMI_Pkg
  type
    DMI_Dynamic_T = {
      valid : bool,
      system_clock : Obu_BasicTypes_Pkg::T_internal_Type,
      v_train : Obu_BasicTypes_Pkg::V_internal_Type,
      location_front_train : Obu_BasicTypes_Pkg::L_internal_Type,
      location_brake_target : Obu_BasicTypes_Pkg::L_internal_Type,
      v_target : Obu_BasicTypes_Pkg::V_internal_Type,
      v_permitted : Obu_BasicTypes_Pkg::V_internal_Type,
      v_release : Obu_BasicTypes_Pkg::V_internal_Type,
      location_brake_curve_starting_point : Obu_BasicTypes_Pkg::L_internal_Type,
      v_intervention : Obu_BasicTypes_Pkg::V_internal_Type,
      mode : M_MODE,
      level : DMI_Types_Pkg::DMI_level_T,
      nid_c : NID_C,
      nid_c_valid : bool,
      m_warning : DMI_Types_Pkg::M_SupervisionDisplay_T,
      sup_status : DMI_Types_Pkg::M_SUPERVISION_STATUS,
      location_LOA : Obu_BasicTypes_Pkg::L_internal_Type,
      v_LOA : Obu_BasicTypes_Pkg::V_internal_Type,
      location_KP_Balise_Track : Obu_BasicTypes_Pkg::L_internal_Type,
      distance_KP_Balise : Obu_BasicTypes_Pkg::L_internal_Type,
      distance_to_TSA : Obu_BasicTypes_Pkg::L_internal_Type,
      radioConnectionStatus : API_RadioCommunication_Pkg::connectionStatusRadioUnit_T
    };
  
  type
    DMI_Entry_Request_T = {
      valid : bool,
      system_clock : Obu_BasicTypes_Pkg::T_internal_Type,
      entry_request : DMI_Types_Pkg::DMI_List_Entry_Request_T
    };
  
  type
    DMI_Menu_Request_T = {
      valid : bool,
      system_clock : Obu_BasicTypes_Pkg::T_internal_Type,
      available_menu : DMI_Types_Pkg::DMI_Available_Menu_T
    };
  
  type
    DMI_Text_Message_T = {
      valid : bool,
      system_clock : Obu_BasicTypes_Pkg::T_internal_Type,
      nid_message : NID_MESSAGE,
      q_text : DMI_Types_Pkg::DMI_Q_TEXT,
      l_text : L_TEXT,
      x_text : DMI_Types_Pkg::DMI_TEXT,
      q_textClass : Q_TEXTCLASS,
      q_textConfirm : Q_TEXTCONFIRM
    };
  
  type
    DMI_EVC_Coded_Train_Data_T = {
      valid : bool,
      system_clock : Obu_BasicTypes_Pkg::T_internal_Type,
      trainID : DMI_Types_Pkg::DMI_train_id_T,
      trainLength : DMI_Types_Pkg::DMI_train_length_T,
      brakeModel : DMI_Types_Pkg::DMI_brakeModel_id_T,
      vmax : DMI_Types_Pkg::DMI_vMax_id_T,
      mAxleLoad : M_AXLELOADCAT,
      airTightSystem : DMI_Types_Pkg::DMI_airtightSystem_T,
      mLoadingGauge : DMI_Types_Pkg::DMI_loadingGauge_T
    };
  
  type
    DMI_Track_Description_T = {
      valid : bool,
      system_clock : Obu_BasicTypes_Pkg::T_internal_Type,
      speedProfiles : DMI_Types_Pkg::DMI_speedProfile_T,
      gradientProfiles : DMI_Types_Pkg::DMI_gradientProfile_T,
      trackConditions : DMI_Types_Pkg::DMI_trackCondition_T
    };
  
  type
    DMI_Identifier_Request_T = {
      valid : bool,
      system_clock : Obu_BasicTypes_Pkg::T_internal_Type,
      ERTMS_Version : M_VERSION,
      EVC_Version : M_VERSION,
      l_name : L_TEXT,
      x_name : DMI_Types_Pkg::DMI_TEXT,
      l_extra : L_TEXT
    };
  
  type
    DMI_Icons_T = {
      valid : bool,
      system_clock : Obu_BasicTypes_Pkg::T_internal_Type,
      DMI_m_icon_control_flag : DMI_Types_Pkg::Icon_control_flag_T,
      DMI_m_icon_flashing_freq : real,
      DMI_nid_icon_group : DMI_Types_Pkg::Icon_group_T,
      DMI_nid_icon_rank : int,
      DMI_nid_area_group : DMI_Types_Pkg::Area_group_T,
      DMI_nid_area_rank : int,
      DMI_nid_icon_identifier : int
    };
  
  type
    DMI_System_Version_T = {
      valid : bool,
      system_clock : Obu_BasicTypes_Pkg::T_internal_Type,
      system_version : M_VERSION
    };
  
  type
    DMI_Display_Control_T = {
      valid : bool,
      cab_is_active : bool,
      system_clock : Obu_BasicTypes_Pkg::T_internal_Type
    };
  
  type
    DMI_EVC_Level_Data_T = {
      valid : bool,
      system_clock : Obu_BasicTypes_Pkg::T_internal_Type,
      n_iter : N_ITER,
      levelList : DMI_Types_Pkg::DMI_LevelList_T
    };
  
  type
    DMI_EVC_Radio_Net_Data_T = {
      valid : bool,
      system_clock : Obu_BasicTypes_Pkg::T_internal_Type,
      nid_mn : NID_MN
    };
  
  type
    DMI_EVC_VBC_Datat_T = {
      valid : bool,
      system_clock : Obu_BasicTypes_Pkg::T_internal_Type
    };
  
  type
    DMI_User_Function_T = {
      valid : bool,
      system_clock : Obu_BasicTypes_Pkg::T_internal_Type
    };
  
  type
    DMI_EVC_Coded_SetVBC_Data_T = {
      valid : bool,
      system_clock : Obu_BasicTypes_Pkg::T_internal_Type
    };
  
  type
    DMI_EVC_Coded_RmVBC_Data_T = {
      valid : bool,
      system_clock : Obu_BasicTypes_Pkg::T_internal_Type
    };
  
  type
    DMI_NTC_Input_T = {
      valid : bool,
      system_clock : Obu_BasicTypes_Pkg::T_internal_Type
    };
  
  type
    DMI_NTC_Data_Entry_T = {
      valid : bool,
      system_clock : Obu_BasicTypes_Pkg::T_internal_Type
    };
  
end;

/* $*************** KCG Version 6.1.3 (build i6) ****************
** -
** Generation date: 2015-05-27T21:43:21
*************************************************************$ */
/* $*************** KCG Version 6.1.3 (build i6) ****************
** Command: x2s613 C:/Users/Baseliyos/Documents/GitHub_05_2015/model/Scade/System/APITypes/DMI_Types_Pkg.xscade
** Generation date: 2015-05-27T21:43:21
*************************************************************$ */

/* xscade source: C:/Users/Baseliyos/Documents/GitHub_05_2015/model/Scade/System/APITypes/DMI_Types_Pkg.xscade */
package DMI_Types_Pkg
  const cDMI_maxTrackCondProfile : int = 4;
  
  const cDMI_maxSpeedProfile : int = 4;
  
  const cDMI_maxLevels : int = 32;
  
  const cDMI_maxGradientProfile : int = 4;
  
  const cDMI_charsInText : int = 255;
  
  const cDMIUnknownSpeed : Obu_BasicTypes_Pkg::V_internal_Type = -1;
  
  type NID_STM = int;
  
  type
    M_SUPERVISION_STATUS = enum {
      CSM,
      PIM,
      TSM,
      RSM,
      supervision_status_unknown
    };
  
  type DMI_vMax_id_T = { number : int, dig1 : BCD, dig2 : BCD, dig3 : BCD };
  
  type
    DMI_train_length_T = {
      number : int,
      dig1 : BCD,
      dig2 : BCD,
      dig3 : BCD,
      dig4 : BCD
    };
  
  type
    DMI_train_id_T = {
      number : int,
      dig1 : BCD,
      dig2 : BCD,
      dig3 : BCD,
      dig4 : BCD,
      dig5 : BCD
    };
  
  type
    DMI_trackConditionElement_T = {
      d_trackcond : D_TRACKCOND,
      m_trackcond : M_TRACKCOND
    };
  
  type
    DMI_trackConditionArray_T = DMI_trackConditionElement_T^cDMI_maxSpeedProfile;
  
  type
    DMI_trackCondition_T = {
      nIter : int,
      speedProfiles : DMI_SpeedProfileArray_T
    };
  
  type DMI_SR_Data_T = { valid : bool };
  
  type DMI_speedProfileElement_T = { d_static : D_STATIC, v_static : V_STATIC };
  
  type DMI_SpeedProfileArray_T = DMI_speedProfileElement_T^cDMI_maxSpeedProfile;
  
  type
    DMI_speedProfile_T = {
      nIter : int,
      speedProfiles : DMI_SpeedProfileArray_T
    };
  
  type DMI_mAxleLoad_T = { number : int, dig1 : BCD, dig2 : BCD, dig3 : BCD };
  
  type
    DMI_loadingGauge_T = { number : int, dig1 : BCD, dig2 : BCD, dig3 : BCD };
  
  type DMI_LevelList_T = { levelList : DMI_level_array_T };
  
  type DMI_level_T = { level : M_LEVEL, nid_stm : NID_STM };
  
  type DMI_level_array_T = DMI_level_T^cDMI_maxLevels;
  
  type
    DMI_gradientProfileElement_T = {
      d_gradient : D_GRADIENT,
      g_a : G_A,
      q_gdir : Q_GDIR
    };
  
  type
    DMI_gradientProfileArray_T = DMI_gradientProfileElement_T^cDMI_maxGradientProfile;
  
  type
    DMI_gradientProfile_T = {
      nIter : int,
      gradientProfiles : DMI_SpeedProfileArray_T
    };
  
  type
    DMI_brakeModel_id_T = { number : int, dig1 : BCD, dig2 : BCD, dig3 : BCD };
  
  type
    DMI_airtightSystem_T = { number : int, dig1 : BCD, dig2 : BCD, dig3 : BCD };
  
  type BCD = int;
  
  type
    DMI_StatusSet_T = enum {
      Running_state,
      Starting_state,
      Failure_state,
      Running_not_active_state,
      Train_Speed_Overflow,
      Invalid_track_condition,
      Invalid_predefined_text_message,
      Invalid_text_message,
      HW_warning_temp_reached,
      TFT_OFF_temp_reached,
      Device_OFF_temp_reached,
      Over_temperature,
      Backlight_on_off,
      FAN_blocked,
      Power_supply_key_switch_off,
      Watchdog_not_running
    };
  
  type
    DMI_Request_T = enum {
      Start_of_mission,
      Shunting_entry,
      Shunting_exit,
      Non_leading,
      Non_leading_exit,
      Maintain_shunting,
      Level_entry_request,
      Override_EOA,
      Override_route_unsuitability,
      Request_for_radio_network_entry,
      Request_for_train_data,
      Request_for_Adhesion_factor_data,
      Request_for_SR_data,
      Request_for_system_version,
      Request_for_switching_train_data_entry,
      Request_for_train_data_view,
      Request_to_show_geographical_position,
      Language_changed,
      Train_data_entry_aborted,
      Train_running_number_entry_aborted,
      SR_data_entry_aborted,
      Radio_network_entry_aborted,
      Request_to_hide_geographical_information,
      Request_to_show_supervision_data,
      Request_to_hide_supervision_data,
      Scroll_text_up,
      Scroll_text_down,
      Request_to_contact_last_known_RBC,
      Request_to_use_short_number,
      Request_isolation,
      Track_Ahead_Free_is_validated,
      The_Train_Integrity_request,
      Set_VBC_request,
      Remove_VBC_request,
      Show_tunnel_stopping_information,
      Hide_tunnel_stopping_information,
      NTC_data_entry_request,
      End_of_NTC_data_entry
    };
  
  type
    DMI_List_Entry_Request_T = enum {
      Enter_revalidate_driver_identifier,
      Enter_revalidate_train_running_number,
      Enter_revalidate_ETCS_level,
      Enter_RBC_contact_menu,
      Validate_train_data,
      Enter_NTC_data,
      Spare,
      Enable_the_track_ahead_free_by_the_driver,
      Disable_the_Track_Ahead_free_page,
      Show_main_window,
      Hide_main_window,
      Hide_adhesion_factor_entry_window,
      Hide_staff_responsible_entry_window,
      Show_Set_VBC_validation_window,
      Show_Remove_VBC_validation_window
    };
  
  type
    DMI_Available_Menu_T = {
      Menu_button_start_of_mission : bool,
      Menu_button_shunting : bool,
      Menu_button_shunting_exit : bool,
      Menu_button_non_leading : bool,
      Menu_button_exit_non_leading : bool,
      Menu_button_maintain_shunting : bool,
      Menu_button_driver_ID : bool,
      Menu_button_train_running_number : bool,
      Menu_button_ETCS_level : bool,
      Menu_button_train_data_modification : bool,
      Menu_button_train_data_view : bool,
      Menu_button_staff_responsible_data : bool,
      Menu_button_language_selection : bool,
      Menu_button_override_EOA : bool,
      Menu_button_override_route_suitability : bool,
      Menu_button_adhesion_factor : bool,
      Menu_button_system_version : bool,
      Menu_button_volume : bool,
      Menu_button_luminance : bool,
      Menu_button_train_integrity : bool,
      Menu_button_isolation : bool,
      Show_hourglass : bool,
      Menu_button_use_short_number : bool,
      Menu_button_enter_RBC_data : bool,
      Menu_button_radio_network_ID : bool,
      Menu_button_contact_last_RBC : bool,
      Button_switch_for_train_data : bool,
      Fix_train_data_entry : bool,
      Menu_button_Set_VBC : bool,
      Menu_button_Remove_VBC : bool
    };
  
  type M_BRAKEPERCT = int;
  
  type NID_DRIVER = int;
  
  type DMI_DMI_Identifier_T = enum { DMI_1, DMI_2 };
  
  type DMI_Cabin_Identifier_T = enum { cabin_A, cabin_B };
  
  type
    DMI_EVC_status_T = {
      DMI_Active : bool,
      DMI_Error : bool,
      DMI_DriverIdValidated : bool,
      DMI_TrainRunningNumberFirstValidation : bool,
      DMI_TrainRunningNumberValidated : bool,
      DMI_TrainDataValidated : bool,
      DMI_StartReceived : bool,
      DMI_Identifier : DMI_Messages_DMI_to_EVC_Pkg::DMI_Identifier_T
    };
  
  type
    DMI_Q_TEXT = enum {
      balise_read_error,
      communication_error,
      entering_FS,
      entering_OS,
      no_track_condition_will_be_received,
      runaway_movement,
      SH_refused,
      trackside_not_compatible,
      train_data_changed,
      train_is_rejected,
      unauthorized_passing_of_EOA_LOA,
      no_MA_received_at_level_transition,
      SR_distance_exceeded,
      SH_stop_order,
      SR_stop_order,
      emergency_stop,
      trackside_malfunction,
      SH_request_failed,
      RV_distance_esceeded,
      no_track_description,
      STM_brake_Deman,
      route_unsuitable_axle_load_category,
      route_unsuitable_loading_gauge,
      route_unsuitable_traction_system,
      radio_network_registration_failed,
      level_crossing_not_protected,
      acknowledgment
    };
  
  type DMI_TEXT = char^cDMI_charsInText;
  
  type
    Icon_group_T = enum {
      level_symbol,
      mode_symbols,
      status_symbols,
      order_an_announcements_symbols,
      planning_information_symbols,
      navigation_symbols,
      settings_symbols
    };
  
  type
    Icon_control_flag_T = enum {
      show_icon_in_area,
      clear_area,
      show_icon_flashing_in_area,
      show_icon_with_yellow_flashing_frame_in_area
    };
  
  type Area_group_T = enum { A, B, C, D, E, F, G, H };
  
  type
    M_SupervisionDisplay_T = enum {
      supDis_normal,
      supDis_indication,
      supDis_overspeed,
      supDis_warning,
      supDis_intervention
    };
  
  type
    speedSupervisionForDMI_T = {
      valid : bool,
      targetSpeed : Obu_BasicTypes_Pkg::V_internal_Type,
      permittedSpeed : Obu_BasicTypes_Pkg::V_internal_Type,
      releaseSpeed : Obu_BasicTypes_Pkg::V_internal_Type,
      locationBrakeTarget : Obu_BasicTypes_Pkg::L_internal_Type,
      location_brake_curve_starting_point : Obu_BasicTypes_Pkg::L_internal_Type,
      interventionSpeed : Obu_BasicTypes_Pkg::V_internal_Type,
      sup_status : M_SUPERVISION_STATUS,
      supervisionDisplay : M_SupervisionDisplay_T
    };
  
  type
    nationValuesForDMI_T = { valid : bool, nid_c : NID_C, nid_c_valid : bool };
  
  type
    movementAuthorityForDMI_T = {
      valid : bool,
      location_LOA : Obu_BasicTypes_Pkg::L_internal_Type,
      v_LOA : Obu_BasicTypes_Pkg::V_internal_Type
    };
  
  type
    morePositions_T = {
      valid : bool,
      location_KP_Balise_Track : Obu_BasicTypes_Pkg::L_internal_Type,
      distance_KP_Balise : Obu_BasicTypes_Pkg::L_internal_Type,
      distance_to_TSA : Obu_BasicTypes_Pkg::L_internal_Type
    };
  
  type
    DMI_To_Modes_T = {
      valid : bool,
      DriverAck : DMI_DriverAck_T,
      DriverRequest : DMI_DriverRequest_T,
      LevelAck : bool
    };
  
  type
    DMI_ModesToDMI_T = {
      valid : bool,
      whichMode : M_MODE,
      SH_Req_RefusedByRBC : bool,
      LevelNeedsAck : bool,
      newLevel : M_LEVEL,
      previousLevel : M_LEVEL
    };
  
  type
    DMI_DriverRequest_T = {
      valid : bool,
      Req_Exit_SH : bool,
      Req_NL : bool,
      Req_Override : bool,
      Req_SH : bool,
      Req_Start : bool,
      ETCS_Isolated : bool
    };
  
  type
    DMI_DriverAck_T = {
      valid : bool,
      whichMode : M_MODE,
      acknowledgement : bool
    };
  
end;

/* $*************** KCG Version 6.1.3 (build i6) ****************
** -
** Generation date: 2015-05-27T21:43:21
*************************************************************$ */
/* $*************** KCG Version 6.1.3 (build i6) ****************
** Command: x2s613 C:/Users/Baseliyos/Documents/GitHub_05_2015/model/Scade/System/APITypes/API_DMI_Pkg.xscade
** Generation date: 2015-05-27T21:43:21
*************************************************************$ */

/* xscade source: C:/Users/Baseliyos/Documents/GitHub_05_2015/model/Scade/System/APITypes/API_DMI_Pkg.xscade */
package API_DMI_Pkg
  type
    DMI_to_EVC_Message_T = {
      present : bool,
      status : DMI_Messages_DMI_to_EVC_Pkg::DMI_Status_T,
      identifier : DMI_Messages_DMI_to_EVC_Pkg::DMI_Identifier_T,
      driverRequest : DMI_Messages_DMI_to_EVC_Pkg::DMI_Driver_Request_T,
      driverIdentifier : DMI_Messages_Bothways_Pkg::DMI_Driver_Identifier_T,
      trainRunningNumber : DMI_Messages_Bothways_Pkg::DMI_Train_Running_Number_T,
      radioNetData : DMI_Messages_DMI_to_EVC_Pkg::DMI_Radio_Net_Data_T,
      textMessageAck : DMI_Messages_DMI_to_EVC_Pkg::DMI_Text_Message_Ack_T,
      trainDataAck : DMI_Messages_DMI_to_EVC_Pkg::DMI_Train_Data_Ack_T,
      trainData : DMI_Messages_Bothways_Pkg::DMI_Train_Data_T,
      adhesionFactor : DMI_Messages_Bothways_Pkg::DMI_Adhesion_Factor_Data_T,
      iconAck : DMI_Messages_DMI_to_EVC_Pkg::DMI_Icon_Ack_T
    };
  
  type
    EVC_to_DMI_Message_T = {
      present : bool,
      dynamic : DMI_Messages_EVC_to_DMI_Pkg::DMI_Dynamic_T,
      menu_request : DMI_Messages_EVC_to_DMI_Pkg::DMI_Menu_Request_T,
      entry_request : DMI_Messages_EVC_to_DMI_Pkg::DMI_Entry_Request_T,
      evc_coded_train_data : DMI_Messages_EVC_to_DMI_Pkg::DMI_EVC_Coded_Train_Data_T,
      textMessage : DMI_Messages_EVC_to_DMI_Pkg::DMI_Text_Message_T,
      trackDescription : DMI_Messages_EVC_to_DMI_Pkg::DMI_Track_Description_T,
      identifierRequest : DMI_Messages_EVC_to_DMI_Pkg::DMI_Identifier_Request_T,
      systemVersion : DMI_Messages_EVC_to_DMI_Pkg::DMI_System_Version_T,
      displayControl : DMI_Messages_EVC_to_DMI_Pkg::DMI_Display_Control_T,
      EVC_levelData : DMI_Messages_EVC_to_DMI_Pkg::DMI_EVC_Level_Data_T,
      EVC_radioNetData : DMI_Messages_EVC_to_DMI_Pkg::DMI_EVC_Radio_Net_Data_T,
      driverIdentifier : DMI_Messages_Bothways_Pkg::DMI_Driver_Identifier_T,
      trainRunningNumber : DMI_Messages_Bothways_Pkg::DMI_Train_Running_Number_T,
      trainData : DMI_Messages_Bothways_Pkg::DMI_Train_Data_T,
      adhesionFactor : DMI_Messages_Bothways_Pkg::DMI_Adhesion_Factor_Data_T,
      iconRequest : DMI_Messages_EVC_to_DMI_Pkg::DMI_Icons_T
    };
  
end;

/* $*************** KCG Version 6.1.3 (build i6) ****************
** -
** Generation date: 2015-05-27T21:43:21
*************************************************************$ */
/* $*************** KCG Version 6.1.3 (build i6) ****************
** Command: x2s613 C:/Users/Baseliyos/Documents/GitHub_05_2015/model/Scade/System/ObuFunctions/ManageLocationRelatedInformation/BaliseGroup/BG_Types/BG_Types_Pkg.xscade
** Generation date: 2015-05-27T21:43:21
*************************************************************$ */

/* xscade source: C:/Users/Baseliyos/Documents/GitHub_05_2015/model/Scade/System/ObuFunctions/ManageLocationRelatedInformation/BaliseGroup/BG_Types/BG_Types_Pkg.xscade */
package BG_Types_Pkg
  const cMaxNoOfLinkedBGs : int = 4;
  
  const cNID_LRBG_unknown : NID_LRBG = 16777215;
  
  const cNID_LRBG_14Bits_Multiplicator : int = 16384;
  
  const cNID_BG_unknown : NID_BG = 16383;
  
  const cMaxNoBalises : int = 8;
  
  const cMaxListBGs : int = 20;
  
  const
    cMaxDistanceBalisesInGroup : Obu_BasicTypes_Pkg::OdometryLocations_T
      = { o_nominal:1200, o_min:1200, o_max:1200 };
  
  const cInvalidIndex : int = -1;
  
  const cInitOrientation : Q_DIRTRAIN = Q_DIRTRAIN_Unknown;
  
  const
    cemptyPosition : centerOfBalisePosition_T
      = {
          odometerOfBaliseDetection:{
              valid:false,
              timestamp:0,
              odo:{ o_nominal:0, o_min:0, o_max:0 },
              speed:{ v_safeNominal:0, v_rawNominal:0, v_lower:0, v_upper:0 },
              acceleration:0,
              motionState:Obu_BasicTypes_Pkg::noMotion,
              motionDirection:Obu_BasicTypes_Pkg::unknownDirection },
          BG_centerDetectionInaccuraccuracies:{ nominal:0, d_min:0, d_max:0 } };
  
  const
    cEmptyHeader : TelegramHeader_T
      = {
          q_updown:Q_UPDOWN_Down_link_telegram,
          m_version:M_VERSION_Previous_versions_according_to_e_g_EEIG_SRS_and_UIC_A200_SRS,
          q_media:Q_MEDIA_Balise,
          n_pig:N_PIG_I_am_the_1st,
          n_total:N_TOTAL_1_balise_in_the_group,
          m_dup:M_DUP_No_duplicates,
          m_mcount:0,
          nid_c:0,
          nid_bg:0,
          q_link:Q_LINK_Unlinked };
  
  const cMaxNoOfLevelTransitionOrders : int = 4;
  
  const
    cEmptyPassedBG : passedBG_T
      = {
          valid:false,
          BG_Header:{
              valid:false,
              q_updown:Q_UPDOWN_Down_link_telegram,
              m_version:M_VERSION_Previous_versions_according_to_e_g_EEIG_SRS_and_UIC_A200_SRS,
              q_media:Q_MEDIA_Balise,
              n_total:N_TOTAL_1_balise_in_the_group,
              m_mcount:0,
              nid_c:0,
              nid_bg:0,
              q_link:Q_LINK_Unlinked,
              bgPosition:{
                  valid:false,
                  timestamp:0,
                  odo:{ o_nominal:0, o_min:0, o_max:0 },
                  speed:{
                      v_safeNominal:0,
                      v_rawNominal:0,
                      v_lower:0,
                      v_upper:0 },
                  acceleration:0,
                  motionState:Obu_BasicTypes_Pkg::noMotion,
                  motionDirection:Obu_BasicTypes_Pkg::unknownDirection },
              BG_centerDetectionInaccuraccuracies:{
                  nominal:0,
                  d_min:0,
                  d_max:0 },
              q_nvlocacc:0,
              noCoordinateSystemHasBeenAssigned:false,
              trainOrientationToBG:Q_DIRLRBG_Reverse,
              trainRunningDirectionToBG:Q_DIRTRAIN_Reverse },
          linkedBGs:[{
                valid:false,
                nid_LRBG:0,
                q_dir:Q_DIR_Reverse,
                q_scale:Q_SCALE_10_cm_scale,
                d_link:0,
                q_newcountry:Q_NEWCOUNTRY_Same_country__or__railway_administration_no_NID_C_follows,
                nid_c:0,
                nid_bg:0,
                q_linkorientation:Q_LINKORIENTATION_The_balise_group_is_seen_by_the_train_in_reverse_direction,
                q_linkreaction:Q_LINKREACTION_Train_trip,
                q_locacc:0 }, {
                valid:false,
                nid_LRBG:0,
                q_dir:Q_DIR_Reverse,
                q_scale:Q_SCALE_10_cm_scale,
                d_link:0,
                q_newcountry:Q_NEWCOUNTRY_Same_country__or__railway_administration_no_NID_C_follows,
                nid_c:0,
                nid_bg:0,
                q_linkorientation:Q_LINKORIENTATION_The_balise_group_is_seen_by_the_train_in_reverse_direction,
                q_linkreaction:Q_LINKREACTION_Train_trip,
                q_locacc:0 }, {
                valid:false,
                nid_LRBG:0,
                q_dir:Q_DIR_Reverse,
                q_scale:Q_SCALE_10_cm_scale,
                d_link:0,
                q_newcountry:Q_NEWCOUNTRY_Same_country__or__railway_administration_no_NID_C_follows,
                nid_c:0,
                nid_bg:0,
                q_linkorientation:Q_LINKORIENTATION_The_balise_group_is_seen_by_the_train_in_reverse_direction,
                q_linkreaction:Q_LINKREACTION_Train_trip,
                q_locacc:0 }, {
                valid:false,
                nid_LRBG:0,
                q_dir:Q_DIR_Reverse,
                q_scale:Q_SCALE_10_cm_scale,
                d_link:0,
                q_newcountry:Q_NEWCOUNTRY_Same_country__or__railway_administration_no_NID_C_follows,
                nid_c:0,
                nid_bg:0,
                q_linkorientation:Q_LINKORIENTATION_The_balise_group_is_seen_by_the_train_in_reverse_direction,
                q_linkreaction:Q_LINKREACTION_Train_trip,
                q_locacc:0 }] };
  
  const
    cEmpty_BaliseTlg : Telegram_T
      = {
          valid:false,
          checkResult:false,
          telegramheader:{
              q_updown:Q_UPDOWN_Down_link_telegram,
              m_version:M_VERSION_Previous_versions_according_to_e_g_EEIG_SRS_and_UIC_A200_SRS,
              q_media:Q_MEDIA_Balise,
              n_pig:N_PIG_I_am_the_1st,
              n_total:N_TOTAL_1_balise_in_the_group,
              m_dup:M_DUP_No_duplicates,
              m_mcount:0,
              nid_c:0,
              nid_bg:0,
              q_link:Q_LINK_Unlinked },
          packets:{
              PacketHeaders:[{
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }],
              PacketData:[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] } };
  
  const
    cEmptyLinking : LinkedBG_T
      = {
          valid:false,
          nid_LRBG:0,
          q_dir:Q_DIR_Reverse,
          q_scale:Q_SCALE_10_cm_scale,
          d_link:0,
          q_newcountry:Q_NEWCOUNTRY_Same_country__or__railway_administration_no_NID_C_follows,
          nid_c:0,
          nid_bg:0,
          q_linkorientation:Q_LINKORIENTATION_The_balise_group_is_seen_by_the_train_in_reverse_direction,
          q_linkreaction:Q_LINKREACTION_Train_trip,
          q_locacc:0 };
  
  const
    cEmptyLinkings : LinkedBGs_T
      = [{
            valid:false,
            nid_LRBG:0,
            q_dir:Q_DIR_Reverse,
            q_scale:Q_SCALE_10_cm_scale,
            d_link:0,
            q_newcountry:Q_NEWCOUNTRY_Same_country__or__railway_administration_no_NID_C_follows,
            nid_c:0,
            nid_bg:0,
            q_linkorientation:Q_LINKORIENTATION_The_balise_group_is_seen_by_the_train_in_reverse_direction,
            q_linkreaction:Q_LINKREACTION_Train_trip,
            q_locacc:0 }, {
            valid:false,
            nid_LRBG:0,
            q_dir:Q_DIR_Reverse,
            q_scale:Q_SCALE_10_cm_scale,
            d_link:0,
            q_newcountry:Q_NEWCOUNTRY_Same_country__or__railway_administration_no_NID_C_follows,
            nid_c:0,
            nid_bg:0,
            q_linkorientation:Q_LINKORIENTATION_The_balise_group_is_seen_by_the_train_in_reverse_direction,
            q_linkreaction:Q_LINKREACTION_Train_trip,
            q_locacc:0 }, {
            valid:false,
            nid_LRBG:0,
            q_dir:Q_DIR_Reverse,
            q_scale:Q_SCALE_10_cm_scale,
            d_link:0,
            q_newcountry:Q_NEWCOUNTRY_Same_country__or__railway_administration_no_NID_C_follows,
            nid_c:0,
            nid_bg:0,
            q_linkorientation:Q_LINKORIENTATION_The_balise_group_is_seen_by_the_train_in_reverse_direction,
            q_linkreaction:Q_LINKREACTION_Train_trip,
            q_locacc:0 }, {
            valid:false,
            nid_LRBG:0,
            q_dir:Q_DIR_Reverse,
            q_scale:Q_SCALE_10_cm_scale,
            d_link:0,
            q_newcountry:Q_NEWCOUNTRY_Same_country__or__railway_administration_no_NID_C_follows,
            nid_c:0,
            nid_bg:0,
            q_linkorientation:Q_LINKORIENTATION_The_balise_group_is_seen_by_the_train_in_reverse_direction,
            q_linkreaction:Q_LINKREACTION_Train_trip,
            q_locacc:0 }];
  
  const
    cEmptyBG_Header : BG_Header_T
      = {
          valid:false,
          q_updown:Q_UPDOWN_Down_link_telegram,
          m_version:M_VERSION_Previous_versions_according_to_e_g_EEIG_SRS_and_UIC_A200_SRS,
          q_media:Q_MEDIA_Balise,
          n_total:N_TOTAL_1_balise_in_the_group,
          m_mcount:0,
          nid_c:0,
          nid_bg:0,
          q_link:Q_LINK_Unlinked,
          bgPosition:{
              valid:false,
              timestamp:0,
              odo:{ o_nominal:0, o_min:0, o_max:0 },
              speed:{ v_safeNominal:0, v_rawNominal:0, v_lower:0, v_upper:0 },
              acceleration:0,
              motionState:Obu_BasicTypes_Pkg::noMotion,
              motionDirection:Obu_BasicTypes_Pkg::unknownDirection },
          BG_centerDetectionInaccuraccuracies:{ nominal:0, d_min:0, d_max:0 },
          q_nvlocacc:0,
          noCoordinateSystemHasBeenAssigned:false,
          trainOrientationToBG:Q_DIRLRBG_Reverse,
          trainRunningDirectionToBG:Q_DIRTRAIN_Reverse };
  
  type
    BG_Header_T = {
      valid : bool,
      q_updown : Q_UPDOWN,
      m_version : M_VERSION,
      q_media : Q_MEDIA,
      n_total : N_TOTAL,
      m_mcount : M_MCOUNT,
      nid_c : NID_C,
      nid_bg : NID_BG,
      q_link : Q_LINK,
      bgPosition : Obu_BasicTypes_Pkg::odometry_T,
      BG_centerDetectionInaccuraccuracies : Obu_BasicTypes_Pkg::LocWithInAcc_T,
      q_nvlocacc : Q_NVLOCACC,
      noCoordinateSystemHasBeenAssigned : bool,
      trainOrientationToBG : Q_DIRLRBG,
      trainRunningDirectionToBG : Q_DIRTRAIN
    };
  
  type
    LinkedBG_T = {
      valid : bool,
      nid_LRBG : NID_LRBG,
      q_dir : Q_DIR,
      q_scale : Q_SCALE,
      d_link : D_LINK,
      q_newcountry : Q_NEWCOUNTRY,
      nid_c : NID_C,
      nid_bg : NID_BG,
      q_linkorientation : Q_LINKORIENTATION,
      q_linkreaction : Q_LINKREACTION,
      q_locacc : Q_LOCACC
    };
  
  type LinkedBGs_T = LinkedBG_T^cMaxNoOfLinkedBGs;
  
  type
    passedBG_T = {
      valid : bool,
      BG_Header : BG_Header_T,
      linkedBGs : LinkedBGs_T
    };
  
  type
    TelegramHeader_T = {
      q_updown : Q_UPDOWN,
      m_version : M_VERSION,
      q_media : Q_MEDIA,
      n_pig : N_PIG,
      n_total : N_TOTAL,
      m_dup : M_DUP,
      m_mcount : M_MCOUNT,
      nid_c : NID_C,
      nid_bg : NID_BG,
      q_link : Q_LINK
    };
  
  type
    ModeAndLevelStatus_T = {
      m_mode : M_MODE,
      m_level : M_LEVEL,
      m_leveltr : M_LEVELTR
    };
  
  type TelegramArray_T = Telegram_T^cMaxNoBalises;
  
  type
    Telegram_T = {
      valid : bool,
      checkResult : bool,
      telegramheader : TelegramHeader_T,
      packets : Common_Types_Pkg::CompressedPackets_T
    };
  
  type
    RBCReport_T = {
      train_position_report : Radio_TrainToTrack::Train_Position_Report
    };
  
  type
    RBCOrientationReport_T = {
      assignment_of_coordinate_system : Radio_TrackToTrain::Assignment_of_coordinate_system
    };
  
  type
    BG_Message_T = {
      present : bool,
      Telegrams : TelegramArray_T,
      numberBalises : int,
      centerOfBalisePosition : centerOfBalisePosition_T
    };
  
  type
    centerOfBalisePosition_T = {
      odometerOfBaliseDetection : Obu_BasicTypes_Pkg::odometry_T,
      BG_centerDetectionInaccuraccuracies : Obu_BasicTypes_Pkg::LocWithInAcc_T
    };
  
  type
    BG_Orientation_T = enum {
      BG_Orientation_Reverse,
      BG_Orientation_Nominal,
      BG_Orientation_Unknown
    };
  
  type TrainToTrackStatus_T = { nid_ntc : NID_NTC, q_length : Q_LENGTH };
  
end;

/* $*************** KCG Version 6.1.3 (build i6) ****************
** -
** Generation date: 2015-05-27T21:43:21
*************************************************************$ */
/* $*************** KCG Version 6.1.3 (build i6) ****************
** Command: x2s613 C:/Users/Baseliyos/Documents/GitHub_05_2015/model/Scade/System/ObuFunctions/ManageLocationRelatedInformation/BaliseGroup/BG_Types/Packet_Types_Pkg.xscade
** Generation date: 2015-05-27T21:43:21
*************************************************************$ */

/* xscade source: C:/Users/Baseliyos/Documents/GitHub_05_2015/model/Scade/System/ObuFunctions/ManageLocationRelatedInformation/BaliseGroup/BG_Types/Packet_Types_Pkg.xscade */
package Packet_Types_Pkg
  const cNIterMax : int = 7;
  
  const cNIterMaxMA : int = 5;
  
  const cNIterMaxAxleloadSpeedProfile : int = 7;
  
  const cNIterMaxPermittedBrakingDistanceInformation : int = 3;
  
  const cNIterMaxTSR : int = 10;
  
  const cNIterMaxTrackConditions : int = 7;
  
  const cNIterMaxTrackConditionStationPlatform : int = 5;
  
  const cNIterMaxRouteSuitabilityData : int = 3;
  
  const cNIterMaxModeProfiles : int = 3;
  
  const cIterPacket58 : int = 2;
  
  type
    P88_LevelCrossingInformation_T = {
      valid : bool,
      q_dir : Q_DIR,
      q_scale : Q_SCALE,
      nid_lx : NID_LX,
      d_lx : D_LX,
      l_lx : L_LX,
      q_lxstatus : Q_LXSTATUS,
      v_lx : V_LX,
      q_stoplx : Q_STOPLX,
      l_stoplx : L_STOPLX
    };
  
  type
    P80_ModeProfile_T = {
      valid : bool,
      q_dir : Q_DIR,
      q_scale : Q_SCALE,
      d_mamode : D_MAMODE,
      m_mamode : M_MAMODE,
      v_mamode : V_MAMODE,
      l_mamode : L_MAMODE,
      l_ackmamode : L_ACKMAMODE,
      q_mamode : Q_MAMODE
    };
  
  type
    P79_GeographicalPositionInformation_T = {
      valid : bool,
      q_dir : Q_DIR,
      q_scale : Q_SCALE,
      q_newcountry : Q_NEWCOUNTRY,
      nid_c : NID_C,
      nid_bg : NID_BG,
      d_posoff : D_POSOFF,
      q_mposition : Q_MPOSITION,
      m_position : M_POSITION
    };
  
  type
    P76_PacketForSendingFixedTextMessages_T = {
      valid : bool,
      q_dir : Q_DIR,
      q_scale : Q_SCALE,
      q_textclass : Q_TEXTCLASS,
      q_textdisplay : Q_TEXTDISPLAY,
      d_textdisplay : D_TEXTDISPLAY,
      m_modetextdisplay_start : M_MODETEXTDISPLAY,
      m_leveltextdisplay_start : M_LEVELTEXTDISPLAY,
      nid_ntc_start : NID_NTC,
      l_textdisplay : L_TEXTDISPLAY,
      t_textdisplay : T_TEXTDISPLAY,
      m_modetextdisplay_end : M_MODETEXTDISPLAY,
      m_leveltextdisplay_end : M_LEVELTEXTDISPLAY,
      nid_ntc_end : NID_NTC,
      q_textconfirm : Q_TEXTCONFIRM,
      q_conftextdisplay : Q_CONFTEXTDISPLAY,
      q_textreport : Q_TEXTREPORT,
      nid_textmessage : NID_TEXTMESSAGE,
      nid_c : NID_C,
      nid_rbc : NID_RBC,
      q_text : Q_TEXT
    };
  
  type
    P72_PacketForSendingPlainTextMessages_T = {
      valid : bool,
      q_dir : Q_DIR,
      q_scale : Q_SCALE,
      q_textclass : Q_TEXTCLASS,
      q_textdisplay : Q_TEXTDISPLAY,
      d_textdisplay : D_TEXTDISPLAY,
      m_modetextdisplay_start : M_MODETEXTDISPLAY,
      m_leveltextdisplay_start : M_LEVELTEXTDISPLAY,
      nid_ntc_start : NID_NTC,
      l_textdisplay : L_TEXTDISPLAY,
      t_textdisplay : T_TEXTDISPLAY,
      m_modetextdisplay_end : M_MODETEXTDISPLAY,
      m_leveltextdisplay_end : M_LEVELTEXTDISPLAY,
      nid_ntc_end : NID_NTC,
      q_textconfirm : Q_TEXTCONFIRM,
      q_conftextdisplay : Q_CONFTEXTDISPLAY,
      q_textreport : Q_TEXTREPORT,
      nid_textmessage : NID_TEXTMESSAGE,
      nid_c : NID_C,
      nid_rbc : NID_RBC,
      l_text : L_TEXT,
      x_text : xTextArray_T
    };
  
  type
    P71_AdhesionFactor_T = {
      valid : bool,
      q_dir : Q_DIR,
      q_scale : Q_SCALE,
      d_adhesion : D_ADHESION,
      l_adhesion : L_ADHESION,
      m_adhesion : M_ADHESION
    };
  
  type
    P70_RouteSuitabilityData_T = {
      valid : bool,
      q_dir : Q_DIR,
      q_scale : Q_SCALE,
      q_trackinit : Q_TRACKINIT,
      d_trackinit : D_TRACKINIT,
      d_suitability : D_SUITABILITY,
      q_suitability : Q_SUITABILITY,
      m_linegauge : M_LINEGAUGE,
      m_axleloadcat : M_AXLELOADCAT,
      m_voltage : M_VOLTAGE,
      nid_ctraction : NID_CTRACTION
    };
  
  type
    P69_TrackConditionStationPlatform_T = {
      valid : bool,
      q_dir : Q_DIR,
      q_scale : Q_SCALE,
      q_trackinit : Q_TRACKINIT,
      d_trackinit : D_TRACKINIT,
      d_trackcond : D_TRACKCOND,
      l_trackcond : L_TRACKCOND,
      m_platform : M_PLATFORM,
      q_platform : Q_PLATFORM
    };
  
  type
    P68_TrackCondition_T = {
      valid : bool,
      q_dir : Q_DIR,
      q_scale : Q_SCALE,
      q_trackinit : Q_TRACKINIT,
      d_trackinit : D_TRACKINIT,
      d_trackcond : D_TRACKCOND,
      l_trackcond : L_TRACKCOND,
      m_trackcond : M_TRACKCOND
    };
  
  type
    P66_TemporarySpeedRestrictionRevocation_T = {
      valid : bool,
      q_dir : Q_DIR,
      nid_tsr : NID_TSR
    };
  
  type
    P65_TemporarySpeedRestriction_T = {
      valid : bool,
      q_dir : Q_DIR,
      q_scale : Q_SCALE,
      nid_tsr : NID_TSR,
      d_tsr : D_TSR,
      l_tsr : L_TSR,
      q_front : Q_FRONT,
      v_tsr : V_TSR
    };
  
  type P64_InhibitionOfRevocableTSRsFromBalisesInL23_T = { q_dir : Q_DIR };
  
  type
    P57_MovementAuthorityRequestParameters_T = {
      valid : bool,
      q_dir : Q_DIR,
      t_mar : T_MAR,
      t_timeoutrqst : T_TIMEOUTRQST,
      t_cycrqst : T_CYCRQST
    };
  
  type
    P52_PermittedBrakingDistanceInformation_T = {
      valid : bool,
      q_dir : Q_DIR,
      q_scale : Q_SCALE,
      q_trackinit : Q_TRACKINIT,
      d_trackinit : D_TRACKINIT,
      d_pbd : D_PBD,
      q_gdir : Q_GDIR,
      g_pbdsr : G_PBDSR,
      q_pbdsr : Q_PBDSR,
      d_pbdsr : D_PBDSR,
      l_pbdsr : L_PBDSR
    };
  
  type
    P51_AxleLoadSpeedProfile_T = {
      valid : bool,
      q_dir : Q_DIR,
      q_scale : Q_SCALE,
      q_trackinit : Q_TRACKINIT,
      d_trackinit : D_TRACKINIT,
      d_axleload : D_AXLELOAD,
      l_axleload : L_AXLELOAD,
      q_front : Q_FRONT,
      axleloadArray : axleloadArray_T
    };
  
  type
    P49_ListOfBalisesForSHArea_T = {
      valid : bool,
      q_dir : Q_DIR,
      q_newcountry : Q_NEWCOUNTRY,
      nid_c : NID_C,
      nid_bg : NID_BG
    };
  
  type
    P46_ConditionalLevelTransitionOrder_T = {
      valid : bool,
      q_dir : Q_DIR,
      m_leveltr : M_LEVELTR,
      nid_ntc : NID_NTC
    };
  
  type
    P45_RadioNetworkRegistration_T = {
      valid : bool,
      q_dir : Q_DIR,
      nid_mn : NID_MN
    };
  
  type
    P44_DataUsedByApplicationsOutsideTheERTMSETCSSystem_T = {
      valid : bool,
      q_dir : Q_DIR,
      nid_xuser : NID_XUSER,
      nid_ntc : NID_NTC,
      Other_data_depending_on__NID_XUSER : int
    };
  
  type
    P42_SessionManagement_T = {
      valid : bool,
      q_dir : Q_DIR,
      q_rbc : Q_RBC,
      nid_c : NID_C,
      nid_rbc : NID_RBC,
      nid_radio : NID_RADIO,
      q_sleepsession : Q_SLEEPSESSION
    };
  
  type
    P41_LevelTransitionOrder_T = {
      valid : bool,
      q_dir : Q_DIR,
      q_scale : Q_SCALE,
      d_leveltr : D_LEVELTR,
      m_leveltr : M_LEVELTR,
      nid_ntc : NID_NTC,
      l_ackleveltr : L_ACKLEVELTR
    };
  
  type
    P40_TrackConditionChangeOfAllowedCurrentConsumption_T = {
      valid : bool,
      q_dir : Q_DIR,
      q_scale : Q_SCALE,
      d_current : D_CURRENT,
      m_current : M_CURRENT
    };
  
  type
    P3_NationalValues_T = {
      valid : bool,
      q_dir : Q_DIR,
      d_validnv : D_VALIDNV,
      nid_cArray : nidCArray_T,
      v_nvshunt : V_NVSHUNT,
      v_nvstff : V_NVSTFF,
      v_nvonsight : V_NVONSIGHT,
      v_nvlimsuperv : V_NVLIMSUPERV,
      v_nvunfit : V_NVUNFIT,
      v_nvrel : V_NVREL,
      d_nvroll : D_NVROLL,
      q_nvsbtsmperm : Q_NVSBTSMPERM,
      q_nvemrrls : Q_NVEMRRLS,
      q_nvguiperm : Q_NVGUIPERM,
      q_nvsbfbperm : Q_NVSBFBPERM,
      q_nvinhsmicperm : Q_NVINHSMICPERM,
      v_nvallowovtrp : V_NVALLOWOVTRP,
      v_nvsupovtrp : V_NVSUPOVTRP,
      d_nvovtrp : D_NVOVTRP,
      t_nvovtrp : T_NVOVTRP,
      d_nvpotrp : D_NVPOTRP,
      m_nvcontact : M_NVCONTACT,
      t_nvcontact : T_NVCONTACT,
      m_nvderun : M_NVDERUN,
      d_nvstff : D_NVSTFF,
      q_nvdriver_adhes : Q_NVDRIVER_ADHES,
      a_nvmaxredadh1 : A_NVMAXREDADH1,
      a_nvmaxredadh2 : A_NVMAXREDADH2,
      a_nvmaxredadh3 : A_NVMAXREDADH3,
      q_nvlocacc : Q_NVLOCACC,
      m_nvavadh : M_NVAVADH,
      m_nvebcl : M_NVEBCL,
      q_nvkint : Q_NVKINT,
      nvkvintsetArray : nvkvintsetArray_T,
      nvkrintArray : nvkrintArray_T,
      m_nvktint : M_NVKTINT
    };
  
  type
    P39_TrackConditionChangeOfTractionSystem_T = {
      valid : bool,
      q_dir : Q_DIR,
      q_scale : Q_SCALE,
      d_traction : D_TRACTION,
      m_voltage : M_VOLTAGE,
      nid_ctraction : NID_CTRACTION
    };
  
  type
    P27_InternationalStaticSpeedProfile_T = {
      valid : bool,
      q_dir : Q_DIR,
      q_scale : Q_SCALE,
      d_static : D_STATIC,
      v_static : V_STATIC,
      q_front : Q_FRONT,
      diffArray : DiffArray_T,
      SSPArray : SSPArray_T
    };
  
  type P255_EndOfInformation_T = { valid : bool, nid_packet : NID_PACKET };
  
  type
    P21_GradientProfile_T = {
      valid : bool,
      q_dir : Q_DIR,
      q_scale : Q_SCALE,
      d_gradient : D_GRADIENT,
      q_gdir : Q_GDIR,
      g_a : G_A
    };
  
  type
    P140_TrainRunningNumberFromRBC_T = {
      valid : bool,
      q_dir : Q_DIR,
      nid_operational : NID_OPERATIONAL
    };
  
  type
    P139_ReversingSupervisionInformation_T = {
      valid : bool,
      q_dir : Q_DIR,
      q_scale : Q_SCALE,
      d_reverse : D_REVERSE,
      v_reverse : V_REVERSE
    };
  
  type
    P138_ReversingAreaInformation_T = {
      valid : bool,
      q_dir : Q_DIR,
      q_scale : Q_SCALE,
      d_startreverse : D_STARTREVERSE,
      l_reversearea : L_REVERSEAREA
    };
  
  type
    P137_StopIfInStaffResponsible_T = {
      valid : bool,
      q_dir : Q_DIR,
      q_srstop : Q_SRSTOP
    };
  
  type
    P131_RBCTransitionOrder_T = {
      valid : bool,
      q_dir : Q_DIR,
      q_scale : Q_SCALE,
      d_rbctr : D_RBCTR,
      nid_c : NID_C,
      nid_rbc : NID_RBC,
      nid_radio : NID_RADIO,
      q_sleepsession : Q_SLEEPSESSION
    };
  
  type P21_GradientProfiles_T = P21_GradientProfile_T^cNIterMax;
  
  type SSPArray_T = SSP_T^cNIterMax;
  
  type
    SSP_T = {
      valid : bool,
      d_static : D_STATIC,
      v_static : V_STATIC,
      q_front : Q_FRONT,
      diffArray : DiffArray_T
    };
  
  type DiffArray_T = Diff_T^cNIterMax;
  
  type
    Diff_T = {
      valid : bool,
      q_diff : Q_DIFF,
      nc_cddiff : NC_CDDIFF,
      nc_diff : NC_DIFF,
      v_diff : V_DIFF
    };
  
  type nidCArray_T = nidC_T^cNIterMax;
  
  type nidC_T = { valid : bool, nid_c : NID_C };
  
  type nvkvintsetArray_T = nvkvintset_T^cNIterMax;
  
  type
    nvkvintset_T = {
      valid : bool,
      q_nvkvintset : Q_NVKVINTSET,
      a_nvp12 : A_NVP12,
      a_nvp23 : A_NVP23,
      nvkintArray : nvkvintArray_T
    };
  
  type nvkrintArray_T = nvkrint_T^cNIterMax;
  
  type
    nvkrint_T = { valid : bool, l_nvkrint : L_NVKRINT, m_nvkrint : M_NVKRINT };
  
  type P41_LevelTransistionOrders_T = P41_LevelTransitionOrder_T^cNIterMax;
  
  type
    P46_ConditionalLevelTransitionOrders_T = P46_ConditionalLevelTransitionOrder_T^cNIterMax;
  
  type P49_ListOfBalisesForSHAreas_T = P49_ListOfBalisesForSHArea_T^cNIterMax;
  
  type axleloadArray_T = axleload_T^3;
  
  type
    axleload_T = {
      valid : bool,
      m_axleloadcat : M_AXLELOADCAT,
      v_axleload : V_AXLELOAD
    };
  
  type
    P51_AxleLoadSpeedProfiles_T = P51_AxleLoadSpeedProfile_T^cNIterMaxAxleloadSpeedProfile;
  
  type
    P52_PermittedBrakingDistanceInformations_T = P52_PermittedBrakingDistanceInformation_T^cNIterMaxPermittedBrakingDistanceInformation;
  
  type P68_TrackConditions_T = P68_TrackCondition_T^cNIterMaxTrackConditions;
  
  type
    P69_TrackConditionStationPlatforms_T = P69_TrackConditionStationPlatform_T^cNIterMaxTrackConditionStationPlatform;
  
  type P70_RouteSuitabilityDatas_T = P70_RouteSuitabilityData_T^2;
  
  type
    P79_GeographicalPositionInformations_T = P79_GeographicalPositionInformation_T^cNIterMax;
  
  type P80_ModeProfiles_T = P80_ModeProfile_T^cNIterMaxModeProfiles;
  
  type nvkvintArray_T = nvkvint_T^cNIterMax;
  
  type
    nvkvint_T = {
      valid : bool,
      v_nvkvint : V_NVKVINT,
      m_nvkvint12 : M_NVKVINT,
      m_nvkvint23 : M_NVKVINT
    };
  
  type xTextArray_T = xText_T^255;
  
  type xText_T = { valid : bool, x_text : X_TEXT };
  
  type
    P15_Level23MovementAuthority_T = {
      valid : bool,
      q_dir : Q_DIR,
      q_scale : Q_SCALE,
      v_loa : V_LOA,
      t_loa : T_LOA,
      l_section : L_SECTION,
      q_sectiontimer_k : Q_SECTIONTIMER,
      t_sectiontimer_k : T_SECTIONTIMER,
      d_sectiontimerstoploc_k : D_SECTIONTIMERSTOPLOC,
      l_endsection : L_ENDSECTION,
      q_sectiontimer : Q_SECTIONTIMER,
      t_sectiontimer : T_SECTIONTIMER,
      d_sectiontimerstoploc : D_SECTIONTIMERSTOPLOC,
      q_endtimer : Q_ENDTIMER,
      t_endtimer : T_ENDTIMER,
      d_endtimerstartloc : D_ENDTIMERSTARTLOC,
      q_dangerpoint : Q_DANGERPOINT,
      d_dp : D_DP,
      v_releasedp : V_RELEASEDP,
      q_overlap : Q_OVERLAP,
      d_startol : D_STARTOL,
      t_ol : T_OL,
      d_ol : D_OL,
      v_releaseol : V_RELEASEOL
    };
  
  type
    P15_Level23MovementAuthorities_T = P15_Level23MovementAuthority_T^cNIterMaxMA;
  
  type
    P65_TemporarySpeedRestrictions_T = P65_TemporarySpeedRestriction_T^cNIterMaxTSR;
  
  type
    P58_PositionReportParameters_T = {
      valid : bool,
      nid_packet : NID_PACKET,
      q_dir : Q_DIR,
      l_packet : L_PACKET,
      q_scale : Q_SCALE,
      t_cycloc : T_CYCLOC,
      d_cycloc : D_CYCLOC,
      m_loc : M_LOC,
      n_iter : N_ITER,
      iterPacket58List : IterPacket58List_T
    };
  
  type IterPacket58List_T = IterPacket58_T^cIterPacket58;
  
  type IterPacket58_T = { d_loc : D_LOC, q_lgtloc : Q_LGTLOC };
  
  type
    P66_TemporarySpeedRestrictionRevocations_T = P66_TemporarySpeedRestrictionRevocation_T^cNIterMaxTSR;
  
end;

/* $*************** KCG Version 6.1.3 (build i6) ****************
** -
** Generation date: 2015-05-27T21:43:21
*************************************************************$ */
/* $*************** KCG Version 6.1.3 (build i6) ****************
** Command: x2s613 C:/Users/Baseliyos/Documents/GitHub_05_2015/model/Scade/System/ObuFunctions/ManageLocationRelatedInformation/BaliseGroup/BG_Types/Radio_Types_Pkg.xscade
** Generation date: 2015-05-27T21:43:21
*************************************************************$ */

/* xscade source: C:/Users/Baseliyos/Documents/GitHub_05_2015/model/Scade/System/ObuFunctions/ManageLocationRelatedInformation/BaliseGroup/BG_Types/Radio_Types_Pkg.xscade */
package Radio_Types_Pkg
  const
    cEmptyRadioMsg : RadioMessage_T
      = {
          present:false,
          consistencyError:false,
          header:{
              radioDevice:0,
              receivedSystemTime:0,
              nid_message:0,
              t_train:0.0,
              m_ack:M_ACK_No_acknowledgement_required,
              nid_lrbg:0,
              t_train_reference:0.0,
              nid_em:0,
              q_scale:Q_SCALE_10_cm_scale,
              d_sr:0,
              t_sh_rqst:0.0,
              d_ref:0,
              q_dir:Q_DIR_Reverse,
              d_emergencystop:0,
              m_version:M_VERSION_Previous_versions_according_to_e_g_EEIG_SRS_and_UIC_A200_SRS },
          radioMetadata:{
              t_train_reference:false,
              nid_em:false,
              q_scale:false,
              d_sr:false,
              t_sh_rqst:false,
              d_ref:false,
              q_dir:false,
              d_emergencystop:false,
              m_version:false },
          packets:{
              PacketHeaders:[{
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }],
              PacketData:[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] } };
  
  type
    Radio_TrackTrain_Header_T = {
      radioDevice : int,
      receivedSystemTime : Obu_BasicTypes_Pkg::T_internal_Type,
      nid_message : NID_MESSAGE,
      t_train : T_TRAIN,
      m_ack : M_ACK,
      nid_lrbg : NID_LRBG,
      t_train_reference : T_TRAIN,
      nid_em : NID_EM,
      q_scale : Q_SCALE,
      d_sr : D_SR,
      t_sh_rqst : T_TRAIN,
      d_ref : D_REF,
      q_dir : Q_DIR,
      d_emergencystop : D_EMERGENCYSTOP,
      m_version : M_VERSION
    };
  
  type
    sessionStatus_Type = enum {
      morc_st_inactive,
      morc_st_establishing,
      morc_st_maintaining,
      morc_st_terminating
    };
  
  type
    RadioMessage_T = {
      present : bool,
      consistencyError : bool,
      header : Radio_TrackTrain_Header_T,
      radioMetadata : Common_Types_Pkg::RadioMetadata_T,
      packets : Common_Types_Pkg::CompressedPackets_T
    };
  
  type
    Radio_TrainTrack_Header_T = {
      present : bool,
      nid_message : NID_MESSAGE,
      t_train : T_TRAIN,
      nid_engine : NID_ENGINE,
      xQ_MARQSTREASON : Q_MARQSTREASON,
      xT_TRAIN : T_TRAIN
    };
  
  type
    Radio_TrainTrack_Message_T = {
      present : bool,
      header : Radio_TrainTrack_Header_T,
      packets : Common_Types_Pkg::outPackets_T
    };
  
end;

/* $*************** KCG Version 6.1.3 (build i6) ****************
** -
** Generation date: 2015-05-27T21:43:21
*************************************************************$ */
/* $*************** KCG Version 6.1.3 (build i6) ****************
** Command: x2s613 C:/Users/Baseliyos/Documents/GitHub_05_2015/model/Scade/System/ObuFunctions/ManageLocationRelatedInformation/BaliseGroup/BG_Types/Common_Types_Pkg.xscade
** Generation date: 2015-05-27T21:43:21
*************************************************************$ */

/* xscade source: C:/Users/Baseliyos/Documents/GitHub_05_2015/model/Scade/System/ObuFunctions/ManageLocationRelatedInformation/BaliseGroup/BG_Types/Common_Types_Pkg.xscade */
package Common_Types_Pkg
  const
    cEmptyMetaData : Metadata_T
      = [{
            nid_packet:0,
            q_dir:Q_DIR_Reverse,
            valid:false,
            startAddress:0,
            endAddress:0 }, {
            nid_packet:0,
            q_dir:Q_DIR_Reverse,
            valid:false,
            startAddress:0,
            endAddress:0 }, {
            nid_packet:0,
            q_dir:Q_DIR_Reverse,
            valid:false,
            startAddress:0,
            endAddress:0 }, {
            nid_packet:0,
            q_dir:Q_DIR_Reverse,
            valid:false,
            startAddress:0,
            endAddress:0 }, {
            nid_packet:0,
            q_dir:Q_DIR_Reverse,
            valid:false,
            startAddress:0,
            endAddress:0 }, {
            nid_packet:0,
            q_dir:Q_DIR_Reverse,
            valid:false,
            startAddress:0,
            endAddress:0 }, {
            nid_packet:0,
            q_dir:Q_DIR_Reverse,
            valid:false,
            startAddress:0,
            endAddress:0 }, {
            nid_packet:0,
            q_dir:Q_DIR_Reverse,
            valid:false,
            startAddress:0,
            endAddress:0 }, {
            nid_packet:0,
            q_dir:Q_DIR_Reverse,
            valid:false,
            startAddress:0,
            endAddress:0 }, {
            nid_packet:0,
            q_dir:Q_DIR_Reverse,
            valid:false,
            startAddress:0,
            endAddress:0 }, {
            nid_packet:0,
            q_dir:Q_DIR_Reverse,
            valid:false,
            startAddress:0,
            endAddress:0 }, {
            nid_packet:0,
            q_dir:Q_DIR_Reverse,
            valid:false,
            startAddress:0,
            endAddress:0 }, {
            nid_packet:0,
            q_dir:Q_DIR_Reverse,
            valid:false,
            startAddress:0,
            endAddress:0 }, {
            nid_packet:0,
            q_dir:Q_DIR_Reverse,
            valid:false,
            startAddress:0,
            endAddress:0 }, {
            nid_packet:0,
            q_dir:Q_DIR_Reverse,
            valid:false,
            startAddress:0,
            endAddress:0 }, {
            nid_packet:0,
            q_dir:Q_DIR_Reverse,
            valid:false,
            startAddress:0,
            endAddress:0 }, {
            nid_packet:0,
            q_dir:Q_DIR_Reverse,
            valid:false,
            startAddress:0,
            endAddress:0 }, {
            nid_packet:0,
            q_dir:Q_DIR_Reverse,
            valid:false,
            startAddress:0,
            endAddress:0 }, {
            nid_packet:0,
            q_dir:Q_DIR_Reverse,
            valid:false,
            startAddress:0,
            endAddress:0 }, {
            nid_packet:0,
            q_dir:Q_DIR_Reverse,
            valid:false,
            startAddress:0,
            endAddress:0 }, {
            nid_packet:0,
            q_dir:Q_DIR_Reverse,
            valid:false,
            startAddress:0,
            endAddress:0 }, {
            nid_packet:0,
            q_dir:Q_DIR_Reverse,
            valid:false,
            startAddress:0,
            endAddress:0 }, {
            nid_packet:0,
            q_dir:Q_DIR_Reverse,
            valid:false,
            startAddress:0,
            endAddress:0 }, {
            nid_packet:0,
            q_dir:Q_DIR_Reverse,
            valid:false,
            startAddress:0,
            endAddress:0 }, {
            nid_packet:0,
            q_dir:Q_DIR_Reverse,
            valid:false,
            startAddress:0,
            endAddress:0 }, {
            nid_packet:0,
            q_dir:Q_DIR_Reverse,
            valid:false,
            startAddress:0,
            endAddress:0 }, {
            nid_packet:0,
            q_dir:Q_DIR_Reverse,
            valid:false,
            startAddress:0,
            endAddress:0 }, {
            nid_packet:0,
            q_dir:Q_DIR_Reverse,
            valid:false,
            startAddress:0,
            endAddress:0 }, {
            nid_packet:0,
            q_dir:Q_DIR_Reverse,
            valid:false,
            startAddress:0,
            endAddress:0 }, {
            nid_packet:0,
            q_dir:Q_DIR_Reverse,
            valid:false,
            startAddress:0,
            endAddress:0 }];
  
  const
    cEmptyPackets : CompressedPacketData_T
      = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  
  const cMetadataArraySize : int = cDIM_MaxRMessages;
  
  const
    cDefaultRM : ReceivedMessage_T
      = {
          valid:false,
          source:msrc_undefined,
          radioMetadata:{
              t_train_reference:false,
              nid_em:false,
              q_scale:false,
              d_sr:false,
              t_sh_rqst:false,
              d_ref:false,
              q_dir:false,
              d_emergencystop:false,
              m_version:false },
          BG_Common_Header:{
              valid:false,
              q_updown:Q_UPDOWN_Down_link_telegram,
              m_version:M_VERSION_Previous_versions_according_to_e_g_EEIG_SRS_and_UIC_A200_SRS,
              q_media:Q_MEDIA_Balise,
              n_total:N_TOTAL_1_balise_in_the_group,
              m_mcount:0,
              nid_c:0,
              nid_bg:0,
              q_link:Q_LINK_Unlinked,
              bgPosition:{
                  valid:false,
                  timestamp:0,
                  odo:{ o_nominal:0, o_min:0, o_max:0 },
                  speed:{
                      v_safeNominal:0,
                      v_rawNominal:0,
                      v_lower:0,
                      v_upper:0 },
                  acceleration:0,
                  motionState:Obu_BasicTypes_Pkg::noMotion,
                  motionDirection:Obu_BasicTypes_Pkg::unknownDirection },
              BG_centerDetectionInaccuraccuracies:{
                  nominal:0,
                  d_min:0,
                  d_max:0 },
              q_nvlocacc:0,
              noCoordinateSystemHasBeenAssigned:false,
              trainOrientationToBG:Q_DIRLRBG_Reverse,
              trainRunningDirectionToBG:Q_DIRTRAIN_Reverse },
          Radio_Common_Header:{
              radioDevice:0,
              receivedSystemTime:0,
              nid_message:0,
              t_train:0.0,
              m_ack:M_ACK_No_acknowledgement_required,
              nid_lrbg:0,
              t_train_reference:0.0,
              nid_em:0,
              q_scale:Q_SCALE_10_cm_scale,
              d_sr:0,
              t_sh_rqst:0.0,
              d_ref:0,
              q_dir:Q_DIR_Reverse,
              d_emergencystop:0,
              m_version:M_VERSION_Previous_versions_according_to_e_g_EEIG_SRS_and_UIC_A200_SRS },
          packets:{
              PacketHeaders:[{
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }, {
                    nid_packet:0,
                    q_dir:Q_DIR_Reverse,
                    valid:false,
                    startAddress:0,
                    endAddress:0 }],
              PacketData:[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] } };
  
  const cNidPacketInvalid : NID_PACKET = -1;
  
  const cDIM_MaxDataElementsInRMessage : int = 500;
  
  const cDIM_MaxRMessages : int = 30;
  
  const
    cNoErrors : MSG_Errors_T
      = {
          linkedBGError:false,
          unlinkedBGError:false,
          BG_versionIncompatible:false,
          radioSequenceError:false,
          tNvContactError:false,
          otherTimingError:false,
          radioMessageConsistencyError:false };
  
  const
    cemptyMT : MetadataElement_T
      = {
          nid_packet:0,
          q_dir:Q_DIR_Reverse,
          valid:false,
          startAddress:0,
          endAddress:0 };
  
  type
    ReceivedMessage_T = {
      valid : bool,
      source : MsgSource_T,
      radioMetadata : RadioMetadata_T,
      BG_Common_Header : BG_Types_Pkg::BG_Header_T,
      Radio_Common_Header : Radio_Types_Pkg::Radio_TrackTrain_Header_T,
      packets : CompressedPackets_T
    };
  
  type
    MsgSource_T = enum {
      msrc_undefined,
      msrc_Euroradio,
      msrc_Eurobalise,
      msrc_RadioInfillUnit,
      msrc_OBU
    };
  
  type Metadata_T = MetadataElement_T^cMetadataArraySize;
  
  type
    MetadataElement_T = {
      nid_packet : NID_PACKET,
      q_dir : Q_DIR,
      valid : bool,
      startAddress : int,
      endAddress : int
    };
  
  type CompressedPacketData_T = int^cDIM_MaxDataElementsInRMessage;
  
  type
    RadioMetadata_T = {
      t_train_reference : bool,
      nid_em : bool,
      q_scale : bool,
      d_sr : bool,
      t_sh_rqst : bool,
      d_ref : bool,
      q_dir : bool,
      d_emergencystop : bool,
      m_version : bool
    };
  
  type
    TrackSide_ForCheck_T = {
      valid : bool,
      systemTime : Obu_BasicTypes_Pkg::T_internal_Type,
      msg_type : MsgSource_T,
      telegramHeaders : BG_Types_Pkg::BG_Message_T,
      radio_Msg : Radio_Types_Pkg::RadioMessage_T
    };
  
  type
    outPackets_T = {
      p0 : Packet_TrainTypes_Pkg::PT0_PositionReport_T,
      p1 : Packet_TrainTypes_Pkg::PT1_PositionReport_2BG_T,
      p3 : Packet_TrainTypes_Pkg::PT3_OnboardTelephoneNumbers_T,
      p4 : Packet_TrainTypes_Pkg::PT4_ErrorReporting_T,
      p5 : Packet_TrainTypes_Pkg::PT5_TrainRunningNumber,
      p11 : Packet_TrainTypes_Pkg::PT11_ValidatedTrainData_T
    };
  
  type
    radioManagementMessage_T = {
      valid : bool,
      messageSource : MsgSource_T,
      Radio_Common_Header : Radio_Types_Pkg::Radio_TrackTrain_Header_T,
      p42 : Packet_Types_Pkg::P42_SessionManagement_T,
      p45 : Packet_Types_Pkg::P45_RadioNetworkRegistration_T
    };
  
  type
    PositionReportParameter_T = {
      present : bool,
      nidBG : NID_BG,
      bgLocation : Obu_BasicTypes_Pkg::Location_T,
      packet58 : Packet_Types_Pkg::P58_PositionReportParameters_T
    };
  
  type
    CompressedPackets_T = {
      PacketHeaders : Metadata_T,
      PacketData : CompressedPacketData_T
    };
  
  type CompressedHeaders_T = int^cDIM_MaxRMessages;
  
  type
    TrackSide_Errors_T = {
      applyServiceBrake : bool,
      badBaliseMessageToDMI : bool,
      errorLinkedBG : bool,
      errorUnlinkedBG : bool,
      radioSequenceError : bool,
      radioMessageConsistencyError : bool
    };
  
  type
    MSG_Errors_T = {
      linkedBGError : bool,
      unlinkedBGError : bool,
      BG_versionIncompatible : bool,
      radioSequenceError : bool,
      tNvContactError : bool,
      otherTimingError : bool,
      radioMessageConsistencyError : bool
    };
  
end;

/* $*************** KCG Version 6.1.3 (build i6) ****************
** -
** Generation date: 2015-05-27T21:43:21
*************************************************************$ */
/* $*************** KCG Version 6.1.3 (build i6) ****************
** Command: x2s613 C:/Users/Baseliyos/Documents/GitHub_05_2015/model/Scade/System/ObuFunctions/ManageLocationRelatedInformation/BaliseGroup/BG_Types/Packet_Train_Types_Pkg.xscade
** Generation date: 2015-05-27T21:43:21
*************************************************************$ */

/* xscade source: C:/Users/Baseliyos/Documents/GitHub_05_2015/model/Scade/System/ObuFunctions/ManageLocationRelatedInformation/BaliseGroup/BG_Types/Packet_Train_Types_Pkg.xscade */
package Packet_TrainTypes_Pkg
  const cIterPacket58 : int = 2;
  
  const cDigitsInTelephoneNumber : int = 15;
  
  const cmaxNumberTelephoneNumbers : int = 1;
  
  const cMaxTractionIdentity : int = 3;
  
  const cMaxNationalSystem : int = 3;
  
  const cNoNTC : aNID_NTC_T = [0, 0, 0];
  
  const
    cNoTractionSystems : aTractionIdentity_T
      = [{
            m_voltage:M_VOLTAGE_Line_not_fitted_with_any_traction_system,
            nid_ctraction:0 }, {
            m_voltage:M_VOLTAGE_Line_not_fitted_with_any_traction_system,
            nid_ctraction:0 }, {
            m_voltage:M_VOLTAGE_Line_not_fitted_with_any_traction_system,
            nid_ctraction:0 }];
  
  type
    PT5_TrainRunningNumber = {
      valid : bool,
      TrainRunningNumber : NID_OPERATIONAL
    };
  
  type PT4_ErrorReporting_T = { valid : bool, M_ERROR : M_ERROR };
  
  type
    PT1_PositionReport_2BG_T = {
      valid : bool,
      packet1 : TrainToTrack::Position_Report_based_on_two_balise_groups
    };
  
  type
    PT0_PositionReport_T = {
      valid : bool,
      packet0 : TrainToTrack::Position_Report
    };
  
  type
    PT3_OnboardTelephoneNumbers_T = {
      valid : bool,
      number : int,
      aNID_RADIO : aNID_RADIO_T
    };
  
  type telephoneNumber_T = Obu_BasicTypes_Pkg::BCD_T^cDigitsInTelephoneNumber;
  
  type aNID_RADIO_T = sNID_RADIO_T^cmaxNumberTelephoneNumbers;
  
  type
    PT11_ValidatedTrainData_T = {
      valid : bool,
      NC_CDTRAIN : NC_CDTRAIN,
      NC_TRAIN : NC_TRAIN,
      l_train : Obu_BasicTypes_Pkg::L_internal_Type,
      v_maxtrain : Obu_BasicTypes_Pkg::V_internal_Type,
      m_loadinggoage : M_LOADINGGAUGE,
      m_axleloadcat : M_AXLELOADCAT,
      m_airtight : M_AIRTIGHT,
      n_axle : N_AXLE,
      nIter_tractionIdentity : int,
      tractionIdentity : aTractionIdentity_T,
      nIter_ntc : int,
      nid_ntc : aNID_NTC_T
    };
  
  type
    sTractionIdentity_T = {
      m_voltage : M_VOLTAGE,
      nid_ctraction : NID_CTRACTION
    };
  
  type aTractionIdentity_T = sTractionIdentity_T^cMaxTractionIdentity;
  
  type aNID_NTC_T = NID_NTC^cMaxNationalSystem;
  
  type
    PT9_Level23_TransitionInformation_T = {
      valid : bool,
      transitionInformation : NID_LTRBG
    };
  
  type sNID_RADIO_T = { valid : bool, telephoneNumber : telephoneNumber_T };
  
end;

/* $*************** KCG Version 6.1.3 (build i6) ****************
** -
** Generation date: 2015-05-27T21:43:21
*************************************************************$ */
/* $*************** KCG Version 6.1.3 (build i6) ****************
** Command: x2s613 C:/Users/Baseliyos/Documents/GitHub_05_2015/model/Scade/System/ObuFunctions/ManageLocationRelatedInformation/BaliseGroup/BG_Types/Id_Pkg.xscade
** Generation date: 2015-05-27T21:43:21
*************************************************************$ */

/* xscade source: C:/Users/Baseliyos/Documents/GitHub_05_2015/model/Scade/System/ObuFunctions/ManageLocationRelatedInformation/BaliseGroup/BG_Types/Id_Pkg.xscade */
package Id_Pkg
  const cp003_NationalValues : NID_PACKET = 3;
  
  const cp005_linking : NID_PACKET = 5;
  
  const cm38_Initiation_of_a_Communication_Session : NID_MESSAGE = 38;
  
  const
    cm39_Acknowledgement_of_termination_of_a_communication_session : NID_MESSAGE
      = 39;
  
  const cm24_General_Message : NID_MESSAGE = 24;
  
  const cm03_Movement_Authority : NID_MESSAGE = 3;
  
  const cm08_Acknowledgement_of_Train_Data : NID_MESSAGE = 8;
  
  const cm09_Request_To_Shorten_MA : NID_MESSAGE = 9;
  
  const cm15_Conditional_Emergency_Stop : NID_MESSAGE = 15;
  
  const cm16_Unconditional_Emergency_Stop : NID_MESSAGE = 16;
  
  const cm18_Revocation_of_Emergency_Stop : NID_MESSAGE = 18;
  
  const cm33_MA_with_Shifted_Location_Reference : NID_MESSAGE = 33;
  
  const cm41_Train_Accepted : NID_MESSAGE = 41;
  
  const co129_Validated_Train_Data : NID_MESSAGE = 129;
  
  const co132_MA_Request : NID_MESSAGE = 132;
  
  const co136_Train_Position_Report : NID_MESSAGE = 136;
  
  const co147_Acknowledgement_of_Emergency_Stop : NID_MESSAGE = 147;
  
  const co150_End_of_Mission : NID_MESSAGE = 150;
  
  const co155_Initiation_of_a_communication_session : NID_MESSAGE = 155;
  
  const co146_Acknowledgement : NID_MESSAGE = 146;
  
  const co159_Session_established : NID_MESSAGE = 159;
  
  const co156_Termination_of_a_communication_session : NID_MESSAGE = 156;
  
  const cp042_Session_Management : NID_PACKET = 42;
  
  const cp058_Position_Report_Parameters : NID_PACKET = 58;
  
  const cp045_Radio_Network_registration : NID_PACKET = 45;
  
  const co154_No_Compatible_Version_Support : NID_MESSAGE = 154;
  
  const cm32_RBC_RIU_System_Version : NID_MESSAGE = 32;
  
end;

/* $*************** KCG Version 6.1.3 (build i6) ****************
** -
** Generation date: 2015-05-27T21:43:21
*************************************************************$ */
/* $*************** KCG Version 6.1.3 (build i6) ****************
** Command: x2s613 C:/Users/Baseliyos/Documents/GitHub_05_2015/model/Scade/System/ObuFunctions/ManageLocationRelatedInformation/TrainPosition/TrainPosition_Types/TrainPosition_Types_Pck.xscade
** Generation date: 2015-05-27T21:43:21
*************************************************************$ */

/* xscade source: C:/Users/Baseliyos/Documents/GitHub_05_2015/model/Scade/System/ObuFunctions/ManageLocationRelatedInformation/TrainPosition/TrainPosition_Types/TrainPosition_Types_Pck.xscade */
#pragma kcg doc "GdC_1" {Author = "Uwe Steinke", DateC = "Created : 2014-05-22", DateM = "Modified : 2014-06-03", Version = "00.03.00"} #end
#pragma kcg doc "Remark_1" {Description = "Description : Determines the index of BG in BGs - Copyright Siemens AG, 2014 - Licensed under the EUPL V.1.1 ( http://joinup.ec.europa.eu/software/page/eupl/licence-eupl ) - Gist URL: --- - Cryptography: No - Author(s): Uwe Steinke   The use of this software is limited to non-vital applications.  It has not been developed for vital operation purposes and must not be used for applications which may cause harm to people, physical accidents or financial loss.  THEREFORE, NO LIABILITY WILL BE GIVEN FOR SUCH AND ANY OTHER KIND OF USE.  "} #end
package TrainPosition_Types_Pck
  const cQLOCACC_resolution : Obu_BasicTypes_Pkg::Location_T = 100;
  
  const cQ_SCALE_10_cm_resolution : Obu_BasicTypes_Pkg::Location_T = 10;
  
  const cQ_SCALE_1_m_resolution : Obu_BasicTypes_Pkg::Location_T = 100;
  
  const cQ_SCALE_10_m_resolution : Obu_BasicTypes_Pkg::Location_T = 1000;
  
  const cMaxNoOfStoredBGs : int = 2 * BG_Types_Pkg::cMaxNoOfLinkedBGs;
  
  type
    trainProperties_T = {
      nid_engine : NID_ENGINE,
      nid_operational : NID_OPERATIONAL,
      l_train : L_TRAIN,
      d_baliseAntenna_2_frontend : Obu_BasicTypes_Pkg::LocWithInAcc_T,
      d_frontend_2_rearend : Obu_BasicTypes_Pkg::LocWithInAcc_T,
      locationAccuracy_DefaultValue : Obu_BasicTypes_Pkg::LocWithInAcc_T,
      centerDetectionAcc_DefaultValue : Obu_BasicTypes_Pkg::LocWithInAcc_T
    };
  
  type
    trainPosition_T = {
      valid : bool,
      timestamp : Obu_BasicTypes_Pkg::T_internal_Type,
      trainPositionIsUnknown : bool,
      noCoordinateSystemHasBeenAssigned : bool,
      trainPosition : Obu_BasicTypes_Pkg::LocWithInAcc_T,
      estimatedFrontEndPosition : Obu_BasicTypes_Pkg::Location_T,
      minSafeFrontEndPosition : Obu_BasicTypes_Pkg::Location_T,
      maxSafeFrontEndPostion : Obu_BasicTypes_Pkg::Location_T,
      LRBG : positionedBG_T,
      prvLRBG : positionedBG_T,
      nominalOrReverseToLRBG : Q_DLRBG,
      trainOrientationToLRBG : Q_DIRLRBG,
      trainRunningDirectionToLRBG : Q_DIRTRAIN,
      linkingIsUsedOnboard : bool
    };
  
  type
    positionedBG_T = {
      valid : bool,
      nid_c : NID_C,
      nid_bg : NID_BG,
      q_link : Q_LINK,
      location : Obu_BasicTypes_Pkg::LocWithInAcc_T,
      seqNoOnTrack : int,
      infoFromLinking : infoFromLinking_T,
      infoFromPassing : BG_Types_Pkg::passedBG_T
    };
  
  type
    infoFromLinking_T = {
      valid : bool,
      nid_bg_fromLinkingBG : NID_BG,
      nid_c_fromLinkingBG : NID_C,
      expectedLocation : Obu_BasicTypes_Pkg::LocWithInAcc_T,
      d_link : Obu_BasicTypes_Pkg::LocWithInAcc_T,
      linkingInfo : BG_Types_Pkg::LinkedBG_T
    };
  
  type
    linkedBGs_asPositionedBGs_T = positionedBG_T^BG_Types_Pkg::cMaxNoOfLinkedBGs;
  
  type positionedBGs_T = positionedBG_T^cMaxNoOfStoredBGs;
  
  type
    trainPositionInfo_T = {
      valid : bool,
      timestamp : Obu_BasicTypes_Pkg::T_internal_Type,
      trainPosition : Obu_BasicTypes_Pkg::LocWithInAcc_T,
      trainPositionDerivedFromLastLinkedBG : Obu_BasicTypes_Pkg::LocWithInAcc_T,
      trainPositionDerivedFromLastUnlinkedBG : Obu_BasicTypes_Pkg::LocWithInAcc_T,
      prevPassedLinkedBG : positionedBG_T,
      lastPassedLinkedBG : positionedBG_T,
      lastPassedUnlinkedBG : positionedBG_T,
      speed : Obu_BasicTypes_Pkg::Speed_T,
      linkingIsUsedOnboard : bool
    };
  
  type
    positionErrors_T = {
      outOfMemSpace : bool,
      passedBG_foundNotWhereExpected : bool,
      positionCalculation_inconsistent : bool,
      linkedBGMissed : bool,
      BGpassedInUnexpectedDirection : bool,
      BG_LinkingConsistencyError : bool,
      twoConsecutiveLinkedBGs_missed : bool,
      doubleRepositioningError : bool,
      bg : positionedBG_T
    };
  
end;

/* $*************** KCG Version 6.1.3 (build i6) ****************
** -
** Generation date: 2015-05-27T21:43:21
*************************************************************$ */
/* $*************** KCG Version 6.1.3 (build i6) ****************
** Command: x2s613 C:/Users/Baseliyos/Documents/GitHub_05_2015/model/Scade/System/ObuFunctions/Radio/MoRC/MoRC.xscade
** Generation date: 2015-05-27T21:43:21
*************************************************************$ */

/* xscade source: C:/Users/Baseliyos/Documents/GitHub_05_2015/model/Scade/System/ObuFunctions/Radio/MoRC/MoRC.xscade */

/* $*************** KCG Version 6.1.3 (build i6) ****************
** -
** Generation date: 2015-05-27T21:43:21
*************************************************************$ */
/* $*************** KCG Version 6.1.3 (build i6) ****************
** Command: x2s613 C:/Users/Baseliyos/Documents/GitHub_05_2015/model/Scade/System/ObuFunctions/Radio/MoRC/MoRC_Pck.xscade
** Generation date: 2015-05-27T21:43:21
*************************************************************$ */

/* xscade source: C:/Users/Baseliyos/Documents/GitHub_05_2015/model/Scade/System/ObuFunctions/Radio/MoRC/MoRC_Pck.xscade */
package MoRC_Pck
  package Utils
    node #pragma kcg doc The countDownTimer implements a generic timer function. #end
      #pragma kcg doc "GdC_1" {Author = "Author : Uwe Steinke", DateC = "Created : 2012-10-15", DateM = "Modified : 2012-12-20", Version = "Version : 00.00.00.001"} #end
      #pragma kcg doc "Remark_1" {Description = "- Name: countDownTimer - Description: Implements a generic Count Down Timer  - Copyright Siemens AG, 2013 - Licensed under the EUPL V.1.1 ( http://joinup.ec.europa.eu/software/page/eupl/licence-eupl ) - Gist URL: --- - Cryptography: No - Author(s): Uwe Steinke  The use of this software is limited to non-vital applications.  It has not been developed for vital operation purposes and must not be used for applications which may cause harm to people, physical accidents or financial loss.  THEREFORE, NO LIABILITY WILL BE GIVEN FOR SUCH AND ANY OTHER KIND OF USE. "} #end
      countDownTimer(
        re_start : bool;
        stop : bool;
        actualTime : time_Type;
        autoretrigger : bool;
        interval : time_Type)
      returns (expired : bool default = false; started : bool)
    sig
      sStart;
    var
      expired_loc : bool default = false;
      _L1 : bool;
    let
      
      automaton TimerStatus_SM
        initial state Stopped
          unless
            if stop restart Stopped;
            if re_start or autoretrigger
              do let emit 'sStart; tel restart Counting;
          var
            _L1 : bool;
          let
            expired= _L1;
            _L1= false;
          tel

        state Counting
          unless
            if stop restart Stopped;
          var
            _L1 : time_Type;
            _L4 : time_Type;
            _L5 : time_Type;
            _L6 : int;
            _L7 : bool;
            _L8 : bool;
          let
            _L1= actualTime;
            _L4= #1 linear::MemoryBasic(_L1, _L1, _L8);
            _L5= interval;
            _L6= _L1 - _L5;
            _L7= _L6 >= _L4;
            _L8= false;
            expired_loc= _L7;
            expired= _L7;
          tel
          until
            if re_start do let emit 'sStart; tel restart Counting;
            if expired_loc and autoretrigger
              do let emit 'sStart; tel restart Counting;
            if expired_loc do restart Expired;

        state Expired
          unless
            if stop restart Stopped;
          var
            _L1 : bool;
          let
            expired= _L1;
            _L1= true;
          tel
          until
            if re_start or autoretrigger
              do let emit 'sStart; tel restart Counting;
      returns ..;
      _L1= 'sStart;
      started= _L1;
    tel
    
    node #pragma kcg doc Implements a timer for a triggering an action a limited number of times in configured intervals. #end
      #pragma kcg 
									doc 
								 #end
      #pragma kcg doc Repeats triggerAction maxNoOfRepetition times in intervals of repeatInterval. #end
      #pragma kcg doc triggerAction is activated at the beginning of each interval. #end
      #pragma kcg doc elapsed is activated after the last interval. #end
      #pragma kcg doc "Remark_1" {Description = "- Name: waitAndRepeatTimer - Description: Implements a timer for a triggering an action a limited number of times in configured intervals - Copyright Siemens AG, 2013 - Licensed under the EUPL V.1.1 ( http://joinup.ec.europa.eu/software/page/eupl/licence-eupl ) - Gist URL: --- - Cryptography: No - Author(s): Uwe Steinke  The use of this software is limited to non-vital applications.  It has not been developed for vital operation purposes and must not be used for applications which may cause harm to people, physical accidents or financial loss.  THEREFORE, NO LIABILITY WILL BE GIVEN FOR SUCH AND ANY OHER KIND OF USE."} #end
      waitAndRepeatTimer(
        actualTime : time_Type;
        re_start : bool;
        stop : bool;
        repeatInterval : time_Type;
        maxNoOfRepetitions : int)
      returns (triggerAction : bool; elapsed : bool)
    var
      _L1 : bool;
      _L3 : time_Type;
      _L4 : bool;
      _L5 : time_Type;
      _L6 : int;
      _L7 : int;
      _L8 : int;
      _L9 : int;
      _L10 : bool;
      _L11 : int;
      _L14 : bool;
      _L15 : bool;
      _L21 : bool;
      _L22 : int;
      _L23 : int;
      _L24 : bool;
      _L25 : bool;
      _L27 : bool;
      _L28 : bool;
    let
      _L1, _L27= #1 countDownTimer(_L21, _L24, _L3, _L4, _L5);
      _L3= actualTime;
      _L4= true;
      _L5= repeatInterval;
      _L6= _L7 + _L9;
      _L7= 1;
      _L8= if _L1 then _L6 else _L9;
      _L9= fby(_L22; 1; 0);
      _L10= _L9 >= _L11;
      _L11= maxNoOfRepetitions;
      elapsed= _L10;
      _L14= not _L10;
      _L15= _L14 and _L1;
      triggerAction= _L25;
      _L21= re_start;
      _L22= if _L21 then _L23 else _L8;
      _L23= 0;
      _L24= stop;
      _L25= _L15 or _L28;
      _L28= _L14 and _L27;
    tel
    
  end;
  
  package Subfunc_Pkg
    node #pragma kcg doc Subset 096, REQ 3.5.7 #end
      #pragma kcg doc Controls the radio connection indication for the driver. #end
      #pragma kcg doc "Remark_1" {Description = "- Name: safeRadioConnectionIndication - Description: Controls the radio connection indication for the driver. - Copyright Siemens AG, 2013 - Licensed under the EUPL V.1.1 ( http://joinup.ec.europa.eu/software/page/eupl/licence-eupl ) - Gist URL: --- - Cryptography: No - Author(s): Uwe Steinke  The use of this software is limited to non-vital applications.  It has not been developed for vital operation purposes and must not be used for applications which may cause harm to people, physical accidents or financial loss.  THEREFORE, NO LIABILITY WILL BE GIVEN FOR SUCH AND ANY OHER KIND OF USE."} #end
      safeRadioConnectionIndication(
        startOfMissionProcedureIsGoingOn : bool;
        finalAttemptToSetupTheSafeRadioConnectionFailed : bool;
        requestsToSetupASafeRadioConnectionAreStopped_unsuccessfullReason
        : bool;
        requestsToSetupASafeRadioConnectionAreStopped : bool;
        safeRadioConnection_Setup : bool;
        safeRadioConnection_Released : bool;
        safeRadioConnection_Lost : bool;
        trainfrontIsInsideAnAnnouncedRadioHole : bool;
        actualTime : time_Type;
        firstRequestToSetupASafeRadioConnection_fromEstablishing : bool;
        firstRequestToSetupASafeRadioConnection_fromMaintaining : bool;
        connectionStatusTimerInterval : time_Type)
      returns (connectionStatus : safeRadioConnectionStatusValid_Type)
    var
      connectionStatus_loc : safeRadioConnectionStatus_Type;
      connectionStatusTimerExpired : bool;
      condition_ID_1 : bool;
      condition_ID_2 : bool;
      condition_ID_3 : bool;
      condition_ID_4 : bool;
      condition_ID_5 : bool;
      condition_ID_6 : bool;
      condition_ID_7 : bool;
      _L1 : safeRadioConnectionStatus_Type;
      _L3 : bool;
      _L4 : bool;
      _L5 : bool;
      _L6 : bool;
      _L7 : bool;
      _L8 : bool;
      _L9 : bool;
      _L10 : bool;
      _L11 : bool;
      _L12 : bool;
      _L13 : bool;
      _L14 : bool;
      _L15 : bool;
      _L16 : bool;
      _L17 : bool;
      _L18 : bool;
      _L19 : bool;
      _L22 : bool;
      _L21 : bool;
      _L23 : time_Type;
      _L24 : bool;
      _L27 : time_Type;
      _L28 : bool;
      _L29 : bool;
      _L30 : bool;
      _L31 : bool;
      _L40 : safeRadioConnectionStatusValid_Type;
    let
      connectionStatus= _L40;
      _L1= connectionStatus_loc;
      _L3= true;
      
      automaton connectionStatus_SM
        initial state NoConnection
          unless
            if condition_ID_4 restart ConnectionUp;
            if condition_ID_1 or condition_ID_2
              restart ConnectionLost_SetupFailed;
          var
            _L1 : safeRadioConnectionStatus_Type;
          let
            connectionStatus_loc= _L1;
            _L1= srcs_NoConnection;
          tel

        state ConnectionLost_SetupFailed
          unless
            if condition_ID_4 restart ConnectionUp;
            if condition_ID_3 restart NoConnection;
          var
            _L1 : safeRadioConnectionStatus_Type;
          let
            connectionStatus_loc= _L1;
            _L1= srcs_ConnectionLost_SetupFailed;
          tel

        state ConnectionUp
          unless
            if condition_ID_5 or condition_ID_6 or condition_ID_7
              restart NoConnection;
            if condition_ID_2 restart ConnectionLost_SetupFailed;
          var
            _L1 : safeRadioConnectionStatus_Type;
          let
            connectionStatus_loc= _L1;
            _L1= srcs_ConnectionUp;
          tel
      returns ..;
      _L4= startOfMissionProcedureIsGoingOn;
      _L5= finalAttemptToSetupTheSafeRadioConnectionFailed;
      _L6= _L4 and _L5;
      _L7= connectionStatusTimerExpired;
      _L8= startOfMissionProcedureIsGoingOn;
      _L9= not _L8;
      _L10= _L9 and _L11;
      _L11= requestsToSetupASafeRadioConnectionAreStopped_unsuccessfullReason;
      condition_ID_1= _L6;
      condition_ID_2= _L7;
      condition_ID_3= _L10;
      condition_ID_4= _L12;
      condition_ID_5= _L13;
      condition_ID_6= _L16;
      condition_ID_7= _L19;
      _L12= safeRadioConnection_Setup;
      _L13= safeRadioConnection_Released;
      _L14= requestsToSetupASafeRadioConnectionAreStopped_unsuccessfullReason;
      _L15= safeRadioConnection_Lost;
      _L16= _L15 and _L14;
      _L17= safeRadioConnection_Lost;
      _L18= trainfrontIsInsideAnAnnouncedRadioHole;
      _L19= _L17 and _L18;
      _L21, _L22= #1 Utils::countDownTimer(_L31, _L28, _L23, _L24, _L27);
      _L23= actualTime;
      _= _L22;
      connectionStatusTimerExpired= _L21;
      _L24= false;
      _L27= connectionStatusTimerInterval;
      _L28= requestsToSetupASafeRadioConnectionAreStopped;
      _L29= firstRequestToSetupASafeRadioConnection_fromEstablishing;
      _L30= firstRequestToSetupASafeRadioConnection_fromMaintaining;
      _L31= _L29 or _L30;
      _L40= (make safeRadioConnectionStatusValid_Type)(_L3, _L1);
    tel
    
    node #pragma kcg doc Subset 096, REQ 3.5.6 #end
      #pragma kcg doc Implements the registration to the radio network. #end
      #pragma kcg doc "Remark_1" {Description = "- Name: registeringToTheRadioNetwork - Description: Implements the registration to the radio network. - Copyright Siemens AG, 2013 - Licensed under the EUPL V.1.1 ( http://joinup.ec.europa.eu/software/page/eupl/licence-eupl ) - Gist URL: --- - Cryptography: No - Author(s): Uwe Steinke  The use of this software is limited to non-vital applications.  It has not been developed for vital operation purposes and must not be used for applications which may cause harm to people, physical accidents or financial loss.  THEREFORE, NO LIABILITY WILL BE GIVEN FOR SUCH AND ANY OHER KIND OF USE."} #end
      registeringToTheRadioNetwork(
        atPowerUp : bool;
        afterDriverEntryOfANewRadioNetworkID : bool;
        level : M_LEVEL;
        registrationOrderedFromTrackside : bool;
        registrationOrderFromTracksideCancelled : bool;
        atPowerOff : bool;
        RadioNetworkID_memorized
        : Packet_Types_Pkg::P45_RadioNetworkRegistration_T;
        RadioNetworkID_fromDriver
        : Packet_Types_Pkg::P45_RadioNetworkRegistration_T;
        RadioNetworkID_fromTrackside
        : Packet_Types_Pkg::P45_RadioNetworkRegistration_T;
        triggerDecisionThatNoRadioNetworkIDAvailable : bool;
        mobileHWStatus : mobileHWStatus_Type;
        mobileSWCmd : mobileSWCmd_Type;
        RadioNetworkID_Default
        : Packet_Types_Pkg::P45_RadioNetworkRegistration_T)
      returns (
        orderTheRegistrationOfItsConnectedMobiles : bool;
        memorizeTheLastRadioNetworkID : bool;
        actualRadioNetworkID : Packet_Types_Pkg::P45_RadioNetworkRegistration_T;
        rejectOrderToContactRBC_or_RIU : bool;
        mobileHWCmd : mobileHWCmd_Type default = cInvalidmobileHWCmd;
        mobileSWStatus : mobileSWStatus_Type)
    var
      startTheRegistrationOfConnectedMobiles : bool;
      noValidActualRadioNetworkID_available : bool last = true;
      newRadioNetworkIDReceivedFromTracksideOrDriver : bool;
      actualRadioNetworkID_loc
      : Packet_Types_Pkg::P45_RadioNetworkRegistration_T;
      mobileSWStatus_loc : mobileSWStatus_Type last = cInvalidMobileSWStatus;
      orderTheRegistrationOfEachMobile : bool;
      _L1 : bool;
      _L2 : bool;
      _L3 : M_LEVEL;
      _L5 : bool;
      _L6 : bool;
      _L7 : M_LEVEL;
      _L8 : M_LEVEL;
      _L9 : bool;
      _L10 : bool;
      _L11 : bool;
      _L12 : bool;
      _L13 : bool;
      _L14 : bool;
      _L15 : bool;
      _L16 : bool;
      _L17 : Packet_Types_Pkg::P45_RadioNetworkRegistration_T;
      _L22 : bool;
      _L23 : bool;
      _L24 : Packet_Types_Pkg::P45_RadioNetworkRegistration_T;
      _L25 : Packet_Types_Pkg::P45_RadioNetworkRegistration_T;
      _L26 : bool;
      _L27 : bool;
      _L28 : Packet_Types_Pkg::P45_RadioNetworkRegistration_T;
      _L31 : bool;
      _L32 : bool;
      _L33 : bool;
      _L34 : Packet_Types_Pkg::P45_RadioNetworkRegistration_T;
      _L35 : bool;
      _L37 : bool;
      _L38 : bool;
      _L39 : bool;
      _L41 : Packet_Types_Pkg::P45_RadioNetworkRegistration_T;
      _L42 : bool;
      _L43 : bool;
      _L44 : bool;
      _L45 : Packet_Types_Pkg::P45_RadioNetworkRegistration_T;
      _L46 : Packet_Types_Pkg::P45_RadioNetworkRegistration_T;
      _L47 : bool;
      _L48 : bool;
      _L49 : bool;
      _L50 : Packet_Types_Pkg::P45_RadioNetworkRegistration_T;
      _L51 : bool;
      _L54 : bool;
      _L55 : bool;
      _L57 : bool;
      _L59 : mobileSWStatus_Type;
      _L58 : mobileHWCmd_Type;
      _L60 : mobileSWCmd_Type;
      _L76 : mobileSWStatus_Type;
      _L78 : bool;
      _L79 : bool;
      _L80 : Packet_Types_Pkg::P45_RadioNetworkRegistration_T;
      _L84 : mobileSWConnectionStatus_Type;
      _L85 : mobileSWConnectionStatus_Type;
      _L86 : mobileSWConnectionStatus_Type;
      _L87 : mobileSWConnectionStatus_Type;
      _L89 : bool;
      _L92 : bool;
      _L93 : mobileSWConnectionStatus_Type;
      _L94 : bool;
      _L95 : bool;
      _L96 : bool;
      _L97 : bool;
      _L98 : bool;
      _L99 : bool;
      _L100 : bool;
      _L101 : bool;
      _L102 : bool;
      _L103 : bool;
      _L105 : bool;
      _L106 : bool;
      _L107 : bool;
      _L108 : bool;
      _L109 : bool;
      _L110 : bool;
      _L111 : bool;
      _L112 : bool;
      _L113 : mobileSWConnectionStatus_Type;
      _L114 : bool;
      _L115 : mobileSWConnectionStatus_Type;
      _L116 : bool;
      _L117 : bool;
      _L118 : mobileSWCmd_Type;
      _L119 : mobileSWAction_Type;
      _L120 : bool;
      _L121 : Packet_Types_Pkg::P45_RadioNetworkRegistration_T;
      _L122 : NID_MN;
      _L123 : mobileHWStatus_Type;
      _L124 : mobileSWCmd_Type;
      _L125 : NID_MN;
      _L126 : bool;
      _L77 : NID_MN;
      _L73 : mobileSWConnectionStatus_Type;
      _L72 : bool;
      _L71 : bool;
    let
      _L1= atPowerUp;
      _L2= afterDriverEntryOfANewRadioNetworkID;
      _L3= level;
      orderTheRegistrationOfItsConnectedMobiles= _L5;
      _L5= _L6 or _L12 or _L37;
      _L6= #1 digital::RisingEdge(_L1);
      _L7= M_LEVEL_Level_2;
      _L8= M_LEVEL_Level_3;
      _L9= _L7 = _L3;
      _L10= _L3 = _L8;
      _L11= _L9 or _L10;
      _L12= _L2 and _L11;
      memorizeTheLastRadioNetworkID= _L27;
      _L13= atPowerOff;
      _L14= #2 digital::RisingEdge(_L13);
      _L15= atPowerUp;
      _L16= #3 digital::RisingEdge(_L15);
      _L17= RadioNetworkID_memorized;
      _L22= _L17.valid;
      _L23= _L22 and _L16;
      _L24= #1 linear::MemoryBasic(_L50, _L25, _L33);
      _L25= cInvalidRadioNetworkID;
      _L26= _L24.valid;
      _L27= _L14 and _L26;
      actualRadioNetworkID= _L24;
      _L28= RadioNetworkID_fromDriver;
      _L31= _L28.valid;
      _L32= _L31 and _L39;
      _L33= _L23 or _L32 or _L44 or _L49;
      _L34= if _L32 then _L28 else _L17;
      _L35= triggerDecisionThatNoRadioNetworkIDAvailable;
      _L37= _L35 and _L38;
      _L38= not _L26;
      _L39= afterDriverEntryOfANewRadioNetworkID;
      startTheRegistrationOfConnectedMobiles= _L5;
      _L41= RadioNetworkID_fromTrackside;
      _L42= registrationOrderedFromTrackside;
      _L43= _L41.valid;
      _L44= _L43 and _L42;
      _L45= if _L44 then _L41 else _L34;
      _L46= RadioNetworkID_Default;
      _L47= triggerDecisionThatNoRadioNetworkIDAvailable;
      _L48= _L46.valid;
      _L49= _L48 and _L47 and _L51;
      _L50= if _L49 then _L46 else _L45;
      noValidActualRadioNetworkID_available= _L38;
      _L51= last 'noValidActualRadioNetworkID_available;
      _L54= _L32 or _L44;
      newRadioNetworkIDReceivedFromTracksideOrDriver= _L54;
      _L55= newRadioNetworkIDReceivedFromTracksideOrDriver;
      _L57= startTheRegistrationOfConnectedMobiles;
      _L58, _L59= #1 radioNetworkMobile(_L123, _L118);
      _L60= (make mobileSWCmd_Type)(_L120, _L119, _L122);
      actualRadioNetworkID_loc= _L24;
      mobileSWStatus_loc= _L59;
      _L71, _L72, _L73, _L77, _L126= (flatten mobileSWStatus_Type)(_L76);
      _L76= last 'mobileSWStatus_loc;
      _L78= _L71 and _L72 and _L111;
      _L79= _L77 <> _L125;
      _L80= actualRadioNetworkID_loc;
      _L84= mswc_connecting;
      _L85= mswc_connected;
      _L86= mswc_establishingSession;
      _L87= mswc_sessionEstablished;
      _L89= _L73 = _L93;
      _L92= _L93 <> _L73;
      _L93= mswc_unregistered;
      _L94= _L92 and _L79;
      _L95= _L89 or _L94;
      _L96= _L73 = _L86;
      _L97= _L73 = _L87;
      _L98= _L96 or _L97;
      _L99= not _L98;
      _L100= _L73 = _L84;
      _L101= _L73 = _L85;
      _L102= _L100 or _L101;
      _L103= not _L102;
      _L105= _L106 and _L95 and _L99 and _L103;
      _L106= registrationOrderedFromTrackside;
      orderTheRegistrationOfEachMobile= _L78;
      _L107= _L108 and _L95 and _L99 and _L103;
      _L108= #1 digital::FlipFlopReset(_L106, _L109, false);
      _L109= registrationOrderFromTracksideCancelled;
      _L110= #4 digital::RisingEdge(_L107);
      _L111= _L105 or _L110;
      rejectOrderToContactRBC_or_RIU= _L116;
      _L112= _L73 = _L113;
      _L113= mswc_unregistered;
      _L114= _L73 = _L115;
      _L115= mswc_registering;
      _L116= _L112 or _L114;
      _L117= orderTheRegistrationOfEachMobile;
      _L118= if _L120 then _L60 else _L124;
      _L119= mswa_register;
      _L120= _L117 or _L57 or _L55;
      _L121= actualRadioNetworkID_loc;
      _L122= _L121.nid_mn;
      _L123= mobileHWStatus;
      _L124= mobileSWCmd;
      mobileHWCmd= _L58;
      mobileSWStatus= _L59;
      _L125= _L80.nid_mn;
      _= _L126;
    tel
    
    node #pragma kcg doc Subset 096, REQ 3.5.5.1 #end
      #pragma kcg doc Initiates and processes the termination of a communication session. #end
      #pragma kcg doc "Remark_1" {Description = "- Name: initiateTerminatingASession - Description: Initiates and processes the termination of a communication session.  - Copyright Siemens AG, 2013 - Licensed under the EUPL V.1.1 ( http://joinup.ec.europa.eu/software/page/eupl/licence-eupl ) - Gist URL: --- - Cryptography: No - Author(s): Uwe Steinke  The use of this software is limited to non-vital applications.  It has not been developed for vital operation purposes and must not be used for applications which may cause harm to people, physical accidents or financial loss.  THEREFORE, NO LIABILITY WILL BE GIVEN FOR SUCH AND ANY OHER KIND OF USE."} #end
      initiateTerminatingASession(
        orderReceivedFromTrackside : Coder_Pkg::p42e_SessionManagement_T;
        errorConditionRequiringTerminationDetected : bool;
        trainIsRejectedByRBC_duringStartOfMission : bool;
        driverClosesTheDeskduringStartOfMission : bool;
        trainExitedFromAnRBCArea : bool;
        receivedOrderToTerminateTheSession
        : Coder_Pkg::p42e_SessionManagement_T;
        actualTime : time_Type;
        isInCommunicationSessionWithAnRIU : bool;
        level_1_isLeft : bool;
        endOfMissionIsExecuted : bool)
      returns (initiateTermination : bool; sendAPositionReport : bool)
    sig
      sTerminateTheCommunicationSession, sSendAPositionReport;
    var
      orderToTerminateTheSessionIsReceived : bool;
      noReplyReceivedAfterLastRepetition : bool;
      definedNumberOfRepetitionsHasBeenReached : bool default = false;
      _L1 : Coder_Pkg::p42e_SessionManagement_T;
      _L15 : bool;
      _L16 : bool;
      _L17 : bool;
      _L19 : bool;
      _L20 : Coder_Pkg::p42e_SessionManagement_T;
      _L34 : bool;
      _L35 : bool;
      _L36 : bool;
      _L37 : bool;
      _L38 : bool;
      _L39 : bool;
      _L40 : bool;
      _L41 : bool;
      _L42 : bool;
      _L47 : bool;
      _L48 : bool;
    let
      _L1= orderReceivedFromTrackside;
      _L15= errorConditionRequiringTerminationDetected;
      initiateTermination= _L16;
      _L16= _L47 or _L15 or _L17 or _L19 or _L36 or _L42;
      _L17= trainIsRejectedByRBC_duringStartOfMission;
      _L19= driverClosesTheDeskduringStartOfMission;
      
      automaton TrainExitedFromRBCArea_SM
        initial state Idle
          unless
            if trainExitedFromAnRBCArea
              do restart WaitForOrderToTerminateTheSession;

        state WaitForOrderToTerminateTheSession
          unless
            if orderToTerminateTheSessionIsReceived restart Idle;
          var
            _L2 : time_Type;
            _L20 : int;
            _L26 : bool;
            _L25 : bool;
            _L27 : time_Type;
            _L28 : bool;
          let
            _L2= cPositionReportRepetitionInterval;
            definedNumberOfRepetitionsHasBeenReached= _L26;
            emit 'sSendAPositionReport if _L25;
            _L20= cPositionReoport_MaxNoOfRepetitions;
            _L25, _L26=
              #1 Utils::waitAndRepeatTimer(_L27, _L28, _L28, _L2, _L20);
            _L27= actualTime;
            _L28= false;
          tel
          until
            if noReplyReceivedAfterLastRepetition
              do let emit 'sTerminateTheCommunicationSession; tel restart Idle;
      returns ..;
      _L20= receivedOrderToTerminateTheSession;
      orderToTerminateTheSessionIsReceived= _L48;
      sendAPositionReport= _L34;
      _L34= 'sSendAPositionReport;
      _L35= definedNumberOfRepetitionsHasBeenReached;
      noReplyReceivedAfterLastRepetition= _L35;
      _L36= 'sTerminateTheCommunicationSession;
      _L37= isInCommunicationSessionWithAnRIU;
      _L38= level_1_isLeft;
      _L39= endOfMissionIsExecuted;
      _L40= _L38 and _L37;
      _L41= _L37 and _L39;
      _L42= _L40 or _L41;
      _L47= _L1.terminate;
      _L48= _L20.terminate;
    tel
    
    node #pragma kcg doc Subset 096, REQ 3.5.3.5.2 #end
      #pragma kcg doc Determines, if an establishing or established session has to be terminated due to a new order that request a session with a different RBC. #end
      #pragma kcg doc Initiates the termination, waits til the termination is achieved and initiates the new session. #end
      #pragma kcg doc "Remark_1" {Description = "- Name: terminateAndEstablishSession - Description: Terminates the actual session and establishes a new one, if required.  - Copyright Siemens AG, 2013 - Licensed under the EUPL V.1.1 ( http://joinup.ec.europa.eu/software/page/eupl/licence-eupl ) - Gist URL: --- - Cryptography: No - Author(s): Uwe Steinke  The use of this software is limited to non-vital applications.  It has not been developed for vital operation purposes and must not be used for applications which may cause harm to people, physical accidents or financial loss.  THEREFORE, NO LIABILITY WILL BE GIVEN FOR SUCH AND ANY OHER KIND OF USE."} #end
      terminateAndEstablishSession(
        newOrderToEstablishASession_in : Coder_Pkg::p42e_SessionManagement_T;
        sessionStatus : Radio_Types_Pkg::sessionStatus_Type;
        OBU_hasToEstablishANewSession : bool)
      returns (
        initiateTermination : bool;
        initiateEstablishingNewSession : bool default = false;
        newOrderToEstablishASession_out : Coder_Pkg::p42e_SessionManagement_T)
    var
      terminateActualSession : bool;
      storedOrder : Coder_Pkg::p42e_SessionManagement_T;
      ActualSessionIsInactive : bool;
      _L18 : Coder_Pkg::p42e_SessionManagement_T;
      _L19 : bool;
      _L25 : Radio_Types_Pkg::sessionStatus_Type;
      _L26 : bool;
      _L27 : bool;
      _L28 : bool;
      _L30 : Coder_Pkg::p42e_SessionManagement_T;
      _L33 : bool;
      _L34 : bool;
      _L35 : bool;
      _L36 : Coder_Pkg::p42e_SessionManagement_T;
      _L4 : Radio_Types_Pkg::sessionStatus_Type;
    let
      initiateTermination= _L28;
      _L18= newOrderToEstablishASession_in;
      _L19= _L18.terminate;
      _L25= sessionStatus;
      _L26= _L25 <> _L4;
      _L27= OBU_hasToEstablishANewSession;
      _L28= _L19 and _L27 and _L26;
      terminateActualSession= _L28;
      _L30= #1 linear::MemoryBasic(_L18, _L36, _L35);
      storedOrder= _L30;
      ActualSessionIsInactive= _L33;
      
      automaton SM1
        initial state NoTerminationInProgress
          unless
            if terminateActualSession restart TerminationInProgress;
          var
            _L1 : Coder_Pkg::p42e_SessionManagement_T;
          let
            newOrderToEstablishASession_out= _L1;
            _L1= newOrderToEstablishASession_in;
          tel

        state TerminationInProgress
          unless
            if ActualSessionIsInactive restart EstablishNewSession;
          var
            _L2 : Coder_Pkg::p42e_SessionManagement_T;
          let
            newOrderToEstablishASession_out= _L2;
            _L2= Coder_Pkg::cInvalidOrder;
          tel

        state EstablishNewSession
          unless
            if true restart NoTerminationInProgress;
          var
            _L1 : Coder_Pkg::p42e_SessionManagement_T;
            _L2 : bool;
          let
            newOrderToEstablishASession_out= _L1;
            _L1= storedOrder;
            initiateEstablishingNewSession= _L2;
            _L2= true;
          tel
      returns ..;
      _L33= not _L26;
      _L34= _L18.establish;
      _L35= _L34 or _L19;
      _L36= Coder_Pkg::cInvalidOrder;
      _L4= Radio_Types_Pkg::morc_st_inactive;
    tel
    
    function #pragma kcg doc Subset 096, REQ 3.5.7.6 #end
      #pragma kcg doc Manages the switch of the indication status in the case of an RBC/RBC transition #end
      #pragma kcg doc "Remark_1" {Description = "- Name: RBCTransition_forSafeRadioConnectionIndication - Description: Manages the switch of the indication status in the case of an RBC/RBC transition  - Copyright Siemens AG, 2013 - Licensed under the EUPL V.1.1 ( http://joinup.ec.europa.eu/software/page/eupl/licence-eupl ) - Gist URL: --- - Cryptography: No - Author(s): Uwe Steinke  The use of this software is limited to non-vital applications.  It has not been developed for vital operation purposes and must not be used for applications which may cause harm to people, physical accidents or financial loss.  THEREFORE, NO LIABILITY WILL BE GIVEN FOR SUCH AND ANY OHER KIND OF USE."} #end
      RBCTransition_forSafeRadioConnectionIndication(
        connectionStatus_ofHandingOverRBC : safeRadioConnectionStatusValid_Type;
        connectionStatus_ofAcceptingRBC : safeRadioConnectionStatusValid_Type;
        acceptingRBC_becomesTheSupervisingRBC : bool;
        safeRadioConnectionIsReleasedWithTheHandingoverRBC : bool;
        minimumSafeRearEndOfTheTrainHasCrossedTheBorder : bool)
      returns (connectionStatus : safeRadioConnectionStatusValid_Type)
    var
      _L1 : safeRadioConnectionStatusValid_Type;
      _L2 : safeRadioConnectionStatusValid_Type;
      _L3 : safeRadioConnectionStatusValid_Type;
      _L4 : bool;
      _L5 : bool;
      _L6 : bool;
      _L7 : bool;
      _L8 : bool;
    let
      _L1= connectionStatus_ofHandingOverRBC;
      _L2= connectionStatus_ofAcceptingRBC;
      connectionStatus= _L3;
      _L3= if _L8 then _L2 else _L1;
      _L4= acceptingRBC_becomesTheSupervisingRBC;
      _L5= minimumSafeRearEndOfTheTrainHasCrossedTheBorder;
      _L6= safeRadioConnectionIsReleasedWithTheHandingoverRBC;
      _L7= _L5 and _L6;
      _L8= _L4 or _L7;
    tel
    
    node #pragma kcg doc Subset 096, REQ 3.5.3.13, 3.5.3.16, 3.5.3.13.1, 3.5.3.14, 3.5.3.15: #end
      #pragma kcg doc Evaluates the order to contact a RBC, i. e. establish, maintain or terminate a communication session. #end
      #pragma kcg doc "Remark_1" {Description = "- Name: evaluateOrderToContactAnRBD - Description: Evaluates the orders to establish, maintain or terminate a communication session - Copyright Siemens AG, 2013 - Licensed under the EUPL V.1.1 ( http://joinup.ec.europa.eu/software/page/eupl/licence-eupl ) - Gist URL: --- - Cryptography: No - Author(s): Uwe Steinke  The use of this software is limited to non-vital applications.  It has not been developed for vital operation purposes and must not be used for applications which may cause harm to people, physical accidents or financial loss.  THEREFORE, NO LIABILITY WILL BE GIVEN FOR SUCH AND ANY OHER KIND OF USE."} #end
      evaluateOrderToContactAnRBD(
        order_in : orderToContactAnRBC_Type;
        onBoardStoredShortPhoneNo : rbc_phoneNo_Type)
      returns (order_out : orderToContactAnRBC_Type)
    var
      _L1 : orderToContactAnRBC_Type;
      _L12 : rbc_id_Type;
      _L13 : bool;
      _L14 : bool;
      _L16 : orderToContactAnRBC_Type;
      _L17 : orderToContactAnRBC_Type;
      _L18 : orderToContactAnRBC_Type;
      _L19 : bool;
      _L20 : bool;
      _L22 : rbc_id_Type;
      _L23 : rbc_phoneNo_Type;
      _L26 : bool;
      _L27 : rbc_id_Type;
      _L28 : rbc_phoneNo_Type;
      _L29 : bool;
      _L30 : bool;
      _L34 : rbc_phoneNo_Type;
      _L35 : orderToContactAnRBC_Type;
      _L37 : rbc_phoneNo_Type;
      _L38 : rbc_phoneNo_Type;
      _L39 : bool;
      _L40 : rbc_phoneNo_Type;
      _L53 : orderToContactAnRBC_Type;
      _L54 : rbc_id_Type;
      _L55 : bool;
    let
      _L1= order_in;
      _L12= cRBC_id_contactLastKnownRBC;
      _L13= _L12 = _L54;
      _L14= _L13 and _L55;
      _L16= #1 linear::MemoryBasic(_L18, _L17, _L20);
      _L17= cInvalidOrderToContactAnRBC;
      _L18= fby(_L1; 1; cInvalidOrderToContactAnRBC);
      _L19= _L1.valid;
      _L20= #1 digital::FallingEdge(_L26);
      _L22= cRBC_id_contactLastKnownRBC;
      _L23= cRBC_phoneNo_UseOnboardStoredShortNo;
      _L26= _L19 and _L29 and _L30;
      _L27= _L1.rbc_id;
      _L28= _L1.telephoneNoOfTheRBC;
      _L29= _L27 <> _L22;
      _L30= _L28 <> _L23;
      order_out= _L53;
      _L34= onBoardStoredShortPhoneNo;
      _L35= if _L14 then _L16 else _L1;
      _L37= _L35.telephoneNoOfTheRBC;
      _L38= cRBC_phoneNo_UseOnboardStoredShortNo;
      _L39= _L37 = _L38;
      _L40= if _L39 then _L34 else _L37;
      _L53= (_L35 with .telephoneNoOfTheRBC = _L40);
      _L54= _L1.rbc_id;
      _L55= _L1.valid;
    tel
    
    function #pragma kcg doc Checks, it the order carries a valid "Establish Session" command #end
      #pragma kcg doc "Remark_1" {Description = "- Name: isOrderToEstablishConnection - Description: Checks, it the order carries a valid "Establish Session" command - Copyright Siemens AG, 2013 - Licensed under the EUPL V.1.1 ( http://joinup.ec.europa.eu/software/page/eupl/licence-eupl ) - Gist URL: --- - Cryptography: No - Author(s): Uwe Steinke  The use of this software is limited to non-vital applications.  It has not been developed for vital operation purposes and must not be used for applications which may cause harm to people, physical accidents or financial loss.  THEREFORE, NO LIABILITY WILL BE GIVEN FOR SUCH AND ANY OHER KIND OF USE."} #end
      isOrderToEstablishConnection(order : orderToContactAnRBC_Type)
      returns (isEstablishCmd : bool)
    var
      _L1 : orderToContactAnRBC_Type;
      _L3 : bool;
      _L4 : morc_RBC_action_Type;
      _L5 : morc_RBC_action_Type;
      _L6 : bool;
      _L7 : bool;
    let
      isEstablishCmd= _L7;
      _L1= order;
      _L3= _L1.valid;
      _L4= _L1.actionToBePerformed;
      _L5= morc_rbca_establishSession;
      _L6= _L4 = _L5;
      _L7= _L3 and _L6;
    tel
    
    node #pragma kcg doc Subset 096, REQ 3.5.6.3.2, 3.5.6.5 #end
      #pragma kcg doc Controls the registration to the radio network for a single mobile terminal. #end
      #pragma kcg doc "Remark_1" {Description = "- Name: radioNetworkMobile - Description: Controls the registration to the radio network for a single mobile terminal.  - Copyright Siemens AG, 2013 - Licensed under the EUPL V.1.1 ( http://joinup.ec.europa.eu/software/page/eupl/licence-eupl ) - Gist URL: --- - Cryptography: No - Author(s): Uwe Steinke  The use of this software is limited to non-vital applications.  It has not been developed for vital operation purposes and must not be used for applications which may cause harm to people, physical accidents or financial loss.  THEREFORE, NO LIABILITY WILL BE GIVEN FOR SUCH AND ANY OHER KIND OF USE."} #end
      radioNetworkMobile(
        mobileHWStatus : mobileHWStatus_Type;
        mobileSWCmd : mobileSWCmd_Type)
      returns (
        mobileHWCmd : mobileHWCmd_Type default = cInvalidmobileHWCmd;
        mobileSWStatus : mobileSWStatus_Type)
    sig
      sHwRegister, sHWConnect, sHWDisconnect, sHWUnregister;
    var
      hw_available : bool;
      hw_connectionStatus : mobileHWConnectionStatus_Type;
      sw_cmd : mobileSWAction_Type;
      radioNetworkID : NID_MN;
      hw_cmd : mobileHWAction_Type default = mhwa_nop;
      sw_connectionStatus
      : mobileSWConnectionStatus_Type
      default = mswc_unregistered;
      registeredRadioNetworkID : NID_MN;
      _L1 : mobileHWStatus_Type;
      _L2 : mobileHWStatus_Type;
      _L3 : bool;
      _L4 : mobileHWStatus_Type;
      _L17 : mobileSWCmd_Type;
      _L18 : mobileSWCmd_Type;
      _L19 : bool;
      _L20 : mobileSWCmd_Type;
      _L28 : mobileSWAction_Type;
      _L29 : mobileSWAction_Type;
      _L38 : mobileHWConnectionStatus_Type;
      _L39 : mobileHWConnectionStatus_Type;
      _L40 : NID_MN;
      _L41 : bool;
      _L42 : NID_MN;
      _L27 : NID_MN;
      _L26 : mobileSWAction_Type;
      _L25 : bool;
      _L44 : bool;
      _L9 : mobileHWConnectionStatus_Type;
      _L8 : bool;
      _L45 : bool;
    let
      _L1= mobileHWStatus;
      _L2= #1 linear::MemoryBasic(_L1, _L4, _L3);
      _L3= _L1.valid;
      _L4= cInvalidMobileHWStatus;
      _L8, _L9, _L44, _L45= (flatten mobileHWStatus_Type)(_L2);
      hw_available= _L8;
      hw_connectionStatus= _L39;
      _L17= mobileSWCmd;
      _L18= #2 linear::MemoryBasic(_L17, _L20, _L19);
      _L19= _L17.valid;
      _L20= cInvalidMobileSWCmd;
      _L25, _L26, _L27= (flatten mobileSWCmd_Type)(_L18);
      _L28= if _L25 then _L26 else _L29;
      _L29= mswa_nop;
      sw_cmd= _L28;
      radioNetworkID= _L27;
      
      automaton MobileHW_available_SM
        state MobileHWNotAvailable
          unless
            if hw_available do restart MobileHWAvailable;
          var
            _L4 : mobileSWStatus_Type;
          let
            mobileSWStatus= _L4;
            _L4= cMobileSWStatus_noHW;
          tel

        state MobileHWAvailable
          unless
            if not hw_available do restart MobileHWNotAvailable;
          var
            _L14 : mobileSWStatus_Type;
            _L15 : bool;
            _L16 : mobileSWConnectionStatus_Type;
            _L17 : mobileHWCmd_Type;
            _L18 : NID_MN;
            _L19 : bool;
            _L20 : bool;
            _L21 : bool;
            _L22 : bool;
            _L23 : bool;
            _L24 : mobileHWAction_Type;
            _L25 : NID_MN;
            _L26 : mobileHWStatus_Type;
            _L27 : bool;
            _L28 : int;
          let
            
            automaton MobileSWConnection_SM
              initial state UnregisteredToTheRadioNetwork
                unless
                  if sw_cmd = mswa_register
                    do let
                      emit 'sHwRegister;
                    tel restart RegisteringToTheRadioNetwork;

              state RegisteringToTheRadioNetwork
                unless
                  if hw_connectionStatus = mhwc_registered
                    restart RegisteredToTheRadioNetwork;
                  if sw_cmd = mswa_unregister
                    do let
                      emit 'sHWUnregister;
                    tel restart UnregisteredToTheRadioNetwork;
                  if sw_cmd = mswa_register
                    do let
                      emit 'sHwRegister;
                    tel restart RegisteringToTheRadioNetwork;
                var
                  _L3 : mobileSWConnectionStatus_Type;
                let
                  _L3= mswc_registering;
                  sw_connectionStatus= _L3;
                tel

              state RegisteredToTheRadioNetwork
                unless
                  if sw_cmd = mswa_unregister
                    do let
                      emit 'sHWUnregister;
                    tel restart UnregisteredToTheRadioNetwork;
                  if sw_cmd = mswa_connect
                    do let
                      emit 'sHWConnect;
                    tel restart ConnectingToTheRadioNetwork;
                  if hw_connectionStatus = mhwc_notRegistered
                    restart UnregisteredToTheRadioNetwork;
                var
                  _L2 : mobileSWConnectionStatus_Type;
                let
                  sw_connectionStatus= _L2;
                  _L2= mswc_registered;
                tel

              state ConnectingToTheRadioNetwork
                unless
                  if sw_cmd = mswa_disconnect
                    do let
                      emit 'sHWDisconnect;
                    tel restart RegisteredToTheRadioNetwork;
                  if hw_connectionStatus = mhwc_connected
                    restart ConnectedToTheRadioNetwork;
                var
                  _L1 : mobileSWConnectionStatus_Type;
                let
                  _L1= mswc_connecting;
                  sw_connectionStatus= _L1;
                tel

              state ConnectedToTheRadioNetwork
                unless
                  if sw_cmd = mswa_disconnect
                    do let
                      emit 'sHWDisconnect;
                    tel restart RegisteredToTheRadioNetwork;
                  if hw_connectionStatus = mhwc_registered
                    restart RegisteredToTheRadioNetwork;
                  if hw_connectionStatus = mhwc_notRegistered
                    restart UnregisteredToTheRadioNetwork;
                  if sw_cmd = mswa_establishRadioConnection
                    restart EstablishingASession;
                var
                  _L1 : mobileSWConnectionStatus_Type;
                let
                  sw_connectionStatus= _L1;
                  _L1= mswc_connected;
                tel

              state EstablishingASession
                unless
                  if true restart SessionEstablished;
                var
                  _L1 : mobileSWConnectionStatus_Type;
                let
                  sw_connectionStatus= _L1;
                  _L1= mswc_establishingSession;
                tel

              state SessionEstablished
                unless
                  if sw_cmd = mswa_terminateRadioConnection
                    restart ConnectedToTheRadioNetwork;
                  if hw_connectionStatus = mhwc_notRegistered
                    restart UnregisteredToTheRadioNetwork;
                var
                  _L1 : mobileSWConnectionStatus_Type;
                let
                  _L1= mswc_sessionEstablished;
                  sw_connectionStatus= _L1;
                tel
            returns ..;
            mobileSWStatus= _L14;
            _L14= (make mobileSWStatus_Type)(_L15, _L15, _L16, _L25, _L27);
            _L15= true;
            _L16= sw_connectionStatus;
            mobileHWCmd= _L17;
            _L17= (make mobileHWCmd_Type)(_L23, _L24, _L18, _L28);
            _L18= radioNetworkID;
            _L19= 'sHWConnect;
            _L20= 'sHWDisconnect;
            _L21= 'sHwRegister;
            _L22= 'sHWUnregister;
            _L23= _L19 or _L20 or _L21 or _L22;
            _L24= hw_cmd;
            activate IfBlock1 if 'sHWUnregister
              then var
                _L1 : mobileHWAction_Type;
              let
                hw_cmd= _L1;
                _L1= mhwa_unregister;
              tel
              else if 'sHwRegister
              then var
                _L1 : mobileHWAction_Type;
              let
                hw_cmd= _L1;
                _L1= mhwa_register;
              tel
              else if 'sHWConnect
              then var
                _L1 : mobileHWAction_Type;
              let
                hw_cmd= _L1;
                _L1= mhwa_connect;
              tel
              else if 'sHWDisconnect
              then var
                _L1 : mobileHWAction_Type;
              let
                hw_cmd= _L1;
                _L1= mhwa_disconnect;
              tel
              else var
                _L1 : mobileHWAction_Type;
              let
                hw_cmd= _L1;
                _L1= mhwa_nop;
              tel
            
            returns ..;
            _L25= registeredRadioNetworkID;
            _L26= mobileHWStatus;
            _L27= _L26.settingUpConnectionHasFailed;
            _L28= 0;
          tel

        initial state InitialState
          unless
            if true do restart MobileHWNotAvailable;
          var
            _L1 : mobileSWStatus_Type;
          let
            _L1= cMobileSWStatus_noHW;
            mobileSWStatus= _L1;
          tel
      returns ..;
      _L38= mhwc_notRegistered;
      _L39= if _L8 then _L9 else _L38;
      _L40= #3 linear::MemoryBasic(_L27, _L42, _L41);
      _L41= 'sHwRegister;
      _L42= cInvalidRadioNetworkID_value;
      registeredRadioNetworkID= _L40;
      _= _L44;
      _= _L45;
    tel
    
    node #pragma kcg doc Subset 096, REQ 3.5.3: #end
      #pragma kcg doc Determines, if a communication session has to be initiated. #end
      #pragma kcg doc "Remark_1" {Description = "- Name: Initiate_a_Session - Description: Determines, if a communication session has to be initiated.  - Copyright Siemens AG, 2013 - Licensed under the EUPL V.1.1 ( http://joinup.ec.europa.eu/software/page/eupl/licence-eupl ) - Gist URL: --- - Cryptography: No - Author(s): Uwe Steinke  The use of this software is limited to non-vital applications.  It has not been developed for vital operation purposes and must not be used for applications which may cause harm to people, physical accidents or financial loss.  THEREFORE, NO LIABILITY WILL BE GIVEN FOR SUCH AND ANY OHER KIND OF USE."} #end
      initiate_a_Session(
        initiateRequest_fromOnboardEquipment : bool;
        initiateRequest_fromRBC : bool;
        initiateRequest_fromRadio_InfillUnit : bool;
        m38_initiationOfACommunicationSession : bool;
        level : M_LEVEL;
        atStartOfMission : bool;
        establishSessionOrderedFromTrackside : bool;
        mode : M_MODE;
        modeChangeHasToBeReportedToRBC : bool;
        driverHasManuallyChangedLevel : bool;
        trainFrontReachesEndOfAnnouncedRadioHole : bool;
        prevSessionTerminatedDueToLossOfSafeRadioConnection : bool;
        startOfMissionProcedureCompleted : bool;
        NoCommunicationSessionEstablished : bool;
        initiateEstablishingNewSessionRequest : bool)
      returns (
        initiate_a_communicationSession_Request : bool;
        communicationSessionInitiatedByOBU_ : bool;
        communicationSessionInitiatedFromTrackside_ : bool)
    var
      establishACommunicationSession_1 : bool;
      initiateACommunicationSession_loc : bool;
      _L1 : bool;
      _L2 : bool;
      _L5 : bool;
      _L6 : M_LEVEL;
      _L7 : M_LEVEL;
      _L8 : M_LEVEL;
      _L9 : bool;
      _L10 : bool;
      _L11 : bool;
      _L12 : bool;
      _L13 : bool;
      _L14 : bool;
      _L20 : bool;
      _L22 : M_MODE;
      _L24 : bool;
      _L25 : M_MODE;
      _L26 : bool;
      _L27 : bool;
      _L30 : bool;
      _L31 : bool;
      _L35 : bool;
      _L37 : bool;
      _L38 : bool;
      _L40 : bool;
      _L41 : bool;
      _L42 : bool;
      _L43 : bool;
      _L54 : bool;
      _L78 : bool;
      _L76 : bool;
      _L75 : bool;
      _L81 : bool;
      _L82 : bool;
      _L83 : bool;
      _L84 : bool;
      _L85 : bool;
      _L87 : bool;
      _L88 : bool;
      _L89 : bool;
      _L90 : bool;
      _L91 : bool;
      _L92 : bool;
      _L93 : bool;
      _L94 : bool;
    let
      _L1= initiateRequest_fromOnboardEquipment;
      _L2= initiateRequest_fromRBC;
      initiate_a_communicationSession_Request= _L43;
      _L5= atStartOfMission;
      _L6= level;
      _L7= M_LEVEL_Level_2;
      _L8= M_LEVEL_Level_3;
      _L9= _L6 = _L8;
      _L10= _L6 = _L7;
      _L11= _L9 or _L10;
      _L12= _L5 and _L11;
      _L13= _L93 or _L1 or _L2;
      _L14= establishSessionOrderedFromTrackside;
      _L20= _L12 or _L14 or _L24 or _L31 or _L35 or _L38 or _L41;
      establishACommunicationSession_1 #pragma kcg doc "Graphical_1" {Text = "is "initiate" the same as "establish"?"} #end=
        _L20;
      _L22= mode;
      _L24= _L11 and _L88 and _L26 and _L27;
      _L25= fby(_L22; 1; M_MODE_System_Failure);
      _L26= _L22 <> _L25;
      _L27= modeChangeHasToBeReportedToRBC;
      _L30= driverHasManuallyChangedLevel;
      _L31= _L11 and _L30;
      _L35= trainFrontReachesEndOfAnnouncedRadioHole;
      _L37= establishACommunicationSession_1;
      _L38= prevSessionTerminatedDueToLossOfSafeRadioConnection;
      _L40= startOfMissionProcedureCompleted;
      _L41= _L11 and _L40 and _L42;
      _L42= NoCommunicationSessionEstablished;
      _L43= _L13 or _L54;
      _L54= _L37 or _L87;
      initiateACommunicationSession_loc= _L43;
      _L75= _L92 and _L76;
      _L76= initiateACommunicationSession_loc;
      _L78= initiateRequest_fromOnboardEquipment;
      communicationSessionInitiatedByOBU_= _L75;
      communicationSessionInitiatedFromTrackside_= _L85;
      _L81= initiateRequest_fromRBC;
      _L82= initiateRequest_fromRadio_InfillUnit;
      _L83= establishSessionOrderedFromTrackside;
      _L84= _L81 or _L82 or _L83 or _L94;
      _L85= _L76 and _L84;
      _L87= initiateEstablishingNewSessionRequest;
      _L88=
        (case _L22 of
        | M_MODE_Full_Supervision: _L89
        | M_MODE_On_Sight: _L89
        | M_MODE_Staff_Responsible: _L89
        | M_MODE_Shunting: _L89
        | M_MODE_Trip: _L89
        | M_MODE_Limited_Supervision: _L89
        | M_MODE_National_System: _L89
        | M_MODE_Reversing: _L89
        | _: _L90);
      _L89= true;
      _L90= false;
      _L91= trainFrontReachesEndOfAnnouncedRadioHole;
      _L92= _L91 or _L78;
      _L93= m38_initiationOfACommunicationSession;
      _L94= m38_initiationOfACommunicationSession;
    tel
    
    node #pragma kcg doc Subset 096, REQ 3.5.3 #end
      #pragma kcg doc Implements the establishing process of a communication session #end
      #pragma kcg doc "Remark_1" {Description = "- Name: establish_a_CommunicationSession - Description: Implements the establishing process of a communication session - Copyright Siemens AG, 2013 - Licensed under the EUPL V.1.1 ( http://joinup.ec.europa.eu/software/page/eupl/licence-eupl ) - Gist URL: --- - Cryptography: No - Author(s): Uwe Steinke  The use of this software is limited to non-vital applications.  It has not been developed for vital operation purposes and must not be used for applications which may cause harm to people, physical accidents or financial loss.  THEREFORE, NO LIABILITY WILL BE GIVEN FOR SUCH AND ANY OHER KIND OF USE."} #end
      establish_a_Session(
        isPartOfAnOngoingStartOfMissionProcedure : bool;
        connectionSuccessfullyEstablished : bool;
        settingUpSafeConnectionHasFailed : bool;
        endOfMissionIsPerformed : bool;
        trainPassesALevelTransitionBorder : bool;
        orderToEstablishACommunicationSession_fromTrackside
        : Coder_Pkg::p42e_SessionManagement_T;
        orderToEstablishACommunicationSession_fromOBU
        : Coder_Pkg::p42e_SessionManagement_T;
        orderDoesNotRequestToContactAnAcceptingRBC : bool;
        trainPassesA_RBC_RBC_border_WithItsFrontEnd : bool;
        systemVersionFromTracksideSupported : bool;
        systemVersionReceived : bool;
        m38_initiationOfACommunicationSession : bool;
        communicationSessionInitiatedByOBU_ : bool;
        communicationSessionInitiatedFromTrackside_ : bool)
      returns (
        InformTheDriverThatNoConnectionWasSetup : bool;
        requestTheSetupOfASafeRadioConnection : bool;
        sendTheMessageInitiationOfCommunicationSessionToTrackside : bool;
        sendMessage_NoCompatibleVersionSupported : bool;
        terminateTheCommunicationSession : bool;
        sendASessionEstablishedReportToTrackside : bool;
        firstRequestToSetupASafeRadioConnection : bool;
        finalAttemptToSetupTheSafeRadioConnectionFailed : bool;
        requestsToSetupTheSafeRadioConnectionStopped : bool;
        sessionSuccessfullyEstablished : bool default = false;
        establishingACommunicationSessionAborted : bool)
    sig
      sRequestTheSetupOfASafeRadioConnection,
      sInformTheDriverThatNoConnectionWasSetup, sTryToEstablishConnectionFailed,
      sSendTheMessageInitiationOfCommunicationSessionToTrackside,
      sSendMessageEstablishedReport, sSendMessage_NoCompatibleVersionSupported,
      sTerminateTheCommunicationSession,
      sSendASessionEstablishedReportToTrackside,
      sFirstRequestToSetupASafeRadioConnection,
      sfinalAttemptToSetupTheSafeRadioConnectionFailed;
    var
      _L59 : bool;
      _L60 : bool;
      _L61 : bool;
      _L62 : bool;
      _L63 : bool;
      _L64 : bool;
      _L65 : bool;
      _L66 : bool;
      _L67 : bool;
      _L68 : bool;
      _L69 : bool;
      _L71 : bool;
      _L72 : bool;
    let
      
      automaton EstablishmentOfACommunicationSession_SM
        initial state Idle
          unless
            if communicationSessionInitiatedByOBU_
              do let
                emit 'sFirstRequestToSetupASafeRadioConnection;
              tel restart RequestSetupOfASafeRadioConnection_initiatedByOBU;
            if communicationSessionInitiatedFromTrackside_
              do let
                emit 'sFirstRequestToSetupASafeRadioConnection;
              tel restart RequestSetupOfASafeRadioConnection_initiatedByTrackside;

        state RequestSetupOfASafeRadioConnection_initiatedByOBU
          unless
            if connectionSuccessfullyEstablished
              do let
                emit 'sSendTheMessageInitiationOfCommunicationSessionToTrackside;
              tel restart WaitForSystemVersionFromTrackSide;
          var
            noOfConnectionRetriesExceeded : bool default = false;
            repeatRetryConditionFailed : bool default = false;
          let
            
            automaton RequestConnectionWithTrackSide_SM
              initial state Start
                unless
                  if isPartOfAnOngoingStartOfMissionProcedure
                    restart TryToEstablishConnection_isPartOfStartOfMission;
                  if true
                    restart TryToEstablishConnection_isNotPartOfStartOfMission;

              state TryToEstablishConnection_isPartOfStartOfMission
                unless
                  if connectionSuccessfullyEstablished restart Success;
                var
                  _L2 : bool;
                  _L3 : int;
                  _L4 : int;
                  _L5 : int;
                  _L6 : int;
                  _L7 : int;
                  _L8 : int;
                  _L9 : bool;
                let
                  
                  automaton RepeatSetupConnection_SM
                    initial state Start
                      unless
                        if true
                          do let
                            emit 'sRequestTheSetupOfASafeRadioConnection;
                          tel restart Retry;

                    state Retry
                      unless
                        if settingUpSafeConnectionHasFailed
                          do let
                            emit 'sRequestTheSetupOfASafeRadioConnection;
                          tel restart Retry;
                  returns ..;
                  _L2= 'sRequestTheSetupOfASafeRadioConnection;
                  _L3= _L4 + _L7;
                  _L4= if _L2 then _L5 else _L6;
                  _L5= 1;
                  _L6= 0;
                  _L7= fby(_L3; 1; 0);
                  _L8= cMaxNoOfConnectionRetries;
                  _L9= _L3 >= _L8;
                  noOfConnectionRetriesExceeded= _L9;
                tel
                until
                  if noOfConnectionRetriesExceeded
                    do let
                      emit 'sInformTheDriverThatNoConnectionWasSetup;
                      emit 'sTryToEstablishConnectionFailed;
                    tel restart NoSuccess;

              state Success

              state NoSuccess

              state TryToEstablishConnection_isNotPartOfStartOfMission
                unless
                  if connectionSuccessfullyEstablished restart Success;
                var
                  _L1 : bool;
                  _L2 : bool;
                  _L4 : bool;
                  _L19 : bool;
                  _L21 : Coder_Pkg::p42e_SessionManagement_T;
                  _L32 : bool;
                  _L35 : bool;
                  _L40 : bool;
                  _L41 : bool;
                  _L42 : bool;
                  _L43 : NID_RBC;
                  _L44 : bool;
                  _L46 : NID_RBC;
                  _L48 : bool;
                  _L20 : Coder_Pkg::p42e_SessionManagement_T;
                let
                  
                  automaton RepeatSetupConnection_SM
                    initial state Start
                      unless
                        if true
                          do let
                            emit 'sRequestTheSetupOfASafeRadioConnection;
                          tel restart Retry;

                    state Retry
                      unless
                        if settingUpSafeConnectionHasFailed
                          do let
                            emit 'sRequestTheSetupOfASafeRadioConnection;
                          tel restart Retry;
                  returns ..;
                  _L1= connectionSuccessfullyEstablished;
                  _= _L1;
                  _L2= endOfMissionIsPerformed;
                  _L4= trainPassesALevelTransitionBorder;
                  _L19= _L43 <> _L46;
                  _L21= orderToEstablishACommunicationSession_fromOBU;
                  _L32= _L42 and _L19 and _L44 and _L48 and _L35;
                  _L35= orderDoesNotRequestToContactAnAcceptingRBC;
                  _L40= trainPassesA_RBC_RBC_border_WithItsFrontEnd;
                  _L41= _L2 or _L4 or _L40 or _L42 or _L32;
                  repeatRetryConditionFailed= _L41;
                  _L42= _L20.terminate;
                  _L43= _L20.nid_rbc;
                  _L44= _L20.establish;
                  _L46= _L21.nid_rbc;
                  _L48= _L21.establish;
                  _L20= orderToEstablishACommunicationSession_fromTrackside;
                tel
                until
                  if repeatRetryConditionFailed
                    do let
                      emit 'sTryToEstablishConnectionFailed;
                    tel restart NoSuccess;
            returns ..;
          tel
          until
            if 'sTryToEstablishConnectionFailed
              do let
                emit 'sfinalAttemptToSetupTheSafeRadioConnectionFailed;
                emit 'sTerminateTheCommunicationSession;
              tel restart Idle;

        state WaitForSystemVersionFromTrackSide
          unless
            if systemVersionFromTracksideSupported and systemVersionReceived
              do let
                emit 'sSendMessageEstablishedReport;
              tel restart CompatibleSystemVersionSupported;
            if systemVersionReceived and not systemVersionFromTracksideSupported
              do let
                emit 'sSendMessage_NoCompatibleVersionSupported;
                emit 'sInformTheDriverThatNoConnectionWasSetup;
              tel restart NoCompatibleSystemVersionSupported;

        state CompatibleSystemVersionSupported
          var
            _L1 : bool;
          let
            sessionSuccessfullyEstablished= _L1;
            _L1= true;
          tel

        state NoCompatibleSystemVersionSupported
          unless
            if true
              do let
                emit 'sTerminateTheCommunicationSession;
                emit 'sfinalAttemptToSetupTheSafeRadioConnectionFailed;
              tel restart WaitTil_CommunicationSessionTerminated;

        state WaitTil_CommunicationSessionTerminated

        state RequestSetupOfASafeRadioConnection_initiatedByTrackside
          unless
            if connectionSuccessfullyEstablished
              restart WaitForMessage_InitiationOfCommunicationSession_FromTrackside;

        state WaitForMessage_InitiationOfCommunicationSession_FromTrackside
          unless
            if m38_initiationOfACommunicationSession
              do let
                emit 'sSendASessionEstablishedReportToTrackside;
              tel restart ConsiderTheCommunicationSessionEstablished;

        state ConsiderTheCommunicationSessionEstablished
          var
            _L1 : bool;
          let
            sessionSuccessfullyEstablished= _L1;
            _L1= true;
          tel
      returns ..;
      InformTheDriverThatNoConnectionWasSetup= _L59;
      requestTheSetupOfASafeRadioConnection= _L60;
      _L59= 'sInformTheDriverThatNoConnectionWasSetup;
      _L60= 'sRequestTheSetupOfASafeRadioConnection;
      sendTheMessageInitiationOfCommunicationSessionToTrackside= _L61;
      _L61= 'sSendTheMessageInitiationOfCommunicationSessionToTrackside;
      _L62= 'sSendMessageEstablishedReport;
      sendMessage_NoCompatibleVersionSupported= _L63;
      _L63= 'sSendMessage_NoCompatibleVersionSupported;
      terminateTheCommunicationSession= _L64;
      _L64= 'sTerminateTheCommunicationSession;
      sendASessionEstablishedReportToTrackside= _L72;
      _L65= 'sSendASessionEstablishedReportToTrackside;
      firstRequestToSetupASafeRadioConnection= _L66;
      _L66= 'sFirstRequestToSetupASafeRadioConnection;
      finalAttemptToSetupTheSafeRadioConnectionFailed= _L67;
      _L67= 'sfinalAttemptToSetupTheSafeRadioConnectionFailed;
      requestsToSetupTheSafeRadioConnectionStopped= _L68;
      _L68= _L67 or _L69;
      _L69= connectionSuccessfullyEstablished;
      establishingACommunicationSessionAborted= _L71;
      _L71= 'sfinalAttemptToSetupTheSafeRadioConnectionFailed;
      _L72= _L62 or _L65;
    tel
    
    node #pragma kcg doc Subset 096, REQ 3.5.4 #end
      #pragma kcg doc Maintains an established communcation session. #end
      #pragma kcg doc "Remark_1" {Description = "- Name: maintaining_a_CommunicationSession - Description: Maintains an established communcation session.   - Copyright Siemens AG, 2013 - Licensed under the EUPL V.1.1 ( http://joinup.ec.europa.eu/software/page/eupl/licence-eupl ) - Gist URL: --- - Cryptography: No - Author(s): Uwe Steinke  The use of this software is limited to non-vital applications.  It has not been developed for vital operation purposes and must not be used for applications which may cause harm to people, physical accidents or financial loss.  THEREFORE, NO LIABILITY WILL BE GIVEN FOR SUCH AND ANY OHER KIND OF USE."} #end
      maintaining_a_Session(
        communicationSessionEstablished : bool;
        safeRadioConnectionReestablished : bool;
        lossOfTheSafeRadioConnection : bool;
        disconnectionHasNotBeenOrdered : bool;
        trainFrontInsideInAnAnnouncedRadioHole : bool;
        actualTime : time_Type)
      returns (
        tryToSetupANewSafeRadioConnection : bool default = false;
        informTheDriverThatNoConnectionWasSetup : bool;
        firstRequestToSetupASafeRadioConnection : bool;
        finalAttemptToSetupTheSafeRadioConnectionFailed : bool;
        requestsToSetupTheSafeRadioConnectionStopped : bool)
    sig
      sInformTheDriverThatNoConnectionWasSetup,
      sStartToTryToSetupASafeRadioConnection,
      sFinalAttemptToSetupTheSafeRadioConnectionFailed,
      sConnecctionLostInAnnouncedRadioHole;
    var
      _L1 : bool;
      _L2 : bool;
      _L3 : bool;
      _L4 : bool;
      _L5 : bool;
    let
      
      automaton Maintaining_SM
        initial state CommunicationSessionNotEstablished
          unless
            if communicationSessionEstablished
              restart CommunicationSessionEstablished;

        state CommunicationSessionEstablished
          sig
            sStart_RadioConnectionLostTimer;
          var
            radioConnectionLostTimer_expired : bool;
            _L2 : bool;
            _L3 : bool;
            _L4 : bool;
            _L5 : time_Type;
            _L6 : time_Type;
            _L7 : bool;
          let
            
            automaton RadioConnection_SM
              initial state SafeRadio_connected
                unless
                  if trainFrontInsideInAnAnnouncedRadioHole and
                  lossOfTheSafeRadioConnection
                    do let
                      emit 'sConnecctionLostInAnnouncedRadioHole;
                    tel restart ConnecctionLostInAnnouncedRadioHole;
                  if lossOfTheSafeRadioConnection and
                  disconnectionHasNotBeenOrdered
                    do let
                      emit 'sStart_RadioConnectionLostTimer;
                      emit 'sStartToTryToSetupASafeRadioConnection;
                    tel restart ConnectionLost;

              state ConnectionLost
                unless
                  if safeRadioConnectionReestablished
                    restart SafeRadio_connected;
                  if radioConnectionLostTimer_expired
                    restart RadioConnectionLostTimerExpired;
                var
                  _L1 : bool;
                let
                  _L1= true;
                  tryToSetupANewSafeRadioConnection= _L1;
                tel

              final state RadioConnectionLostTimerExpired

              state ConnecctionLostInAnnouncedRadioHole
                unless
                  if not trainFrontInsideInAnAnnouncedRadioHole
                    do let
                      emit 'sStart_RadioConnectionLostTimer;
                      emit 'sStartToTryToSetupASafeRadioConnection;
                    tel restart ConnectionLost;
            returns ..;
            radioConnectionLostTimer_expired= _L3;
            _L2= 'sStart_RadioConnectionLostTimer;
            _L3, _L7= #1 Utils::countDownTimer(_L2, _L4, _L5, _L4, _L6);
            _L4= false;
            _L5= actualTime;
            _L6= cRadioConnectionReestablishingTimeout;
            _= _L7;
          tel
          until synchro do let
            emit 'sInformTheDriverThatNoConnectionWasSetup;
            emit 'sFinalAttemptToSetupTheSafeRadioConnectionFailed;
          tel restart CommunicationSessionNotEstablished;
      returns ..;
      _L1= 'sInformTheDriverThatNoConnectionWasSetup;
      informTheDriverThatNoConnectionWasSetup= _L1;
      firstRequestToSetupASafeRadioConnection= _L2;
      finalAttemptToSetupTheSafeRadioConnectionFailed= _L3;
      requestsToSetupTheSafeRadioConnectionStopped= _L4;
      _L2= 'sStartToTryToSetupASafeRadioConnection;
      _L3= 'sFinalAttemptToSetupTheSafeRadioConnectionFailed;
      _L4= _L3 or _L5;
      _L5= 'sConnecctionLostInAnnouncedRadioHole;
    tel
    
    node #pragma kcg doc Subset 096, REQ 3.5.5.2 #end
      #pragma kcg doc Implements the termination of a communication session. #end
      #pragma kcg doc "Remark_1" {Description = "- Name: terminating_a_CommunicationSession - Description: Terminates the communication session.  - Copyright Siemens AG, 2013 - Licensed under the EUPL V.1.1 ( http://joinup.ec.europa.eu/software/page/eupl/licence-eupl ) - Gist URL: --- - Cryptography: No - Author(s): Uwe Steinke  The use of this software is limited to non-vital applications.  It has not been developed for vital operation purposes and must not be used for applications which may cause harm to people, physical accidents or financial loss.  THEREFORE, NO LIABILITY WILL BE GIVEN FOR SUCH AND ANY OHER KIND OF USE."} #end
      terminating_a_CommunicationSession(
        initiateTermination : bool;
        aSessionIsEstablished : bool;
        acknowledgementOfTerminationOfCommunicationSessionReceived : bool;
        aSessionIsCurrentlyBeingEstablished : bool;
        actualTime : time_Type;
        establishingACommunicationSessionAborted : bool)
      returns (
        sendATerminationOfCommunicationMessage : bool;
        requestReleaseOfSafeRadioConnectionWithTrackside : bool;
        ignoreMessagesFromRBC_exceptAckOfTerminationOfCommunicationSession
        : bool
        default = false;
        abortEstablishingACommunicationSession : bool;
        communicationSessionTerminated : bool default = false)
    sig
      sSendATerminationOfCommunicationMessage,
      sRequestReleaseOfSafeRadioConnectionWithTrackside,
      sAbortEstablishingACommunicationSession;
    var
      initiateTerminationOfEstablishedSession : bool;
      considerTheCommunicationSessionTerminated : bool default = false;
      initiateTerminationOfEstablishingSession : bool;
      _L1 : bool;
      _L2 : bool;
      _L3 : bool;
      _L4 : bool;
      _L5 : bool;
      _L6 : bool;
      _L7 : bool;
      _L8 : bool;
      _L9 : bool;
    let
      _L1= initiateTermination;
      _L2= aSessionIsEstablished;
      _L3= _L1 and _L2;
      initiateTerminationOfEstablishedSession= _L3;
      
      automaton TerminateTheCommunicationSession_SM
        initial state Idle
          unless
            if initiateTerminationOfEstablishedSession
              do restart WaitForAcknowledgementMessage;
            if initiateTerminationOfEstablishingSession
              do let
                emit 'sAbortEstablishingACommunicationSession;
              tel restart EstablishingACommunicationSessionAborted;

        state WaitForAcknowledgementMessage
          var
            _L2 : bool;
            _L1 : bool;
            _L3 : time_Type;
            _L4 : bool;
            _L5 : int;
            _L6 : time_Type;
            _L8 : bool;
          let
            _L1, _L2= #1 Utils::waitAndRepeatTimer(_L3, _L4, _L4, _L6, _L5);
            _L3= actualTime;
            _L4= false;
            _L5= cTerminationOfCommunicationSession_MaxNoOfRepetitions;
            _L6= cTerminationOfCommunicationSessionRepetitionInterval;
            emit 'sSendATerminationOfCommunicationMessage if _L1;
            considerTheCommunicationSessionTerminated= _L2;
            ignoreMessagesFromRBC_exceptAckOfTerminationOfCommunicationSession=
              _L8;
            _L8= true;
          tel
          until
            if acknowledgementOfTerminationOfCommunicationSessionReceived or
            considerTheCommunicationSessionTerminated
              do let
                emit 'sRequestReleaseOfSafeRadioConnectionWithTrackside;
              tel restart CommunicationSession_Terminated;

        state CommunicationSession_Terminated
          var
            _L1 : bool;
          let
            communicationSessionTerminated= _L1;
            _L1= true;
          tel

        state EstablishingACommunicationSessionAborted
          until
            if establishingACommunicationSessionAborted
              do let
                emit 'sRequestReleaseOfSafeRadioConnectionWithTrackside;
              tel restart CommunicationSession_Terminated;
      returns ..;
      sendATerminationOfCommunicationMessage= _L4;
      _L4= 'sSendATerminationOfCommunicationMessage;
      _L5= 'sRequestReleaseOfSafeRadioConnectionWithTrackside;
      requestReleaseOfSafeRadioConnectionWithTrackside= _L5;
      _L6= initiateTermination;
      _L7= aSessionIsCurrentlyBeingEstablished;
      _L8= _L6 and _L7;
      initiateTerminationOfEstablishingSession= _L8;
      abortEstablishingACommunicationSession= _L9;
      _L9= 'sAbortEstablishingACommunicationSession;
    tel
    
  end;
  
  package Coder_Pkg
    const cNID_RBC_contactLastKnownRBC : int = 16383;
    
    const cNID_RADIO_useTheShortNumberStoredOnboard : int = 0xFFFFFFFF;
    
    const
      cInvalidOrder : p42e_SessionManagement_T
        = {
            establish:false,
            terminate:false,
            contactLastKnownRBC:false,
            useTheShortNumberStoredOnboard:false,
            establishOrderDoesNotRequestToContactAnAcceptingRBC:false,
            source:Common_Types_Pkg::msrc_undefined,
            q_dir:Q_DIR_Reverse,
            q_rbc:Q_RBC_Terminate_communication_session,
            nid_c:0,
            nid_rbc:0,
            nid_radio:0 };
    
    const
      cEmptyOutPackets : Common_Types_Pkg::outPackets_T
        = {
            p0:{
                valid:false,
                packet0:{
                    NID_PACKET:0,
                    L_PACKET:0,
                    qscale:Q_SCALE_10_cm_scale,
                    NID_LRBG:0,
                    D_LRBG:0,
                    dirlrbg:Q_DIRLRBG_Reverse,
                    dlrbg:Q_DLRBG_Reverse,
                    L_DOUBTOVER:0,
                    L_DOUBTUNDER:0,
                    length:Q_LENGTH_No_train_integrity_information_available,
                    L_TRAININT:0,
                    V_TRAIN:0,
                    dirtrain:Q_DIRTRAIN_Reverse,
                    mode:M_MODE_Full_Supervision,
                    level:M_LEVEL_Level_0,
                    NID_NTC:0 } },
            p1:{
                valid:false,
                packet1:{
                    NID_PACKET:0,
                    L_PACKET:0,
                    qscale:Q_SCALE_10_cm_scale,
                    NID_LRBG:0,
                    NID_PRVLRBG:0,
                    D_LRBG:0,
                    dirlrbg:Q_DIRLRBG_Reverse,
                    dlrbg:Q_DLRBG_Reverse,
                    L_DOUBTOVER:0,
                    L_DOUBTUNDER:0,
                    length:Q_LENGTH_No_train_integrity_information_available,
                    L_TRAININT:0,
                    V_TRAIN:0,
                    dirtrain:Q_DIRTRAIN_Reverse,
                    mode:M_MODE_Full_Supervision,
                    level:M_LEVEL_Level_0,
                    NID_NTC:0 } },
            p3:{
                valid:false,
                number:0,
                aNID_RADIO:[{
                      valid:false,
                      telephoneNumber:[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0] }] },
            p4:{
                valid:false,
                M_ERROR:M_ERROR_Balise_group_linking_consistency_error },
            p5:{ valid:false, TrainRunningNumber:0 },
            p11:{
                valid:false,
                NC_CDTRAIN:NC_CDTRAIN_Cant_Deficiency_80_mm,
                NC_TRAIN:NC_TRAIN_Train_does_not_belong_to_any_of_the_Other_International_Train_Category,
                l_train:0,
                v_maxtrain:0,
                m_loadinggoage:M_LOADINGGAUGE_The_train_does_not_fit_to_any_of_the_interoperable_loading_gauge_profiles,
                m_axleloadcat:M_AXLELOADCAT_A,
                m_airtight:M_AIRTIGHT_Not_fitted,
                n_axle:0,
                nIter_tractionIdentity:0,
                tractionIdentity:[{
                      m_voltage:M_VOLTAGE_Line_not_fitted_with_any_traction_system,
                      nid_ctraction:0 }, {
                      m_voltage:M_VOLTAGE_Line_not_fitted_with_any_traction_system,
                      nid_ctraction:0 }, {
                      m_voltage:M_VOLTAGE_Line_not_fitted_with_any_traction_system,
                      nid_ctraction:0 }],
                nIter_ntc:0,
                nid_ntc:[0, 0, 0] } };
    
    type
      p42e_SessionManagement_T = {
        establish : bool,
        terminate : bool,
        contactLastKnownRBC : bool,
        useTheShortNumberStoredOnboard : bool,
        establishOrderDoesNotRequestToContactAnAcceptingRBC : bool,
        source : Common_Types_Pkg::MsgSource_T,
        q_dir : Q_DIR,
        q_rbc : Q_RBC,
        nid_c : NID_C,
        nid_rbc : NID_RBC,
        nid_radio : NID_RADIO
      };
    
    type
      m159e_sessionEstablished_T = {
        valid : bool,
        p3_onboardPhoneNumbers : NID_RADIO
      };
    
    type
      p42_order_T = {
        source : Common_Types_Pkg::MsgSource_T,
        establishOrderDoesNotRequestToContactAnAcceptingRBC : bool,
        p42 : Packet_Types_Pkg::P42_SessionManagement_T
      };
    
    type
      msgSrc_T = enum {
        msgsrc_balise,
        msgsrc_RBC,
        msgsrc_radioInfillUnit,
        msgsrc_obu
      };
    
    type
      m32e_RBC_or_RIU_System_Version_T = {
        valid : bool,
        version : M_VERSION,
        systemVersionFromTracksideSupported : bool
      };
    
    function P42_Dec(P42_in : p42_order_T; onboardEquipmentIsSleeping : bool)
      returns (P42_out : p42e_SessionManagement_T)
    var
      _L1 : p42_order_T;
      _L15 : Q_SLEEPSESSION;
      _L14 : NID_RADIO;
      _L13 : NID_RBC;
      _L12 : NID_C;
      _L11 : Q_RBC;
      _L10 : Q_DIR;
      _L9 : bool;
      _L16 : bool;
      _L17 : bool;
      _L19 : Q_SLEEPSESSION;
      _L20 : bool;
      _L21 : bool;
      _L22 : bool;
      _L23 : bool;
      _L24 : Q_RBC;
      _L25 : Q_RBC;
      _L28 : bool;
      _L29 : bool;
      _L30 : bool;
      _L31 : bool;
      _L32 : int;
      _L33 : bool;
      _L34 : p42e_SessionManagement_T;
      _L35 : bool;
      _L36 : Packet_Types_Pkg::P42_SessionManagement_T;
      _L37 : Common_Types_Pkg::MsgSource_T;
      _L38 : int;
      _L39 : bool;
      _L41 : bool;
    let
      _L1= P42_in;
      _L9, _L10, _L11, _L12, _L13, _L14, _L15=
        (flatten Packet_Types_Pkg::P42_SessionManagement_T)(_L36);
      _L16= onboardEquipmentIsSleeping;
      _L17= _L9 and _L20 and _L16;
      _L19= Q_SLEEPSESSION_Execute_session_establishment_order;
      _L20= _L15 = _L19;
      _L21= _L17 or _L23;
      _L22= not _L16;
      _L23= _L9 and _L22;
      _L24= Q_RBC_Terminate_communication_session;
      _L25= Q_RBC_Establish_communication_session;
      _L28= _L24 = _L11;
      _L29= _L11 = _L25;
      _L30= _L28 and _L21;
      _L31= _L29 and _L21;
      _L32= cNID_RBC_contactLastKnownRBC;
      _L33= _L13 = _L32;
      _L34=
        (make p42e_SessionManagement_T)(_L31, _L30, _L35, _L39, _L41, _L37,
          _L10, _L11, _L12, _L13, _L14);
      P42_out= _L34;
      _L35= _L31 and _L33;
      _L36= _L1.p42;
      _L37= _L1.source;
      _L38= cNID_RADIO_useTheShortNumberStoredOnboard;
      _L39= _L38 = _L14;
      _L41= _L1.establishOrderDoesNotRequestToContactAnAcceptingRBC;
    tel
    
    function genMsgToRBC(
        present : bool;
        nid_message : NID_MESSAGE;
        t_train : T_TRAIN;
        nid_engine : NID_ENGINE)
      returns (radioMessage : Radio_Types_Pkg::Radio_TrainTrack_Message_T)
    var
      _L2 : Radio_Types_Pkg::Radio_TrainTrack_Message_T;
      _L1 : Radio_Types_Pkg::Radio_TrainTrack_Header_T;
      _L3 : bool;
      _L4 : NID_MESSAGE;
      _L5 : T_TRAIN;
      _L6 : NID_ENGINE;
      _L7 : Common_Types_Pkg::outPackets_T;
      _L8 : Q_MARQSTREASON;
    let
      _L1=
        (make Radio_Types_Pkg::Radio_TrainTrack_Header_T)(_L3, _L4, _L5, _L6,
          _L8, _L5);
      _L2= (make Radio_Types_Pkg::Radio_TrainTrack_Message_T)(_L3, _L1, _L7);
      radioMessage= _L2;
      _L3= present;
      _L4= nid_message;
      _L5= t_train;
      _L6= nid_engine;
      _L7= cEmptyOutPackets;
      _L8= Q_MARQSTREASON_Start_selected_by_driver;
    tel
    
  end;
  
  const cP3_OnboardPhoneNumbers : NID_RADIO = 0;
  
  const
    cEstablishSafeRadioConnectionCmd : mobileSWCmd_Type
      = { valid:true, action:mswa_establishRadioConnection, radioNetworkID:0 };
  
  const
    cEstablishOrderFromTrackside : orderToContactAnRBC_Type
      = {
          valid:true,
          rbc_id:0,
          telephoneNoOfTheRBC:0,
          actionToBePerformed:morc_rbca_establishSession,
          appliesAlsoToSleepingUnits:false };
  
  const cConnectionStatusTimerInterval : time_Type = 15000;
  
  const
    cInvalidmobileHWCmd : mobileHWCmd_Type
      = { valid:false, action:mhwa_nop, radioNetworkID:0, nid_radio:0 };
  
  const
    cInvalidMobileHWStatus : mobileHWStatus_Type
      = {
          valid:false,
          connectionStatus:mhwc_notRegistered,
          settingUpConnectionHasFailed:false,
          connectionLost:false };
  
  const cMaxNoOfConnectionRetries : int = 3;
  
  const cInvalidRadioNetworkID_value : NID_MN = 0;
  
  const
    cInvalidRadioNetworkID : Packet_Types_Pkg::P45_RadioNetworkRegistration_T
      = { valid:false, q_dir:Q_DIR_Reverse, nid_mn:0 };
  
  const
    cInvalidOrderToContactAnRBC : orderToContactAnRBC_Type
      = {
          valid:false,
          rbc_id:0,
          telephoneNoOfTheRBC:0,
          actionToBePerformed:morc_rbca_noAction,
          appliesAlsoToSleepingUnits:false };
  
  const
    cInvalidMobileSWStatus : mobileSWStatus_Type
      = {
          valid:false,
          mobileHW_available:false,
          connectionStatus:mswc_unregistered,
          registeredRadioNetworkID:0,
          settingUpConnectionHasFailed:false };
  
  const
    cInvalidMobileSWCmd : mobileSWCmd_Type
      = { valid:false, action:mswa_nop, radioNetworkID:0 };
  
  const
    cMobileSWStatus_unregistered : mobileSWStatus_Type
      = {
          valid:true,
          mobileHW_available:true,
          connectionStatus:mswc_unregistered,
          registeredRadioNetworkID:0,
          settingUpConnectionHasFailed:false };
  
  const
    cMobileSWStatus_noHW : mobileSWStatus_Type
      = {
          valid:true,
          mobileHW_available:false,
          connectionStatus:mswc_unregistered,
          registeredRadioNetworkID:0,
          settingUpConnectionHasFailed:false };
  
  const
    cMobileHWStatus_Registered : mobileHWStatus_Type
      = {
          valid:true,
          connectionStatus:mhwc_registered,
          settingUpConnectionHasFailed:false,
          connectionLost:false };
  
  const
    cMobileHWStatus_notRegistered : mobileHWStatus_Type
      = {
          valid:true,
          connectionStatus:mhwc_notRegistered,
          settingUpConnectionHasFailed:false,
          connectionLost:false };
  
  const
    cMobileHWStatus_Disconnected : mobileHWStatus_Type
      = {
          valid:true,
          connectionStatus:mhwc_notRegistered,
          settingUpConnectionHasFailed:false,
          connectionLost:false };
  
  const
    cMobileHWStatus_Connected : mobileHWStatus_Type
      = {
          valid:true,
          connectionStatus:mhwc_connected,
          settingUpConnectionHasFailed:false,
          connectionLost:false };
  
  const cNID_RBC_ContactLastKnownRBC : NID_RBC_Type = 16383;
  
  const cNID_RADIO_useTheShortNumberStoredOnboard : NID_RADIO_Type = 4294967295;
  
  const cNID_PACKET_42 : int = 42;
  
  const cNID_PACKET_131 : int = 131;
  
  const
    cNID_MESSAGE_terminationOfACommunicationSession : NID_MESSAGE_Type = 156;
  
  const cNID_MESSAGE_SessionEstablished : NID_MESSAGE_Type = 159;
  
  const cNID_MESSAGE_registerNetwork : NID_MESSAGE_Type = 45;
  
  const cNID_MESSAGE_RBC_RIU_SystemVersion : NID_MESSAGE_Type = 32;
  
  const cNID_MESSAGE_noMessage : NID_MESSAGE_Type = 255;
  
  const cNID_MESSAGE_NoCompatibleVersionSupported : NID_MESSAGE_Type = 154;
  
  const
    cNID_MESSAGE_InitiationOfACommunicationSession_track : NID_MESSAGE_Type
      = 38;
  
  const cNID_MESSAGE_InitiationOfACommunicationSession : NID_MESSAGE_Type = 155;
  
  const cNID_MESSAGE_GeneralMessage_init : NID_MESSAGE_Type = 25;
  
  const cNID_MESSAGE_GeneralMessage : NID_MESSAGE_Type = 24;
  
  const
    cNID_MESSAGE_AckOfTerminationOfACommunicationSession : NID_MESSAGE_Type
      = 39;
  
  const cNID_LRBG_Unknown : NID_LRBG_Type = 16777215;
  
  const cTime_0 : time_Type = 0;
  
  const cTerminationOfCommunicationSessionRepetitionInterval : time_Type = 1000;
  
  const cTerminationOfCommunicationSession_MaxNoOfRepetitions : int = 5;
  
  const
    cTerminateSafeRadioConnectionCmd : mobileSWCmd_Type
      = { valid:true, action:mswa_terminateRadioConnection, radioNetworkID:0 };
  
  const
    cTerminateOrderFromTrackside : orderToContactAnRBC_Type
      = {
          valid:true,
          rbc_id:0,
          telephoneNoOfTheRBC:0,
          actionToBePerformed:morc_rbca_terminateSesssion,
          appliesAlsoToSleepingUnits:false };
  
  const
    cSampleRadioNetworkID : validRadioNetworkID_Type
      = { valid:true, radioNetworkID:0 };
  
  const
    cRegisterSafeRadioConnectionCmd : mobileSWCmd_Type
      = { valid:true, action:mswa_register, radioNetworkID:0 };
  
  const cRBC_phoneNo_UseOnboardStoredShortNo : rbc_phoneNo_Type = -1;
  
  const cRBC_id_contactLastKnownRBC : rbc_id_Type = -1;
  
  const cRadioConnectionReestablishingTimeout : time_Type = 10000;
  
  const cPositionReportRepetitionInterval : time_Type = 10000;
  
  const cPositionReoport_MaxNoOfRepetitions : int = 5;
  
  const
    cNoMessageToRBC : Radio_Types_Pkg::Radio_TrainTrack_Message_T
      = {
          present:false,
          header:{
              present:false,
              nid_message:0,
              t_train:0.0,
              nid_engine:0,
              xQ_MARQSTREASON:Q_MARQSTREASON_Start_selected_by_driver,
              xT_TRAIN:0.0 },
          packets:{
              p0:{
                  valid:false,
                  packet0:{
                      NID_PACKET:0,
                      L_PACKET:0,
                      qscale:Q_SCALE_10_cm_scale,
                      NID_LRBG:0,
                      D_LRBG:0,
                      dirlrbg:Q_DIRLRBG_Reverse,
                      dlrbg:Q_DLRBG_Reverse,
                      L_DOUBTOVER:0,
                      L_DOUBTUNDER:0,
                      length:Q_LENGTH_No_train_integrity_information_available,
                      L_TRAININT:0,
                      V_TRAIN:0,
                      dirtrain:Q_DIRTRAIN_Reverse,
                      mode:M_MODE_Full_Supervision,
                      level:M_LEVEL_Level_0,
                      NID_NTC:0 } },
              p1:{
                  valid:false,
                  packet1:{
                      NID_PACKET:0,
                      L_PACKET:0,
                      qscale:Q_SCALE_10_cm_scale,
                      NID_LRBG:0,
                      NID_PRVLRBG:0,
                      D_LRBG:0,
                      dirlrbg:Q_DIRLRBG_Reverse,
                      dlrbg:Q_DLRBG_Reverse,
                      L_DOUBTOVER:0,
                      L_DOUBTUNDER:0,
                      length:Q_LENGTH_No_train_integrity_information_available,
                      L_TRAININT:0,
                      V_TRAIN:0,
                      dirtrain:Q_DIRTRAIN_Reverse,
                      mode:M_MODE_Full_Supervision,
                      level:M_LEVEL_Level_0,
                      NID_NTC:0 } },
              p3:{
                  valid:false,
                  number:0,
                  aNID_RADIO:[{
                        valid:false,
                        telephoneNumber:[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                          0, 0] }] },
              p4:{
                  valid:false,
                  M_ERROR:M_ERROR_Balise_group_linking_consistency_error },
              p5:{ valid:false, TrainRunningNumber:0 },
              p11:{
                  valid:false,
                  NC_CDTRAIN:NC_CDTRAIN_Cant_Deficiency_80_mm,
                  NC_TRAIN:NC_TRAIN_Train_does_not_belong_to_any_of_the_Other_International_Train_Category,
                  l_train:0,
                  v_maxtrain:0,
                  m_loadinggoage:M_LOADINGGAUGE_The_train_does_not_fit_to_any_of_the_interoperable_loading_gauge_profiles,
                  m_axleloadcat:M_AXLELOADCAT_A,
                  m_airtight:M_AIRTIGHT_Not_fitted,
                  n_axle:0,
                  nIter_tractionIdentity:0,
                  tractionIdentity:[{
                        m_voltage:M_VOLTAGE_Line_not_fitted_with_any_traction_system,
                        nid_ctraction:0 }, {
                        m_voltage:M_VOLTAGE_Line_not_fitted_with_any_traction_system,
                        nid_ctraction:0 }, {
                        m_voltage:M_VOLTAGE_Line_not_fitted_with_any_traction_system,
                        nid_ctraction:0 }],
                  nIter_ntc:0,
                  nid_ntc:[0, 0, 0] } } };
  
  type
    radioNetWorkIDs_T = {
      defaultID : Packet_Types_Pkg::P45_RadioNetworkRegistration_T,
      memorizedID : Packet_Types_Pkg::P45_RadioNetworkRegistration_T,
      ID_fromDriver : Packet_Types_Pkg::P45_RadioNetworkRegistration_T
    };
  
  type
    obuEventsAndPhases_T = {
      atPowerDown : bool,
      atPowerUp : bool,
      atStartOfMission : bool,
      startOfMissionProcedureIsGoingOn : bool,
      startOfMissionProcedureCompleted : bool,
      trainIsRejectedByRBC_duringStartOfMission : bool,
      endOfMissionIsExecuted : bool,
      driverClosesTheDeskduringStartOfMission : bool,
      driverHasManuallyChangedLevel : bool,
      afterDriverEntryOfANewRadioNetworkID : bool,
      triggerDecisionThatNoRadioNetworkIDAvailable : bool,
      isPartOfAnOngoingStartOfMissionProcedure : bool,
      trainPassesALevelTransitionBorder : bool,
      trainPassesA_RBC_RBC_border_WithItsFrontEnd : bool,
      trainExitedFromAnRBCArea : bool,
      modeChangeHasToBeReportedToRBC : bool,
      trainFrontInsideInAnAnnouncedRadioHole : bool,
      trainFrontReachesEndOfAnnouncedRadioHole : bool,
      OBU_hasToEstablishANewSession : bool,
      isInCommunicationSessionWithAnRIU : bool,
      errorConditionRequiringTerminationDetected : bool
    };
  
  type
    m39_acknowledgementOfTerminationOfACommunicationSession_Type = {
      valid : bool,
      NID_MESSAGE : NID_MESSAGE_Type,
      T_TRAIN : T_TRAIN_Type,
      M_ACK : M_ACK_Type,
      NID_LRBG : NID_LRBG_Type
    };
  
  type
    m38_initiationOfACommunicationSession_Type = {
      valid : bool,
      NID_MESSAGE : NID_MESSAGE_Type,
      T_TRAIN : T_TRAIN_Type,
      M_ACK : M_ACK_Type,
      NID_LRBG : NID_LRBG_Type
    };
  
  type
    m32_RBC_RIU_systemVersion_Type = {
      valid : bool,
      NID_MESSAGE : NID_MESSAGE_Type,
      T_TRAIN : T_TRAIN,
      M_ACK : M_ACK_Type,
      NID_LRBG : NID_LRBG_Type,
      M_VERSION : M_VERSION_Type
    };
  
  type
    m24_generalMessage_Type = {
      valid : bool,
      NID_MESSAGE : NID_MESSAGE_Type,
      T_TRAIN : T_TRAIN,
      M_ACK : M_ACK_Type,
      NID_LRBG : NID_LRBG_Type
    };
  
  type
    m159_SessionEstablished_Type = {
      valid : bool,
      NID_MESSAGE : NID_MESSAGE_Type,
      T_TRAIN : T_TRAIN,
      NID_ENGINE : NID_ENGINE_Type,
      NID_RADIO : NID_RADIO_Type
    };
  
  type
    m156_terminationOfACommunicationSession_Type = {
      valid : bool,
      NID_MESSAGE : NID_MESSAGE_Type,
      T_TRAIN : T_TRAIN,
      NID_ENGINE : NID_ENGINE_Type
    };
  
  type
    m155_initiationOfACommunicationSession_Type = {
      valid : bool,
      NID_MESSAGE : NID_MESSAGE_Type,
      T_TRAIN : T_TRAIN,
      NID_ENGINE : NID_ENGINE_Type
    };
  
  type
    m154_NoCompatibleVersionSupported_Type = {
      valid : bool,
      NID_MESSAGE : NID_MESSAGE_Type,
      T_TRAIN : T_TRAIN,
      NID_ENGINE : NID_ENGINE_Type
    };
  
  type D_RBCTR_Type = int;
  
  type M_ACK_Type = enum { M_ACK_NoAckRequired, M_ACK_AckRequired };
  
  type M_VERSION_Type = { firstNumber : int, secondNumber : int };
  
  type
    M_MODE_Type = enum {
      ETCS_Mode_FullSupervision,
      ETCS_Mode_OnSight,
      ETCS_Mode_StaffResponsible,
      ETCS_Mode_Shunting,
      ETCS_Mode_Unfitted,
      ETCS_Mode_Sleeping,
      ETCS_Mode_StandBy,
      ETCS_Mode_Trip,
      ETCS_Mode_PostTrip,
      ETCS_Mode_SystemFailure,
      ETCS_Mode_Isolation,
      ETCS_Mode_NonLeading,
      ETCS_Mode_LimitedSupervision,
      ETCS_Mode_NationalSystem,
      ETCS_Mode_Reversing,
      ETCS_Mode_PassiveShunting,
      ETCS_Mode_EndOfMission
    };
  
  type
    M_LEVEL_Type = enum {
      ETCS_Level_0,
      ETCS_Level_NTC,
      ETCS_Level_1,
      ETCS_Level_2,
      ETCS_Level_3
    };
  
  type
    mobileHWAction_Type = enum {
      mhwa_nop,
      mhwa_register,
      mhwa_connect,
      mhwa_disconnect,
      mhwa_unregister
    };
  
  type
    mobileHWCmd_Type = {
      valid : bool,
      action : mobileHWAction_Type,
      radioNetworkID : NID_MN,
      nid_radio : NID_RADIO
    };
  
  type
    mobileHWConnectionStatus_Type = enum {
      mhwc_notRegistered,
      mhwc_registered,
      mhwc_connecting,
      mhwc_connected,
      mhwc_registering
    };
  
  type
    mobileHWStatus_Type = {
      valid : bool,
      connectionStatus : mobileHWConnectionStatus_Type,
      settingUpConnectionHasFailed : bool,
      connectionLost : bool
    };
  
  type
    mobileSWAction_Type = enum {
      mswa_nop,
      mswa_register,
      mswa_connect,
      mswa_establishRadioConnection,
      mswa_terminateRadioConnection,
      mswa_disconnect,
      mswa_unregister
    };
  
  type
    mobileSWCmd_Type = {
      valid : bool,
      action : mobileSWAction_Type,
      radioNetworkID : NID_MN
    };
  
  type
    mobileSWConnectionStatus_Type = enum {
      mswc_unregistered,
      mswc_registering,
      mswc_registered,
      mswc_connecting,
      mswc_connected,
      mswc_establishingSession,
      mswc_sessionEstablished
    };
  
  type
    mobileSWStatus_Type = {
      valid : bool,
      mobileHW_available : bool,
      connectionStatus : mobileSWConnectionStatus_Type,
      registeredRadioNetworkID : NID_MN,
      settingUpConnectionHasFailed : bool
    };
  
  type
    morc_RBC_action_Type = enum {
      morc_rbca_noAction,
      morc_rbca_establishSession,
      morc_rbca_terminateSesssion
    };
  
  type NID_LRBG_Type = int;
  
  type NID_ENGINE_Type = int;
  
  type NID_C_Type = int;
  
  type NID_MESSAGE_Type = int;
  
  type NID_RADIO_Type = int;
  
  type NID_RBC_Type = int;
  
  type
    onBoardOrder_Type = enum {
      obo_noOrder,
      obo_initiateCommunication,
      obo_terminateCommunication,
      obo_registerNetwork
    };
  
  type
    orderToContactAnAcceptingRBC_Type = {
      valid : bool,
      rbc_id : rbc_id_Type,
      telephoneNoOfTheRBC : rbc_phoneNo_Type,
      appliesAlsoToSleepingUnits : bool
    };
  
  type
    orderToContactAnRBC_Type = {
      valid : bool,
      rbc_id : rbc_id_Type,
      telephoneNoOfTheRBC : rbc_phoneNo_Type,
      actionToBePerformed : morc_RBC_action_Type,
      appliesAlsoToSleepingUnits : bool
    };
  
  type
    p42_SessionManagement_Type = {
      valid : bool,
      NID_PACKET : NID_PACKET_Type,
      Q_DIR : Q_DIR_Type,
      L_PACKET : int,
      Q_RBC : Q_RBC_Type,
      NID_C : NID_C_Type,
      NID_RBC : NID_RBC_Type,
      NID_RADIO : NID_RADIO_Type,
      Q_SLEEPSESSION : Q_SLEEPSESSION_Type
    };
  
  type
    p131_RBC_TransitionOrderType = {
      valid : bool,
      NID_PACKET : NID_PACKET_Type,
      Q_DIR : Q_DIR_Type,
      L_PACKET : int,
      D_RBCTR : D_RBCTR_Type,
      NID_C : NID_C_Type,
      NID_RBC : NID_RBC_Type,
      NID_RADIO : NID_RADIO_Type,
      Q_SLEEPSESSION : Q_SLEEPSESSION_Type
    };
  
  type
    orderToContactARadioInfillUnit_Type = {
      valid : bool,
      radioInFillUnit_id : rbc_id_Type,
      telephoneNoOfTheRadioInfillUnit : rbc_phoneNo_Type,
      actionToBePerformed : morc_RBC_action_Type
    };
  
  type
    Q_DIR_Type = enum {
      q_dir_reverse,
      q_dir_nominal,
      q_dir_bothDirections,
      q_dir_spare
    };
  
  type
    Q_RBC_Type = enum {
      q_rbc_terminateCommunicationSession,
      q_rbc_establishCommunicationSession
    };
  
  type
    Q_SLEEPSESSION_Type = enum {
      q_sleepsession_ignoreSessionEstablishmentOrder,
      q_sleepsession_executeSessionEstablishmentOrder
    };
  
  type radioHoleStatus_Type = enum { rhs_none, rhs_end, rhs_begin, rhs_inside };
  
  type radioNetworkID_Type = NID_MN;
  
  type
    RadioNetworkMobileHWStatusType = {
      valid : bool,
      connectionStatus : mobileHWConnectionStatus_Type
    };
  
  type rbc_id_Type = int;
  
  type rbc_phoneNo_Type = int;
  
  type
    rbc_TransitionOrder_Type = {
      valid : bool,
      orderToContactAnAcceptingRBC : orderToContactAnAcceptingRBC_Type
    };
  
  type
    safeRadioConnectionStatus_Type = enum {
      srcs_NoConnection,
      srcs_ConnectionLost_SetupFailed,
      srcs_ConnectionUp
    };
  
  type
    safeRadioConnectionStatusValid_Type = {
      valid : bool,
      status : safeRadioConnectionStatus_Type
    };
  
  type NID_PACKET_Type = int;
  
  type
    sessionStatus_Type = enum {
      morc_st_inactive,
      morc_st_establishing,
      morc_st_maintaining,
      morc_st_terminating
    };
  
  type T_TRAIN_Type = int;
  
  type time_Type = int;
  
  type validRadioNetworkID_Type = { valid : bool, radioNetworkID : NID_MN };
  
  type
    train_2_track_Type = {
      m155_initiationOfACommunicationSession : m155_initiationOfACommunicationSession_Type,
      m156_terminationOfACommunicationSession : m156_terminationOfACommunicationSession_Type,
      m159_SessionEstablished : m159_SessionEstablished_Type,
      m154_NoCompatibleVersionSupported : m154_NoCompatibleVersionSupported_Type
    };
  
  type
    track_2_train_Type = {
      m24_generalMessage : m24_generalMessage_Type,
      m32_RBC_RIU_systemVersion : m32_RBC_RIU_systemVersion_Type,
      m38_initiationOfACommunicationSession : m38_initiationOfACommunicationSession_Type,
      m39_acknowledgementOfTerminationOfACommunicationSession : m39_acknowledgementOfTerminationOfACommunicationSession_Type,
      p131_RBC_TransitionOrder : p131_RBC_TransitionOrderType,
      p42_sessionManagement : p42_SessionManagement_Type
    };
  
  node private #pragma kcg doc Subset 096, REQ 3.5 #end
    #pragma kcg doc This is the top level node of the "Management of Radio Communication" function. #end
    #pragma kcg doc "Remark_1" {Description = "- Name: managementOfRadioCommunication - Description: This is the top level node of the "Management of Radio Communication" function - Copyright Siemens AG, 2013 - Licensed under the EUPL V.1.1 ( http://joinup.ec.europa.eu/software/page/eupl/licence-eupl ) - Gist URL: --- - Cryptography: No - Author(s): Uwe Steinke  The use of this software is limited to non-vital applications.  It has not been developed for vital operation purposes and must not be used for applications which may cause harm to people, physical accidents or financial loss.  THEREFORE, NO LIABILITY WILL BE GIVEN FOR SUCH AND ANY OHER KIND OF USE."} #end
    managementOfRadioCommunication(
      currentTime : time_Type;
      acknowledgementOfTerminationOfCommunicationSessionReceived : bool;
      orderReceivedFromTrackside : Coder_Pkg::p42e_SessionManagement_T;
      establishOrderReceivedFromRBC : bool;
      establishOrderReceivedFromRadioInfillUnit : bool;
      errorConditionRequiringTerminationDetected : bool;
      trainIsRejectedByRBC_duringStartOfMission : bool;
      driverClosesTheDeskduringStartOfMission : bool;
      trainExitedFromAnRBCArea : bool;
      endOfMissionIsExecuted : bool;
      isInCommunicationSessionWithAnRIU : bool;
      atPowerUp : bool;
      atPowerDown : bool;
      level : M_LEVEL;
      RadioNetworkID_memorized
      : Packet_Types_Pkg::P45_RadioNetworkRegistration_T;
      RadioNetworkID_fromDriver
      : Packet_Types_Pkg::P45_RadioNetworkRegistration_T;
      RadioNetworkID_fromTrackside
      : Packet_Types_Pkg::P45_RadioNetworkRegistration_T;
      afterDriverEntryOfANewRadioNetworkID : bool;
      triggerDecisionThatNoRadioNetworkIDAvailable : bool;
      mobileHWStatus : mobileHWStatus_Type;
      isPartOfAnOngoingStartOfMissionProcedure : bool;
      trainPassesALevelTransitionBorder : bool;
      orderToEstablishACommunicationSession_fromOBU
      : Coder_Pkg::p42e_SessionManagement_T;
      orderDoesNotRequestToContactAnAcceptingRBC : bool;
      trainPassesA_RBC_RBC_border_WithItsFrontEnd : bool;
      systemVersionFromTracksideSupported : bool;
      systemVersionReceived : bool;
      mode : M_MODE;
      atStartOfMission : bool;
      modeChangeHasToBeReportedToRBC : bool;
      driverHasManuallyChangedLevel : bool;
      trainFrontReachesEndOfAnnouncedRadioHole : bool;
      startOfMissionProcedureCompleted : bool;
      trainFrontInsideInAnAnnouncedRadioHole : bool;
      OBU_hasToEstablishANewSession : bool;
      startOfMissionProcedureIsGoingOn : bool;
      m38_initiationOfACommunicationSession : bool;
      RadioNetworkID_Default : Packet_Types_Pkg::P45_RadioNetworkRegistration_T;
      connectionStatusTimerInterval : time_Type)
    returns (
      sendAPositionReport : bool;
      mobileHWCmd : mobileHWCmd_Type;
      memorizeTheLastRadioNetworkID : bool;
      currentRadioNetworkID : Packet_Types_Pkg::P45_RadioNetworkRegistration_T;
      orderTheRegistrationOfItsConnectedMobiles : bool;
      rejectOrderToContactRBC_or_RIU : bool;
      InformTheDriverThatNoConnectionWasSetup : bool default = false;
      sendTheMessageInitiationOfCommunicationSessionToTrackside
      : bool
      default = false;
      sendMessage_NoCompatibleVersionSupported : bool default = false;
      sendASessionEstablishedReportToTrackside : bool default = false;
      sendATerminationOfCommunicationMessage : bool default = false;
      ignoreMessagesFromRBC_except_m39_AckOfTerminationOfCommunicationSession
      : bool
      default = false;
      safeRadioConnectionStatus_toDriver : safeRadioConnectionStatusValid_Type;
      sessionSuccessfullyEstablished : bool last = false;
      mobileSWStatus : mobileSWStatus_Type;
      requestTheSetupOfASafeRadioConnection : bool default = false;
      requestReleaseOfSafeRadioConnectionWithTrackside : bool default = false;
      sessionStatus : Radio_Types_Pkg::sessionStatus_Type;
      ready : bool)
  sig
    notReady;
  var
    sessionEstablished : bool last = false;
    startTerminatingSession : bool default = false;
    sessionTerminated : bool default = false;
    startEstablishingSession : bool;
    communicationSessionInitiatedByOBU : bool last = false;
    communicationSessionInitiatedFromTrackside : bool last = false;
    sessionStatus_loc
    : Radio_Types_Pkg::sessionStatus_Type
    last = Radio_Types_Pkg::morc_st_inactive;
    initiateTermination : bool;
    establishingACommunicationSessionAborted : bool last = false;
    requestTheSetupOfASafeRadioConnection_loc : bool default = false;
    requestsToSetupTheSafeRadioConnectionStopped : bool default = false;
    mobileSWStatus_loc : mobileSWStatus_Type last = cInvalidMobileSWStatus;
    prevSessionTerminatedDueToLossOfSafeRadioConnection : bool;
    initiateEstablishingNewSession : bool;
    finalAttemptToSetupTheSafeRadioConnectionFailed : bool last = false;
    mobileSWCmd : mobileSWCmd_Type default = cInvalidMobileSWCmd;
    orderReceivedFromTrackside_loc : Coder_Pkg::p42e_SessionManagement_T;
    firstRequestToSetupASafeRadioConnection : bool default = false;
    _L6 : mobileSWStatus_Type;
    _L5 : mobileHWCmd_Type;
    _L4 : bool;
    _L3 : Packet_Types_Pkg::P45_RadioNetworkRegistration_T;
    _L2 : bool;
    _L1 : bool;
    _L7 : safeRadioConnectionStatusValid_Type;
    _L20 : time_Type;
    _L18 : bool;
    _L19 : bool;
    _L21 : Coder_Pkg::p42e_SessionManagement_T;
    _L22 : bool;
    _L23 : bool;
    _L24 : bool;
    _L25 : bool;
    _L27 : bool;
    _L28 : bool;
    _L29 : bool;
    _L30 : bool;
    _L31 : M_LEVEL;
    _L44 : Packet_Types_Pkg::P45_RadioNetworkRegistration_T;
    _L45 : Packet_Types_Pkg::P45_RadioNetworkRegistration_T;
    _L46 : Packet_Types_Pkg::P45_RadioNetworkRegistration_T;
    _L47 : Packet_Types_Pkg::P45_RadioNetworkRegistration_T;
    _L48 : bool;
    _L49 : bool;
    _L50 : mobileHWStatus_Type;
    _L51 : bool;
    _L52 : bool;
    _L53 : M_LEVEL;
    _L54 : M_LEVEL;
    _L55 : bool;
    _L56 : bool;
    _L59 : Coder_Pkg::p42e_SessionManagement_T;
    _L58 : bool;
    _L57 : bool;
    _L60 : Radio_Types_Pkg::sessionStatus_Type;
    _L61 : bool;
    _L63 : bool;
    _L64 : mobileSWCmd_Type;
    _L65 : bool;
    _L66 : bool;
    _L67 : time_Type;
    _L68 : time_Type;
    _L69 : bool;
    _L70 : bool;
    _L71 : bool;
    _L72 : mobileSWStatus_Type;
    _L73 : bool;
    _L74 : bool;
    _L75 : mobileSWConnectionStatus_Type;
    _L80 : mobileSWConnectionStatus_Type;
    _L83 : mobileSWConnectionStatus_Type;
    _L85 : bool;
    _L86 : bool;
    _L87 : bool;
    _L88 : bool;
    _L89 : bool;
    _L90 : bool;
    _L91 : bool;
    _L92 : bool;
    _L93 : bool;
    _L94 : bool;
    _L95 : bool;
    _L96 : bool;
    _L97 : bool;
    _L98 : mobileSWStatus_Type;
    _L99 : bool;
    _L100 : Radio_Types_Pkg::sessionStatus_Type;
    _L101 : bool;
    _L107 : bool;
    _L108 : bool;
    _L109 : bool;
    _L110 : bool;
    _L111 : mobileSWStatus_Type;
    _L112 : bool;
    _L113 : Radio_Types_Pkg::sessionStatus_Type;
    _L114 : bool;
    _L115 : bool;
    _L116 : bool;
    _L117 : Radio_Types_Pkg::sessionStatus_Type;
  let
    
    automaton CommunicationSession_SM
      initial state NoSession
        var
          _L5 : bool;
          _L6 : bool;
          _L7 : bool;
          _L12 : M_LEVEL;
          _L13 : M_MODE;
          _L30 : Coder_Pkg::p42e_SessionManagement_T;
          _L39 : bool;
          _L40 : bool;
          _L42 : bool;
          _L43 : bool;
          _L44 : bool;
          _L45 : bool;
          _L46 : bool;
          _L47 : bool;
          _L48 : bool;
          _L49 : bool;
          _L50 : bool;
          _L52 : bool;
          _L53 : bool;
          _L54 : bool;
          _L11 : Radio_Types_Pkg::sessionStatus_Type;
        let
          _L5, _L6, _L7=
            #1 Subfunc_Pkg::initiate_a_Session(_L53, _L39, _L40, _L54, _L12,
              _L43, _L42, _L13, _L46, _L47, _L48, _L45, _L49, _L44, _L50);
          startEstablishingSession= _L5;
          communicationSessionInitiatedByOBU= _L6;
          communicationSessionInitiatedFromTrackside= _L7;
          sessionStatus_loc= _L11;
          _L12= level;
          _L13= mode;
          _L30= orderToEstablishACommunicationSession_fromOBU;
          _L39= establishOrderReceivedFromRBC;
          _L40= establishOrderReceivedFromRadioInfillUnit;
          _L42= _L39 or _L40 or _L54;
          _L43= atStartOfMission;
          _L44= true;
          _L45= prevSessionTerminatedDueToLossOfSafeRadioConnection;
          _L46= modeChangeHasToBeReportedToRBC;
          _L47= driverHasManuallyChangedLevel;
          _L48= trainFrontReachesEndOfAnnouncedRadioHole;
          _L49= startOfMissionProcedureCompleted;
          _L50= initiateEstablishingNewSession;
          sessionSuccessfullyEstablished= _L52;
          sessionEstablished= _L52;
          _L52= false;
          _L53= _L30.establish;
          _L54= m38_initiationOfACommunicationSession;
          _L11= Radio_Types_Pkg::morc_st_inactive;
        tel
        until
          if startEstablishingSession
            do let emit 'notReady; tel restart Establishing;

      state Establishing
        var
          _L28 : bool;
          _L27 : bool;
          _L26 : bool;
          _L25 : bool;
          _L24 : bool;
          _L23 : bool;
          _L21 : bool;
          _L20 : bool;
          _L19 : bool;
          _L31 : bool;
          _L32 : bool;
          _L33 : bool;
          _L35 : bool;
          _L37 : bool;
          _L38 : bool;
          _L39 : mobileSWConnectionStatus_Type;
          _L40 : bool;
          _L41 : mobileSWConnectionStatus_Type;
          _L42 : bool;
          _L44 : mobileSWStatus_Type;
          _L45 : bool;
          _L46 : bool;
          _L47 : bool;
          _L49 : Coder_Pkg::p42e_SessionManagement_T;
          _L50 : bool;
          _L51 : bool;
          _L52 : bool;
          _L53 : bool;
          _L55 : Coder_Pkg::p42e_SessionManagement_T;
          _L56 : bool;
          _L34 : Radio_Types_Pkg::sessionStatus_Type;
        let
          _L19, _L20, _L21, _L23, _L24, _L25, _L26, _L27, _L28, _L31, _L35=
            #2 Subfunc_Pkg::establish_a_Session(_L37, _L42, _L45, _L46, _L47,
              _L55, _L49, _L50, _L51, _L52, _L53, _L56, _L32, _L33);
          sessionEstablished= _L31;
          startTerminatingSession= _L24;
          _L32= last 'communicationSessionInitiatedByOBU;
          _L33= last 'communicationSessionInitiatedFromTrackside;
          sessionStatus_loc= _L34;
          establishingACommunicationSessionAborted= _L35;
          requestTheSetupOfASafeRadioConnection_loc= _L20;
          requestsToSetupTheSafeRadioConnectionStopped= _L28;
          _L37= isPartOfAnOngoingStartOfMissionProcedure;
          _L38= _L44.valid;
          _L39= _L44.connectionStatus;
          _L40= _L39 = _L41;
          _L41= mswc_registered;
          _L42= _L38 and _L40;
          _L44= last 'mobileSWStatus_loc;
          _L45= _L44.settingUpConnectionHasFailed;
          _L46= endOfMissionIsExecuted;
          _L47= trainPassesALevelTransitionBorder;
          _L49= orderToEstablishACommunicationSession_fromOBU;
          _L50= orderDoesNotRequestToContactAnAcceptingRBC;
          _L51= trainPassesA_RBC_RBC_border_WithItsFrontEnd;
          _L52= systemVersionFromTracksideSupported;
          _L53= systemVersionReceived;
          InformTheDriverThatNoConnectionWasSetup= _L19;
          sendTheMessageInitiationOfCommunicationSessionToTrackside= _L21;
          sendMessage_NoCompatibleVersionSupported= _L23;
          sendASessionEstablishedReportToTrackside= _L25;
          finalAttemptToSetupTheSafeRadioConnectionFailed= _L27;
          _L55= orderReceivedFromTrackside_loc;
          firstRequestToSetupASafeRadioConnection= _L26;
          sessionSuccessfullyEstablished= _L31;
          requestTheSetupOfASafeRadioConnection= _L20;
          _L56= m38_initiationOfACommunicationSession;
          _L34= Radio_Types_Pkg::morc_st_establishing;
        tel
        until
          if startTerminatingSession or initiateTermination
            do let emit 'notReady; tel restart Terminating;
          if sessionEstablished do let emit 'notReady; tel restart Maintaining;

      state Maintaining
        var
          _L5 : bool;
          _L4 : bool;
          _L3 : bool;
          _L2 : bool;
          _L1 : bool;
          _L6 : bool;
          _L9 : time_Type;
          _L10 : bool;
          _L11 : mobileSWStatus_Type;
          _L12 : bool;
          _L13 : mobileSWConnectionStatus_Type;
          _L14 : mobileSWConnectionStatus_Type;
          _L15 : bool;
          _L17 : bool;
          _L18 : bool;
          _L19 : bool;
          _L27 : mobileSWCmd_Type;
          _L28 : mobileSWCmd_Type;
          _L29 : mobileSWCmd_Type;
          _L30 : mobileSWCmd_Type;
          _L31 : mobileSWCmd_Type;
          _L32 : mobileSWConnectionStatus_Type;
          _L33 : bool;
          _L8 : Radio_Types_Pkg::sessionStatus_Type;
        let
          _L1, _L2, _L3, _L4, _L5=
            #1 Subfunc_Pkg::maintaining_a_Session(_L10, _L17, _L18, _L6, _L19,
              _L9);
          _L6= true;
          sessionStatus_loc= _L8;
          finalAttemptToSetupTheSafeRadioConnectionFailed= _L4;
          _L9= currentTime;
          _L10= last 'sessionEstablished;
          _L11= last 'mobileSWStatus_loc;
          _L12= _L11.valid;
          _L13= _L11.connectionStatus;
          _L14= mswc_unregistered;
          _L15= _L13 = _L14;
          _L17= _L12 and _L33;
          _L18= _L12 and _L15;
          _L19= trainFrontInsideInAnAnnouncedRadioHole;
          mobileSWCmd= _L31;
          _L27= cInvalidMobileSWCmd;
          _L28= cTerminateSafeRadioConnectionCmd;
          _L29= cRegisterSafeRadioConnectionCmd;
          _L30= if _L1 then _L29 else _L27;
          _L31= if _L5 then _L28 else _L30;
          InformTheDriverThatNoConnectionWasSetup= _L2;
          firstRequestToSetupASafeRadioConnection= _L3;
          _L32= mswc_registered;
          _L33= _L32 = _L13;
          _L8= Radio_Types_Pkg::morc_st_maintaining;
        tel
        until
          if startTerminatingSession or initiateTermination
            do let emit 'notReady; tel restart Terminating;

      state Terminating
        var
          _L4 : bool;
          _L3 : bool;
          _L2 : bool;
          _L1 : bool;
          _L12 : bool;
          _L15 : Radio_Types_Pkg::sessionStatus_Type;
          _L17 : bool;
          _L18 : time_Type;
          _L20 : bool;
          _L22 : bool;
          _L23 : bool;
          _L24 : bool;
          _L26 : mobileSWCmd_Type;
          _L27 : mobileSWCmd_Type;
          _L28 : mobileSWCmd_Type;
          _L13 : Radio_Types_Pkg::sessionStatus_Type;
          _L21 : Radio_Types_Pkg::sessionStatus_Type;
          _L16 : Radio_Types_Pkg::sessionStatus_Type;
        let
          _L1, _L2, _L3, _L4, _L12=
            #1 Subfunc_Pkg::terminating_a_CommunicationSession(_L23, _L20, _L22,
              _L17, _L18, _L24);
          _= _L4;
          sessionTerminated= _L12;
          sessionStatus_loc= _L13;
          _L15= last 'sessionStatus_loc;
          _L17= _L15 = _L16;
          _L18= currentTime;
          _L20= _L21 = _L15;
          _L22= acknowledgementOfTerminationOfCommunicationSessionReceived;
          _L23= true;
          _L24= last 'establishingACommunicationSessionAborted;
          sendATerminationOfCommunicationMessage= _L1;
          ignoreMessagesFromRBC_except_m39_AckOfTerminationOfCommunicationSession=
            _L3;
          mobileSWCmd= _L26;
          _L26= if _L2 then _L28 else _L27;
          _L27= cInvalidMobileSWCmd;
          _L28= cTerminateSafeRadioConnectionCmd;
          requestReleaseOfSafeRadioConnectionWithTrackside= _L2;
          _L13= Radio_Types_Pkg::morc_st_terminating;
          _L21= Radio_Types_Pkg::morc_st_maintaining;
          _L16= Radio_Types_Pkg::morc_st_establishing;
        tel
        until
          if sessionTerminated do let emit 'notReady; tel restart NoSession;
    returns ..;
    _L1, _L2, _L3, _L4, _L5, _L6=
      #1 Subfunc_Pkg::registeringToTheRadioNetwork(_L29, _L48, _L31, _L52, _L51,
        _L30, _L44, _L45, _L46, _L49, _L50, _L64, _L47);
    _L7=
      #1 Subfunc_Pkg::safeRadioConnectionIndication(_L66, _L69, _L69, _L70,
        _L86, _L89, _L92, _L71, _L67, _L73, _L73, _L68);
    _L18, _L19=
      #1 Subfunc_Pkg::initiateTerminatingASession(_L21, _L22, _L23, _L24, _L25,
        _L21, _L20, _L28, _L56, _L27);
    _L20= currentTime;
    initiateTermination= _L61;
    _L21= orderReceivedFromTrackside;
    _L22= errorConditionRequiringTerminationDetected;
    _L23= trainIsRejectedByRBC_duringStartOfMission;
    _L24= driverClosesTheDeskduringStartOfMission;
    _L25= trainExitedFromAnRBCArea;
    _L27= endOfMissionIsExecuted;
    _L28= isInCommunicationSessionWithAnRIU;
    sendAPositionReport= _L19;
    _L29= atPowerUp;
    _L30= atPowerDown;
    _L31= level;
    _L44= RadioNetworkID_memorized;
    _L45= RadioNetworkID_fromDriver;
    _L46= RadioNetworkID_fromTrackside;
    _L47= RadioNetworkID_Default;
    _L48= afterDriverEntryOfANewRadioNetworkID;
    _L49= triggerDecisionThatNoRadioNetworkIDAvailable;
    _L50= mobileHWStatus;
    mobileHWCmd= _L5;
    _L51= requestsToSetupTheSafeRadioConnectionStopped;
    _L52= requestTheSetupOfASafeRadioConnection_loc;
    memorizeTheLastRadioNetworkID= _L2;
    currentRadioNetworkID= _L3;
    orderTheRegistrationOfItsConnectedMobiles= _L1;
    rejectOrderToContactRBC_or_RIU= _L4;
    mobileSWStatus_loc= _L6;
    _L53= level;
    _L54= M_LEVEL_Level_1;
    _L55= _L53 = _L54;
    _L56= #1 digital::FallingEdge(_L55);
    _L57, _L58, _L59=
      #1 Subfunc_Pkg::terminateAndEstablishSession(_L21, _L60, _L65);
    _L60= sessionStatus_loc;
    _L61= _L18 or _L57;
    initiateEstablishingNewSession= _L58;
    prevSessionTerminatedDueToLossOfSafeRadioConnection= _L63;
    _L63= finalAttemptToSetupTheSafeRadioConnectionFailed;
    _L64= mobileSWCmd;
    orderReceivedFromTrackside_loc= _L59;
    _L65= OBU_hasToEstablishANewSession;
    _L66= startOfMissionProcedureIsGoingOn;
    _L67= currentTime;
    _L68= connectionStatusTimerInterval;
    _L69= finalAttemptToSetupTheSafeRadioConnectionFailed;
    _L70= requestsToSetupTheSafeRadioConnectionStopped;
    _L71= trainFrontInsideInAnAnnouncedRadioHole;
    _L72= mobileSWStatus_loc;
    _L73= firstRequestToSetupASafeRadioConnection;
    _L74= _L72.valid;
    _L75= _L72.connectionStatus;
    _L80= mswc_registered;
    _L83= mswc_unregistered;
    _L85= _L75 = _L80;
    _L86= _L74 and _L87;
    _L87= #1 digital::RisingEdge(_L85);
    _L88= #2 digital::FallingEdge(_L85);
    _L89= _L74 and _L88;
    _L90= #2 digital::RisingEdge(_L91);
    _L91= _L75 = _L83;
    _L92= _L74 and _L90;
    safeRadioConnectionStatus_toDriver= _L7;
    mobileSWStatus= _L6;
    _L93= 'notReady;
    _L94= communicationSessionInitiatedByOBU;
    _L95= communicationSessionInitiatedFromTrackside;
    _L96= establishingACommunicationSessionAborted;
    _L97= finalAttemptToSetupTheSafeRadioConnectionFailed;
    _L98= mobileSWStatus_loc;
    _L99= sessionEstablished;
    _L100= sessionStatus_loc;
    _L101= #1 digital::EitherEdge(_L94);
    _L107= #2 digital::EitherEdge(_L95);
    _L108= #3 digital::EitherEdge(_L96);
    _L109= #4 digital::EitherEdge(_L97);
    _L110= #5 digital::EitherEdge(_L99);
    _L111= fby(_L98; 1; cInvalidMobileSWStatus);
    _L112= _L98 <> _L111;
    _L113= fby(_L100; 1; Radio_Types_Pkg::morc_st_inactive);
    _L114= _L100 <> _L113;
    _L115= _L93 or _L101 or _L107 or _L108 or _L109 or _L110 or _L112 or _L114;
    ready= _L116;
    _L116= not _L115;
    sessionStatus= _L117;
    _L117= sessionStatus_loc;
  tel
  
  node MoRC_Main(
      currentTime : Obu_BasicTypes_Pkg::T_internal_Type;
      mode : M_MODE;
      level : M_LEVEL;
      obuEventsAndPhases : obuEventsAndPhases_T;
      radioNetworkIDs : radioNetWorkIDs_T;
      statusOfMobile : mobileHWStatus_Type;
      inMessage : Common_Types_Pkg::radioManagementMessage_T;
      t_train : T_TRAIN;
      connectionStatusTimerInterval : time_Type;
      nid_engine : NID_ENGINE;
      onboardPhoneNumbers
      : Packet_TrainTypes_Pkg::PT3_OnboardTelephoneNumbers_T)
    returns (
      ignoreMessagesFromRBC_except_m39_AckOfTerminationOfCommunicationSession
      : bool;
      sendAPositionReport : bool;
      cmdsToMobile : mobileHWCmd_Type;
      memorizeTheLastRadioNetworkID : bool;
      currentRadioNetworkID : Packet_Types_Pkg::P45_RadioNetworkRegistration_T;
      orderTheRegistrationOfItsConnectedMobiles : bool;
      rejectOrderToContactRBC_or_RIU : bool;
      InformTheDriverThatNoConnectionWasSetup : bool;
      safeRadioConnectionStatus_toDriver : safeRadioConnectionStatusValid_Type;
      mobileSWStatus : mobileSWStatus_Type;
      requestTheSetupOfASafeRadioConnection : bool;
      requestReleaseOfSafeRadioConnectionWithTrackside : bool;
      sessionSuccessfullyEstablished : bool;
      sessionStatus : Radio_Types_Pkg::sessionStatus_Type;
      MessageToRBC : Radio_Types_Pkg::Radio_TrainTrack_Message_T;
      ready : bool)
  var
    p42_establish_or_terminate : Coder_Pkg::p42_order_T;
    p45_radioNetworkRegistration
    : Packet_Types_Pkg::P45_RadioNetworkRegistration_T;
    m38_initiationOfACommunicationSession : bool;
    m39_acknowledgementOfTerminationOfACommunicationSession : bool;
    m32_RBC_or_RIU_System_Version : Coder_Pkg::m32e_RBC_or_RIU_System_Version_T;
    m154_noCompatibleVersionSupported : bool;
    m155_initiationOfACommunicationSession : bool;
    m156_terminationOfACommunicationSession : bool;
    m159_sessionEstablished : bool;
    _L15 : Coder_Pkg::p42e_SessionManagement_T;
    _L50 : bool;
    _L49 : bool;
    _L48 : bool;
    _L47 : mobileSWStatus_Type;
    _L46 : bool;
    _L45 : safeRadioConnectionStatusValid_Type;
    _L44 : bool;
    _L43 : bool;
    _L42 : bool;
    _L41 : bool;
    _L40 : bool;
    _L39 : bool;
    _L38 : bool;
    _L37 : bool;
    _L36 : Packet_Types_Pkg::P45_RadioNetworkRegistration_T;
    _L35 : bool;
    _L34 : mobileHWCmd_Type;
    _L33 : bool;
    _L51 : Obu_BasicTypes_Pkg::T_internal_Type;
    _L54 : bool;
    _L56 : M_LEVEL;
    _L57 : M_MODE;
    _L58 : M_MODE;
    _L59 : M_MODE;
    _L60 : bool;
    _L61 : Common_Types_Pkg::MsgSource_T;
    _L62 : Common_Types_Pkg::MsgSource_T;
    _L63 : bool;
    _L64 : bool;
    _L65 : Common_Types_Pkg::MsgSource_T;
    _L66 : bool;
    _L67 : bool;
    _L68 : Coder_Pkg::p42e_SessionManagement_T;
    _L69 : Common_Types_Pkg::MsgSource_T;
    _L70 : bool;
    _L71 : Common_Types_Pkg::MsgSource_T;
    _L72 : Coder_Pkg::p42e_SessionManagement_T;
    _L74 : Coder_Pkg::p42e_SessionManagement_T;
    _L75 : Coder_Pkg::p42e_SessionManagement_T;
    _L76 : bool;
    _L77 : bool;
    _L86 : radioNetWorkIDs_T;
    _L87 : Packet_Types_Pkg::P45_RadioNetworkRegistration_T;
    _L88 : radioNetWorkIDs_T;
    _L89 : Packet_Types_Pkg::P45_RadioNetworkRegistration_T;
    _L90 : Packet_Types_Pkg::P45_RadioNetworkRegistration_T;
    _L91 : obuEventsAndPhases_T;
    _L92 : bool;
    _L93 : bool;
    _L94 : bool;
    _L95 : bool;
    _L96 : bool;
    _L97 : bool;
    _L98 : bool;
    _L99 : bool;
    _L100 : bool;
    _L102 : bool;
    _L105 : bool;
    _L106 : bool;
    _L107 : bool;
    _L108 : bool;
    _L109 : bool;
    _L111 : bool;
    _L112 : bool;
    _L113 : bool;
    _L114 : bool;
    _L115 : bool;
    _L116 : bool;
    _L117 : bool;
    _L119 : bool;
    _L120 : bool;
    _L121 : bool;
    _L122 : bool;
    _L123 : bool;
    _L125 : bool;
    _L127 : time_Type;
    _L130 : mobileHWStatus_Type;
    _L131 : Radio_Types_Pkg::sessionStatus_Type;
    _L132 : Common_Types_Pkg::radioManagementMessage_T;
    _L143 : Packet_Types_Pkg::P45_RadioNetworkRegistration_T;
    _L142 : Packet_Types_Pkg::P42_SessionManagement_T;
    _L141 : Radio_Types_Pkg::Radio_TrackTrain_Header_T;
    _L140 : Common_Types_Pkg::MsgSource_T;
    _L139 : bool;
    _L145 : Coder_Pkg::p42_order_T;
    _L146 : Packet_Types_Pkg::P42_SessionManagement_T;
    _L147 : bool;
    _L148 : bool;
    _L149 : bool;
    _L150 : Packet_Types_Pkg::P45_RadioNetworkRegistration_T;
    _L151 : bool;
    _L152 : bool;
    _L154 : Common_Types_Pkg::MsgSource_T;
    _L156 : Common_Types_Pkg::MsgSource_T;
    _L158 : bool;
    _L159 : bool;
    _L160 : bool;
    _L161 : NID_MESSAGE;
    _L163 : bool;
    _L166 : bool;
    _L167 : bool;
    _L168 : bool;
    _L169 : bool;
    _L170 : Coder_Pkg::m32e_RBC_or_RIU_System_Version_T;
    _L171 : NID_MESSAGE_Type;
    _L172 : bool;
    _L173 : bool;
    _L174 : M_VERSION;
    _L175 : bool;
    _L176 : Coder_Pkg::p42_order_T;
    _L177 : Coder_Pkg::m32e_RBC_or_RIU_System_Version_T;
    _L178 : bool;
    _L179 : bool;
    _L180 : Packet_Types_Pkg::P45_RadioNetworkRegistration_T;
    _L181 : bool;
    _L182 : Coder_Pkg::m32e_RBC_or_RIU_System_Version_T;
    _L183 : NID_MESSAGE;
    _L184 : NID_MESSAGE;
  let
    _L15= #1 Coder_Pkg::P42_Dec(_L176, _L60);
    _L33, _L34, _L35, _L36, _L37, _L38, _L39, _L40, _L41, _L42, _L43, _L44,
      _L45, _L46, _L47, _L48, _L49, _L131, _L50=
      #1 managementOfRadioCommunication(_L51, _L179, _L74, _L125, _L67, _L117,
        _L115, _L92, _L93, _L94, _L95, _L96, _L97, _L56, _L89, _L90, _L180,
        _L98, _L99, _L130, _L100, _L102, _L68, _L123, _L105, _L77, _L76, _L57,
        _L106, _L107, _L108, _L109, _L111, _L112, _L113, _L114, _L181, _L87,
        _L127);
    _L51= currentTime;
    _L54= _L15.establish;
    _L56= level;
    _L57= mode;
    _L58= M_MODE_Sleeping;
    _L59= mode;
    _L60= _L59 = _L58;
    _L61= _L15.source;
    _L62= Common_Types_Pkg::msrc_Euroradio;
    _L63= _L61 = _L62;
    _L64= _L54 and _L63;
    _L65= Common_Types_Pkg::msrc_RadioInfillUnit;
    _L66= _L61 = _L65;
    _L67= _L54 and _L66;
    _L68= if _L70 then _L15 else _L72;
    _L69= _L15.source;
    _L70= _L71 = _L69;
    _L71= Common_Types_Pkg::msrc_OBU;
    _L72= Coder_Pkg::cInvalidOrder;
    _L74= if _L70 then _L75 else _L15;
    _L75= Coder_Pkg::cInvalidOrder;
    _L76= _L182.valid;
    _L77= _L182.systemVersionFromTracksideSupported;
    _L86= radioNetworkIDs;
    _L87= _L86.defaultID;
    _L88= radioNetworkIDs;
    _L89= _L88.memorizedID;
    _L90= _L88.ID_fromDriver;
    _L91= obuEventsAndPhases;
    _L92= _L91.driverClosesTheDeskduringStartOfMission;
    _L93= _L91.trainExitedFromAnRBCArea;
    _L94= _L91.endOfMissionIsExecuted;
    _L95= _L91.isInCommunicationSessionWithAnRIU;
    _L96= _L91.atPowerUp;
    _L97= _L91.atPowerDown;
    _L98= _L91.afterDriverEntryOfANewRadioNetworkID;
    _L99= _L91.triggerDecisionThatNoRadioNetworkIDAvailable;
    _L100= _L91.isPartOfAnOngoingStartOfMissionProcedure;
    _L102= _L91.trainPassesALevelTransitionBorder;
    _L105= _L91.trainPassesA_RBC_RBC_border_WithItsFrontEnd;
    _L106= _L91.atStartOfMission;
    _L107= _L91.modeChangeHasToBeReportedToRBC;
    _L108= _L91.driverHasManuallyChangedLevel;
    _L109= _L91.trainFrontReachesEndOfAnnouncedRadioHole;
    _L111= _L91.startOfMissionProcedureCompleted;
    _L112= _L91.trainFrontInsideInAnAnnouncedRadioHole;
    _L113= _L91.OBU_hasToEstablishANewSession;
    _L114= _L91.startOfMissionProcedureIsGoingOn;
    _L115= _L91.trainIsRejectedByRBC_duringStartOfMission;
    _L116= _L91.errorConditionRequiringTerminationDetected;
    _L117= _L122 or _L116;
    _L119= _L177.systemVersionFromTracksideSupported;
    _L120= _L177.valid;
    _L121= not _L119;
    _L122= _L121 and _L120;
    _L123= _L15.establishOrderDoesNotRequestToContactAnAcceptingRBC;
    _L125= _L178 or _L64;
    _L127= connectionStatusTimerInterval;
    ignoreMessagesFromRBC_except_m39_AckOfTerminationOfCommunicationSession=
      _L44;
    sendAPositionReport= _L33;
    cmdsToMobile= _L34;
    memorizeTheLastRadioNetworkID= _L35;
    currentRadioNetworkID= _L36;
    orderTheRegistrationOfItsConnectedMobiles= _L37;
    rejectOrderToContactRBC_or_RIU= _L38;
    InformTheDriverThatNoConnectionWasSetup= _L39;
    safeRadioConnectionStatus_toDriver= _L45;
    sessionSuccessfullyEstablished= _L46;
    requestTheSetupOfASafeRadioConnection= _L48;
    requestReleaseOfSafeRadioConnectionWithTrackside= _L49;
    ready= _L50;
    _L130= statusOfMobile;
    sessionStatus= _L131;
    _L132= inMessage;
    _L139, _L140, _L141, _L142, _L143=
      (flatten Common_Types_Pkg::radioManagementMessage_T)(_L132);
    _L145= (make Coder_Pkg::p42_order_T)(_L140, _L149, _L146);
    _L146= (_L142 with .valid = _L147);
    _L147= _L139 and _L148;
    _L148= _L142.valid;
    p42_establish_or_terminate= _L145;
    _L149= false;
    p45_radioNetworkRegistration= _L150;
    _L150= (_L143 with .valid = _L152);
    _L151= _L143.valid;
    _L152= _L139 and _L151;
    _L154= Common_Types_Pkg::msrc_Euroradio;
    _L156= Common_Types_Pkg::msrc_RadioInfillUnit;
    _L158= _L140 = _L154;
    m38_initiationOfACommunicationSession= _L167;
    _L159= _L140 = _L156;
    _L160= _L158 or _L159;
    _L161= _L141.nid_message;
    _L163= _L161 = _L183;
    m39_acknowledgementOfTerminationOfACommunicationSession= _L169;
    _L166= _L139 and _L160;
    _L167= _L166 and _L163;
    _L168= _L161 = _L184;
    _L169= _L166 and _L168;
    _L170=
      (make Coder_Pkg::m32e_RBC_or_RIU_System_Version_T)(_L173, _L174, _L175);
    _L171= cNID_MESSAGE_RBC_RIU_SystemVersion;
    _L172= _L161 = _L171;
    _L173= _L166 and _L172;
    m32_RBC_or_RIU_System_Version= _L170;
    _L174= _L141.m_version;
    _L175= true;
    _L176= p42_establish_or_terminate;
    _L177= m32_RBC_or_RIU_System_Version;
    _L178= m38_initiationOfACommunicationSession;
    _L179= m39_acknowledgementOfTerminationOfACommunicationSession;
    _L180= p45_radioNetworkRegistration;
    _L181= m38_initiationOfACommunicationSession;
    _L182= m32_RBC_or_RIU_System_Version;
    _L183= Id_Pkg::cm38_Initiation_of_a_Communication_Session;
    _L184=
      Id_Pkg::cm39_Acknowledgement_of_termination_of_a_communication_session;
    m154_noCompatibleVersionSupported= _L41;
    m155_initiationOfACommunicationSession= _L40;
    m156_terminationOfACommunicationSession= _L43;
    m159_sessionEstablished= _L42;
    activate ifMessageToRBC if m155_initiationOfACommunicationSession
      then var
        _L8 : NID_MESSAGE;
        _L7 : T_TRAIN;
        _L6 : Radio_Types_Pkg::Radio_TrainTrack_Message_T;
        _L5 : NID_ENGINE;
        _L9 : bool;
      let
        _L5= nid_engine;
        _L6= #6 Coder_Pkg::genMsgToRBC(_L9, _L8, _L7, _L5);
        _L7= t_train;
        _L8= Id_Pkg::co155_Initiation_of_a_communication_session;
        MessageToRBC= _L6;
        _L9= true;
      tel
      else if m156_terminationOfACommunicationSession
      then var
        _L4 : NID_MESSAGE;
        _L3 : T_TRAIN;
        _L2 : Radio_Types_Pkg::Radio_TrainTrack_Message_T;
        _L1 : NID_ENGINE;
        _L5 : bool;
      let
        _L1= nid_engine;
        _L2= #8 Coder_Pkg::genMsgToRBC(_L5, _L4, _L3, _L1);
        _L3= t_train;
        _L4= Id_Pkg::co156_Termination_of_a_communication_session;
        _L5= true;
        MessageToRBC= _L2;
      tel
      else if m159_sessionEstablished
      then var
        _L1 : NID_MESSAGE;
        _L12 : Radio_Types_Pkg::Radio_TrainTrack_Message_T;
        _L11 : T_TRAIN;
        _L10 : bool;
        _L9 : NID_ENGINE;
        _L13 : Packet_TrainTypes_Pkg::PT3_OnboardTelephoneNumbers_T;
        _L15 : Radio_Types_Pkg::Radio_TrainTrack_Message_T;
      let
        _L1= Id_Pkg::co159_Session_established;
        _L9= nid_engine;
        MessageToRBC= _L15;
        _L10= true;
        _L11= t_train;
        _L12= #11 Coder_Pkg::genMsgToRBC(_L10, _L1, _L11, _L9);
        _L13= onboardPhoneNumbers;
        _L15= (_L12 with .packets.p3 = _L13);
      tel
      else if m154_noCompatibleVersionSupported
      then var
        _L4 : NID_ENGINE;
        _L2 : T_TRAIN;
        _L1 : Radio_Types_Pkg::Radio_TrainTrack_Message_T;
        _L5 : bool;
        _L6 : NID_MESSAGE;
      let
        _L1= #13 Coder_Pkg::genMsgToRBC(_L5, _L6, _L2, _L4);
        _L2= t_train;
        _L4= nid_engine;
        MessageToRBC= _L1;
        _L5= true;
        _L6= Id_Pkg::co154_No_Compatible_Version_Support;
      tel
      else var
        _L1 : Radio_Types_Pkg::Radio_TrainTrack_Message_T;
      let
        _L1= cNoMessageToRBC;
        MessageToRBC= _L1;
      tel
    
    returns ..;
    mobileSWStatus= _L47;
  tel
  
end;

/* $*************** KCG Version 6.1.3 (build i6) ****************
** -
** Generation date: 2015-05-27T21:43:22
*************************************************************$ */
